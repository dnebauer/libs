#!/bin/bash

# Suite: libdncommon-bash
# File: liball
# Author: David Nebauer (david at nebauer dot org)
# Purpose: Useful bash functions
# Created: 2024-10-05

# TODO: make clear when 'list' refers to string rather than array?

# ERROR HANDLING    {{{1

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail
# Turn on traces, useful while debugging but commented out by default
# set -o xtrace

# VARIABLES    {{{1

dn_self="$(basename "${0}")" # name of calling app
dn_true=0 dn_false=1         # boolean values
dn_temp_file_dirs=()         # all temp file and dir names
declare -a dn_IFS_stack=()   # manipulate IFS system variable
declare -a dn_ping_urls=( # urls for checking internet connectivity
	'www.google.com'
	'www.debian.org'
	'www.uq.edu.au'
)
# dialog labels used in associative arrays
# • list in order of preference
# • synchronise with dnDialogType help
declare -a dn_dlgs=(
	'zenity'
	'kdialog'
	'gxmessage'
	'xmessage'
	'dialog'
)
declare -A dn_dlg_names=( # readable dialog names
	[dialog]=Dialog
	[gxmessage]=GXMessage
	[kdialog]=KDialog
	[xmessage]=XMessage
	[zenity]=Zenity
)
declare -A dn_dlg_bins=( # dialog binaries to execute
	[dialog]=dialog
	[gxmessage]=gxmessage
	[kdialog]=kdialog
	[xmessage]=xmessage
	[zenity]=zenity
)
# dialog capabilities
# • synchronise with dnDialogType help
#   newline_character - respects hard newlines
#      newline_escape - respects '\n'
#                info - can use for information dialogs
#                warn - can use for warning dialogs
#               error - can use for error dialogs
#               popup - can use for popup dialogs
#             confirm - can use for confirmation dialogs
#              select - can use for selection dialogs
#                 dir - can use for directory selection dialogs
#                file - can use for file selection dialogs
#                 gui - requires a gui desktop
#            terminal - requires a terminal
declare -A dn_dlgs_capabilities=( # dialog capabilities
	[dialog]='newline_character newline_escape info warn error popup confirm select dir file terminal'
	[gxmessage]='newline_character info warn error popup confirm gui'
	[kdialog]='newline_character newline_escape info warn error popup confirm select file gui'
	[xmessage]='newline_character info warn error popup confirm gui'
	[zenity]='newline_character newline_escape info warn error popup confirm select dir file gui'
)
# example usage of command:
#   cmd="${dn_dlg_cmds_popup['kdialog']}" # get dialog commadn
#   cmd="${cmd/<T>/Coolant system Shutdown}" # replace title placeholder token
#   msg="Five minutes to reactor core overload\nGet to minimum safe distance"
#   cmd="${cmd/<M>/${msg}}" # replace message placeholder token
#   cmd="${cmd/<D>/10}" # replace timeout placeholder token
#   eval "${cmd}" # 'eval' is required to handle quotes
# command placeholders:
#   <C> = cue/prompt
#   <D> = duration
#   <F> = file name filter
#   <M> = message
#   <P> = path (directory or file)
#   <T> = title
dn_dlg_gxm_opts="-wrap -buttons \"GTK_STOCK_OK:0\" -default \"GTK_STOCK_OK\" -title \"<T>\""
dn_dlg_xm_opts="-buttons \"OK:0\" -default \"OK\" -title \"<T>\""
declare -A dn_dlg_cmds_info=( # commands to display information dialog
	[dialog]="dialog --title \"<T>\" --clear --erase-on-exit --msgbox \"<M>\" 0 0"
	[gxmessage]="gxmessage ${dn_dlg_gxm_opts} \"<M>\""
	[kdialog]="kdialog --title \"<T>\" --msgbox \"<M>\""
	[xmessage]="xmessage ${dn_dlg_xm_opts} \"<M>\""
	[zenity]="zenity --info --title \"<T>\" --text \"<M>\""
)
declare -A dn_dlg_cmds_warn=( # commands to display warning dialog
	[dialog]="dialog --title \"<T>\" --clear --erase-on-exit --msgbox \"WARNING: <M>\" 0 0"
	[gxmessage]="gxmessage ${dn_dlg_gxm_opts} -bg yellow \"WARNING: <M>\""
	[kdialog]="kdialog --title \"<T>\" --sorry \"<M>\""
	[xmessage]="xmessage ${dn_dlg_xm_opts} -bg yellow \"WARNING: <M>\""
	[zenity]="zenity --warning --title \"<T>\" --text \"<M>\""
)
declare -A dn_dlg_cmds_error=( # commands to display error dialog
	[dialog]="dialog --title \"<T>\" --clear --erase-on-exit --msgbox \"ERROR: <M>\" 0 0"
	[gxmessage]="gxmessage ${dn_dlg_gxm_opts} -fg white -bg red \"ERROR: <M>\""
	[kdialog]="kdialog --title \"<T>\" --error \"<M>\""
	[xmessage]="xmessage ${dn_dlg_xm_opts} -fg white -bg red \"ERROR: <M>\""
	[zenity]="zenity --error --title \"<T>\" --text \"<M>\""
)
# popup duration unit for all dialogs is: seconds
declare -A dn_dlg_cmds_popup=( # commands to display popup dialog
	[dialog]="dialog --title \"<T>\" --clear --erase-on-exit --timeout <D> --msgbox \"<M>\" 0 0"
	[gxmessage]="gxmessage ${dn_dlg_gxm_opts} -timeout <D> \"<M>\""
	[kdialog]="kdialog --title \"<T>\" --passivepopup \"<M>\" <D>"
	[xmessage]="xmessage ${dn_dlg_xm_opts} -timeout <D> \"<M>\""
	[zenity]="zenity --info --title \"<T>\" --text \"<M>\" --timeout <D> &"
)
dn_dlg_gxm_opts="-wrap -buttons \"GTK_STOCK_YES:0,GTK_STOCK_NO:2\" -default \"GTK_STOCK_YES\""
dn_dlg_xm_opts="-buttons \"Yes:0,No:2\" -default \"Yes\""
declare -A dn_dlg_cmds_confirm=( # commands to display confirmation dialog
	[dialog]="dialog --title \"<T>\" --clear --erase-on-exit --yesno \"<M>\" 0 0"
	[gxmessage]="gxmessage ${dn_dlg_gxm_opts} -title \"<T>\" \"<M>\""
	[kdialog]="kdialog --title \"<T>\" --yesno \"<M>\""
	[xmessage]="xmessage ${dn_dlg_xm_opts} -title \"<T>\" \"<M>\""
	[zenity]="zenity --question --title \"<T>\" --text \"<M>\""
)
unset dn_dlg_gxm_opts dn_dlg_xm_opts
# directory selection
# • kdialog is broken for directory selection
# • dialog is given a help button (see dn_dlg_dialog_help_dir_select)
declare -A dn_dlg_cmds_dir_select=( # commands to display directory selection dialog
	[dialog]="dialog --stdout --help-button --clear --erase-on-exit --title \"<C>\" --dselect \"<P>\" 0 0"
	[zenity]="zenity --title \"<C>\" --file-selection --directory --filename=\"<P>\""
)
declare -a dn_dlg_dialog_help_dir_select=(
	'HOTKEYS ARE BROKEN'
	"\nDo NOT use button hotkeys - doing so simulates pressing [Esc]. Instead,"
	'tab to the desired key and press [Enter].'
	"\n"
	"\nMOVING BETWEEN BETWEEN AND WITHIN DIALOG PARTS"
	"\nThe dialog consists of the 'Directories' panel, the selection field"
	'(into which you can type directly), and the <OK>, <Cancel> and <Help>'
	'buttons. Use arrow and [Tab] keys to navigate between dialog parts. The'
	"cursor indicates which dialog part you are in. Inside the 'Directories'"
	'panel use [UpArrow], [DownArrow], [PageUp] and [PageDown] to move.'
	"\n"
	"\nSELECTING A DIRECTORY OR FILE"
	"\nThe [Enter] key is your enemy - do NOT use it until the full path you"
	'want is in the selection field.'
	"\n"
	"\nThe [Space] key IS your friend. Pressing it while in the 'Directory'"
	'panel will add the selected subdirectory name to the content of the'
	'selection field, and move the cursor to the end of that field.'
	"\n"
	"\nIf you have added a subdirectory using [Space], type a terminal slash"
	"to open that subdirectory in the 'Directory' panel. The only way to move"
	"to a parent directory is to move to the '..' entry, press [Space] to add"
	'it to the selection field, and then add a terminal slash to open the'
	"parent directory. (For this reason it is prudent to call 'realpath' on"
	'the returned value from this dialog.)'
	"\n"
	"\nNote: it is also possible to type the desired path directly into the"
	'selection field.'
	"\n"
	"\nSELECTING A DIRECTORY"
	"\nOnce you have the full desired path in the selection field, navigate to"
	'the <OK> button and press [Enter] to accept the selection.'
)
dn_dlg_text_help_dir_select=$(
	cat <<-END
		HOW TO SELECT A DIRECTORY IN DIALOG

		* Hotkeys Are Broken *

		Do NOT use button hotkeys - doing so simulates pressing [Esc]. Instead,
		tab to the desired key and press [Enter].

		* Moving Between Between And Within Dialog Parts *

		The dialog consists of the 'Directories' panel, the selection field
		(into which you can type directly), and the <OK>, <Cancel> and <Help>
		buttons. Use arrow and [Tab] keys to navigate between dialog parts. The
		cursor indicates which dialog part you are in. Inside the 'Directories'
		panel use [UpArrow], [DownArrow], [PageUp] and [PageDown] to move.

		* Selecting A Directory Or File *

		The [Enter] key is your enemy - do NOT use it until the full path you
		want is in the selection field.

		The [Space] key IS your friend. Pressing it while in the 'Directory'
		panel will add the selected subdirectory name to the content of the
		selection field, and move the cursor to the end of that field.

		If you have added a subdirectory using [Space], type a terminal slash
		to open that subdirectory in the 'Directory' panel. The only way to move
		to a parent directory is to move to the '..' entry, press [Space] to add
		it to the selection field, and then add a terminal slash to open the
		parent directory. (For this reason it is prudent to call 'realpath' on
		the returned value from this dialog.)

		Note: it is also possible to type the desired path directly into the
		selection field.

		* Selecting A Directory *

		Once you have the full desired path in the selection field, navigate to
		the <OK> button and press [Enter] to accept the selection.
	END
)
# file selection
# • dialog is given a help button (see dn_dlg_dialog_help_file_select)
# • dialog is unable to filter file display on file type
declare -A dn_dlg_cmds_file_select=( # commands to display file selection dialog
	[dialog]="dialog --stdout --help-button --clear --erase-on-exit --title \"<C>\" --fselect \"<P>\" 0 0"
	[kdialog]="kdialog --title \"<C>\" --getopenfilename \"<P>\" \"<F>\""
	[zenity]="zenity --title \"<C>\" --file-selection --file-filter=\"<F>\" --filename=\"<P>\""
)
declare -a dn_dlg_dialog_help_file_select=(
	'HOTKEYS ARE BROKEN'
	"\nDo NOT use button hotkeys - doing so simulates pressing [Esc]. Instead,"
	'tab to the desired key and press [Enter].'
	"\n"
	"\nMOVING BETWEEN BETWEEN AND WITHIN DIALOG PARTS"
	"\nThe dialog consists of the 'Directories' and 'Files' panels, the"
	'selection field (into which you can type directly), and the <OK>,'
	'<Cancel> and <Help> buttons. Use arrow and [Tab] keys to navigate'
	'between dialog parts. The cursor indicates which dialog part you are in.'
	"Inside the 'Directories' and 'Files' panels use [UpArrow], [DownArrow],"
	'[PageUp] and [PageDown] to move.'
	"\n"
	"\nSELECTING A DIRECTORY OR FILE"
	"\nThe [Enter] key is your enemy - do NOT use it until the full path you"
	'want is in the selection field.'
	"\n"
	"\nThe [Space] key IS your friend. Pressing it while in the 'Directory'"
	"or 'File' panel will add the selected subdirectory or file name to the"
	'content of the selection field, and move the cursor to the end of that'
	'field.'
	"\n"
	"\nIf you have added a subdirectory using [Space], type a terminal slash"
	"to open that subdirectory in the 'Directory' and 'File' panels. The only"
	"way to move to a parent directory is to move to the '..' entry, press"
	'[Space] to add it to the selection field, and then add a terminal slash'
	'to open the parent directory. (For this reason it is prudent to call'
	"'realpath' on the returned value from this dialog.)"
	"\n"
	"\nNote: it is also possible to type the desired path directly into the"
	'selection field.'
	"\n"
	"\nSELECTING A FILE"
	"\nOnce you have the full desired path in the selection field, navigate to"
	'the <OK> button and press [Enter] to accept the selection.'
)
dn_dlg_text_help_file_select=$(
	cat <<-END
		HOW TO SELECT A FILE IN DIALOG

		* Hotkeys Are Broken *

		Do NOT use button hotkeys - doing so simulates pressing [Esc]. Instead,
		tab to the desired key and press [Enter].

		* Moving Between Between And Within Dialog Parts *

		The dialog consists of the 'Directories' and 'Files' panels, the
		selection field (into which you can type directly), and the <OK>,
		<Cancel> and <Help> buttons. Use arrow and [Tab] keys to navigate
		between dialog parts. The cursor indicates which dialog part you are in.
		Inside the 'Directories' and 'Files' panels use [UpArrow], [DownArrow],
		[PageUp] and [PageDown] to move.

		* Selecting A Directory Or File *

		The [Enter] key is your enemy - do NOT use it until the full path you
		want is in the selection field.

		The [Space] key IS your friend. Pressing it while in the 'Directory'
		or 'File' panel will add the selected subdirectory or file name to the
		content of the selection field, and move the cursor to the end of that
		field.

		If you have added a subdirectory using [Space], type a terminal slash
		to open that subdirectory in the 'Directory' and 'File' panels. The only
		way to move to a parent directory is to move to the '..' entry, press
		[Space] to add it to the selection field, and then add a terminal slash
		to open the parent directory. (For this reason it is prudent to call
		'realpath' on the returned value from this dialog.)

		Note: it is also possible to type the desired path directly into the
		selection field.

		* Selecting A File *

		Once you have the full desired path in the selection field, navigate to
		the <OK> button and press [Enter] to accept the selection.
	END
)
declare -A dn_dlg_desktop_overrides=( # dialog preference overrides
	[KDE]=kdialog
	["X-Generic"]=xmessage
)
dn_query_prefix='Query: '   # semantic fragment
dn_prompt_prefix='Prompt: ' # semantic fragment
# dividers
dn_divider='-----------------------------------------------------------'
dn_divider_top="${dn_divider}"
dn_divider_bottom='==========================================================='
# capture shopt output when extglobs is set
# • char before 'on' is horizontal tab (ascii 9, oct 011, hex 09, unicode 0009)
# • can obtain value from bash command and compare directly without variable:
#   bash -c 'shopt extglob | xclip -sel clip || true'
dn_shopt_extglob_output='extglob on'
# prevent shellcheck "referenced but not assigned" errors (SC2154)
declare -a dn_ignore_sc2154=(
	"${dn_dlg_cmds_info[*]}" "${dn_dlg_cmds_warn[*]}" "${dn_dlg_cmds_error[*]}"
	"${dn_dlg_cmds_popup[*]}" "${dn_prompt_prefix}" "${dn_divider_top}"
	"${dn_divider_bottom} ${dn_shopt_extglob_output}" "${dn_dlgs[*]}"
	"${dn_dlg_names[*]}" "${dn_dlg_bins[*]}" "${dn_dlgs_capabilities[*]}"
	"${dn_dlg_dialog_help_file_select[*]}" "${dn_dlg_dialog_help_dir_select[*]}"
	"${dn_dlg_desktop_overrides[*]}"
)
echo "${dn_ignore_sc2154[@]}" >/dev/null
# }}}2

# FUNCTION NAMES BY CATEGORY    {{{1

# Arrays :: handling arrays    {{{2

# dnAlphaSortArray      - sort arrays elements on ascending alpha sort
# dnAlphaSortDualArrays - sort one array based on values in another array
# dnArrayToNullDelimitedString
#                       - output array contents as a null-delimited string
# dnConcatArrayItems    - output array contents as a delimited string
# dnElementInArray      - determine whether element present in array
# dnMakeUniqueArrayElement
#                       - ensure element would be unique in array
# dnOutputArray         - output array in form suitable for capture into
#                         another array
# dnPositionInArray     - determine index of first matching array element
# dnPrintArray          - displays formatted array on STDOUT
# dnPrintArrayStderr    - displays formatted array on STDERR
# dnSplitStringIntoArray
#                       - split a string into an array
# dnUseArray            - assist in passing/returning arrays from function

# Control :: program control    {{{2

# dnAbort               - exit script with feedback to stderr
# dnEndScript           - common exit point from script
# dnEndScriptDlg        - common exit point from script
# dnEndScriptPrompt     - common exit point from script requiring prompt
# dnEndScriptStderr     - common exit point from script
# dnFailScript          - exit script with feedback
# dnFailScriptDlg       - exit script with feedback
# dnStackTrace          - print stack trace
# dnStandardiseBoolean  - standardise truth value to '0'|'1'
# dnStandardiseControl  - standardise control term (verb) as boolean

# Convert :: convert file formats    {{{2

# dnColourToRGB         - convert colour name to RGB value
# dnConvertAudioToWav   - convert audio file to WAV format
# dnConvertNonPngToPng  - convert non-PNG image file to PNG format
# dnConvertVobToMpg     - convert VOB video file to MPG format
# dnConvertWavToAc3     - convert audio WAV file to AC3 format
# dnCreateSilentAc3     - create silent AC3 audio file
# dnNumberToWords       - convert number from sequence of digits to sequence
#                         of words

# Devices :: handling devices    {{{2

# dnDiscMount           - mount disc in drive
# dnDiscUnmount         - unmount disc in drive
# dnTrayClose           - close drive tray
# dnTrayEject           - open drive tray

# Files :: handling files/directories    {{{2

# dnBlockExist          - determine whether block special device exists
# dnBlockValid          - determine whether block special device exists and
#                         is readable
# dnBlockValidNoSpaces  - determine whether block special device exists,
#                         is readable and contains no spaces
# dnCountTarzip         - count tarzipped archives in a directory
# dnDirEmpty            - detemine whether directory is empty
# dnDirFileCountXoX     - count number of files having extensions in directory
# dnDirFileDirCount     - count file and subdirectories in a directory
# dnDirFileOnlyCount    - counts files in a directory
# dnDirValid            - determine whether directory exists and is readable
# dnDirValidNoSpaces    - determine whether directory path exists, is readable
#                         and contains no spaces
# dnExtractExtension    - extract extension from filepath
# dnExtractFileBase     - extract file basename from filepath
# dnExtractFilename     - extract filename from filepath
# dnExtractPath         - extract directory path from file path
# dnFileEmpty           - determine whether file is empty
# dnFileSize            - determine file size in bytes
# dnFileValid           - determine whether file exists and is readable
# dnFileValidNoSpaces   - determine whether file exists, is readable and
#                         contains no spaces
# dnFilesystemMounted   - determine whether a block special device or
#                         remote filesystem is mounted
# dnGetDir              - select directory using a dialog
# dnGetFilepath         - select file using a dialog
# dnGetFirstFile        - get first file from a directory
# dnGlobValid           - determine whether there are any matches for glob
# dnIsCvsTree           - determine whether source tree is a CVS tree (Boolean)
# dnIsSvnTree           - determine whether source tree is a subversion tree
# dnMimeType            - get mimetype of file
# dnNormalisePath       - convert relative path to absolute path
# dnParentDir           - extract parent directory path from file or
#                         directory path
# dnStripExtension      - strip extension from filepath
# dnTempDir             - create temporary directory
# dnTempFile            - create temporary file
# dnTempKill            - remove temporary file/dir from list and
#                         reset trap command
# dnTempTrap            - add temporary file/dir to list and reset trap command
# dnTerminalSubdir      - extract terminal subdirectory from directory path
# dnTrueFilepath        - determine true filepath of supplied file
# dnUniqueFileName      - get a unique file name for a given name template
#                         in a specified directory
# dnValidTarzip         - determine whether file is a valid tarzip archive
# dnZeroFileSize        - determine whether file has zero size

# Internet :: handling the internet    {{{2

# dnCheckInternet       - determines whether the internet is accessible
# dnConfigureSsh        - configure ssh tools for password-less operation
# dnReachableRepository - determine whether at least one internet repository
#                         is reachable

# Lists :: handling lists    {{{2

# dnAddToList           - add item to list
# dnElementInList       - determine whether list contains a particular element
# dnFormatList          - format list for display
# dnListCount           - count the number of elements in a list
# dnListExtra           - compare two lists and determine which items in the
#                         first list are not in the second list
# dnListMissing         - compare two lists and determine which items in the
#                         second list are not in the first list
# dnListSubset          - check whether one list contains another
# dnListsIntersect      - determine whether two lists intersect, that is,
#                         share at least one element
# dnPrintElements       - prints list
# dnRemoveDuplicates    - remove duplicate elements from a list
# dnRemoveElements      - remove elements from a list

# Numbers :: handling numbers    {{{2

# dnDecrement           - decrement number
# dnFlagTrue            - check if flag value is true (equal to zero)
# dnIncrement           - increment number
# dnToggleFlag          - invert value of flag
# dnValidGeometry       - determine whether value is a valid X11 geometry value
# dnValidNonZeroPosInt  - determine whether value is a valid, non-zero,
#                         positive integer
# dnValidNumber         - determine whether value is a valid number
# dnValidPosInteger     - determine whether value is a valid positive integer

# Program-interaction :: interacting with other programs    {{{2

# dnAnalyseSvnRepository
#                       - get information about svn repository
# dnDisplayFilesGitRepoStatus
#                       - display status of directory files with regard to
#                                               local git repo
# dnFilesAvailable      - checks list of files to determine whether all
#                         are available
# dnFormatSvnRepDetails - format svn repository details
# dnFunctionsAvailable  - checks list of functions to determine whether all
#                         are available
# dnKeepProgAlive       - endlessly restarts nominated program if it stops
# dnKillPid             - kill process
# dnListUsers           - list all users
# dnLocalGitRepoUptodate
#                       - determine whether local git repo is up to date
# dnPidRunning          - determine whether given PID is running
# dnPipeSucceeded       - determine whether all commands in the most recently
#                         executed pipe succeeded
# dnPopIFS              - pop top IFS stack value into IFS variable
# dnProcessName         - get name of process ID
# dnProgressWheel       - provide visual feedback while a PID is running
# dnPushIFS             - push current IFS value onto IFS stack
# dnResetIFS            - reset IFS variable to default value
# dnShowIFS             - display current value of internal field separator
#                         variable IFS
# dnToolAvailable       - checks whether a tool is available
# dnToolsAvailable      - checks list of tools to determine whether all
#                         are available
# dnUnderGitControl     - determine whether directory is under local git
#                         version control
# dnUnderRcsControl     - whether directory is under local RCS version control
# dnUpdateLocalGitRepo  - update local git repo
# dnUpdateRemoteGitRepo - update remote git repo
# dnValidUser           - determine whether user has user account and directory
#                         under /home/
# dnVariablesAvailable  - checks list of variables to determine whether all
#                         are available

# Strings :: string manipulation    {{{2

# dnContainsSpace       - returns whether string contains a space
# dnEquals              - returns whether two strings are
#                         (case-insensitive) equal
# dnEraseText           - erase text by backspacing
# dnEscapeChar          - escape character in string
# dnExtractHttpHost     - extract server name from http url
# dnHasEndSlash         - determine whether string has a
#                         terminal (forward) slash
# dnHighlightHotkey     - highlight hotkey in string with different colour
# dnInitialCap          - convert first byte of string to upper case
# dnLastChar            - gets last character from a string
# dnLeftPad             - left pad a string
# dnLowercase           - convert upper case characters in string to lower case
# dnNoSpace             - determine whether string contains space
# dnNullCharacter       - provides a null character, i.e., octal 000, hex 00,
#                         decimal 0, NUL, '\0'
# dnQuoted              - returns whether a string is enclosed in quotes
# dnRedReverseText      - add bash formatting codes to string to make it
#                         display in terminal as reverse red text
# dnRemoveEndSlash      - remove terminal (forward) slash from string
# dnRightPad            - right pad a string
# dnStrLen              - calculate string length
# dnStringContains      - return whether string contains a given substring
# dnStringEqual         - returns whether two string are lexicographically
#                         (case-sensitive) equal
# dnStringGreaterThan   - returns whether first string is lexicographically
#                         greater than second
# dnStringGreaterThanOrEqual
#                       - returns whether first string is lexicographically
#                                               greater than or equal to second
# dnStringLessThan      - returns whether first string is lexicographically
#                         less than second
# dnStringLessThanOrEqual
#                       - returns whether first string is lexicographically
#                                               less than or equal to second
# dnStripComment        - strip comment from a line
# dnStripEnclosingQuotes
#                       - strip enclosing quotes from a string
# dnStripEnclosingSpaces
#                       - strip spaces from front and end of string
# dnStripLeadingZeroes  - strip leading zeroes from an integer
# dnStripQuotes         - strip all quote marks from a string
# dnStripWhitespace     - strip all whitespace from string
# dnTitleCase           - converts string to title case
# dnTruncate            - truncate string at specified length
# dnUnderSpace          - convert underscores to spaces
# dnUppercase           - convert lower case characters in string to upper case
# dnValidDebianPackageVersion
#                       - check validity of debian package version
# dnValidRGB            - determine whether an RGB value is correct

# Time :: manipulating times    {{{2

# dnCalculateSeconds    - calculate total time in seconds from hours,
#                         minutes and seconds
# dnFormatTime          - convert count in seconds to formatted time
# dnSecondsSinceEpoch   - get number of seconds since unix epoch
# dnTimeDifference      - convert time difference to formatted time

# User-interaction :: interacting with user    {{{2

# dnAudibleAlert        - sound audible alert
# dnConfirm             - ask user yes|no question
# dnConfirmDlg          - display confirmatory question in dialog
# dnCritRep             - report operation outcome and exit with message
#                         if it failed
# dnCountdownDelay      - displays countdown message in console
# dnDebug               - print informational message to standard output
# dnDebugStderr         - displays countdown message in console
# dnDialogType          - selects best available dialog type
# dnDlg                 - dialog/popup engine
# dnErrorDlg            - display error message in dialog
# dnErrorStderr         - print fatal error message to standard error
# dnFatal               - print fatal error message to standard output
# dnFatalStderr         - exit with failure notice
# dnFontFormat          - print font-related ANSI escape sequences
# dnGetInput            - get user input
# dnGetPosInteger       - user enter positive integer
# dnInfo                - print informational message to standard output
# dnInfoDlg             - display informational message in dialog
# dnInfoStderr          - print informational message to standard output
# dnInfonStderr         - print warning message to standard output
# dnListDlg             - select multiple options from GUI list
# dnListTagDlg          - select multiple options from GUI list
# dnLog                 - write message to system log
# dnMessage             - print message to standard output
# dnMessageStderr       - print message to standard error
# dnOpFail              - report whether operation failed
# dnOpOk                - report whether operation succeeded
# dnPickColour          - user selects colour name
# dnPopupDlg            - display informational message in popup
# dnPopupNlDlg          - display informational message in popup
# dnPrompt              - print prompt message to standard output
# dnPromptDlg           - display prompt in dialog
# dnPromptStderr        - print prompt message to standard error
# dnQueryStderr         - print informational message to standard output
# dnReport              - report success or failure of operation
# dnSelect              - select option from console list
# dnSelectDlg           - select option from GUI list
# dnSelectTagDlg        - select option from GUI list
# dnWarnDlg             - display warning message in dialog
# dnWarnStderr          - print query message to standard output

# Variables :: useful variables    {{{2

# dnVariableSet         - determine whether variable is set
# }}}1

# STYLE NOTES

# declaring local string (scalar) variables

# • need to declare variables before use or get fatal 'unbound variable' error
# • using "local var1 var2" is not sufficient to avoid 'unbound variable' error
# • using "local var1= var2=" is sufficient to avoid 'unbound variable' error,
#   but it triggers shellcheck warning SC1007
# • using "local var1='' var2=''" is sufficient to avoid 'unbound variable'
#   error, but because of a shellcheck bug this can trigger an erroneous
#   SC2178 warning if the same local variable name is used for an array in one
#   function and a string (scalar) in another function
# • the solution to avoiding the spurious SC2178 error, as described in the
#   help for that check, is to declare the variable in one command and assign
#   to it in another:
#     local var1 var2
#     var1='' var2=''
# • while the erroneous triggering of the SC2178 warning can be fixed when it
#   occurs by changing the name of one of the clashing variables, adopting the
#   style of separate variable declarations and assignments throughout this
#   library ensures this bug is never triggered

# declaring local array variables

# • in an analogous manner to string variables, using "local -a var1 var2" is
#   not sufficient to avoid the 'unbound variable' error, while using
#   "local -a var1= var2=" avoids the 'unbound variable' error but triggers the
#   SC1007 warning
# • using "local -a var1=() var2=()" avoids both the 'unbound variable' error
#   and the shellcheck SC1007 warning, and the erroneous triggering of
#   the shellcheck SC2178 warning is avoided by proper handling of string
#   (scalar) variable declarations as discussed above
# • associative arrays ('-A') are exactly analogous to ordinary arrays ('-a')
#   in how they are declared

# FUNCTIONS

# Function: dnAbort    {{{1
# Exit script with error status, messages to stderr, ± stacktrace to stderr
#   option: t  - print stack trace (optional)
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1+ - message
#   prints: feedback to stacktrace
#   return: nil
# fn_tag dnAbort purpose Exit script with feedback to stderr
# fn_tag dnAbort prints Error messages to stderr
# fn_tag dnAbort returns Failure value (Boolean)
# fn_tag dnAbort option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnAbort option t required no
# fn_tag dnAbort option t multiple no
# fn_tag dnAbort option t type none
# fn_tag dnAbort option s purpose Number of function calls to skip in trace output
# fn_tag dnAbort option s required no
# fn_tag dnAbort option s multiple no
# fn_tag dnAbort option s type integer
# fn_tag dnAbort option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnAbort option s note This option implies the 't' option
# fn_tag dnAbort param message purpose Error messages to be displayed before exiting
# fn_tag dnAbort param message required no
# fn_tag dnAbort param message multipart yes
# fn_tag dnAbort param message type string
# fn_tag dnAbort param message default Aborting script
dnAbort() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# set variables
	local -a msg=()
	msg+=("${@:-'Aborting script'}")
	# display messages
	dnFatalStderr "${msg[@]}"
	# • print stack trace if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfoStderr 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfoStderr "  ${i}"
			done
		)
	fi
	# exit script
	exit 1
}
# Function: dnAddToList    {{{1
# Add item to list
#   params: 1 - base list
#           2 - new item
#   prints: newly expanded list
#   return: nil
#   usage:  list="$( addToList "${list}" "${new_item}" )"
# fn_tag dnAddToList purpose add item to list
# fn_tag dnAddToList prints newly expanded list
# fn_tag dnAddToList returns NIL
# fn_tag dnAddToList note usage: list="$( dnaddToList "${list}" "${new_item}" )"
# fn_tag dnAddToList param list purpose base list to be added to
# fn_tag dnAddToList param list required yes
# fn_tag dnAddToList param list multipart no
# fn_tag dnAddToList param list type string
# fn_tag dnAddToList param item purpose new item to add to list
# fn_tag dnAddToList param item required yes
# fn_tag dnAddToList param item multipart no
# fn_tag dnAddToList param item type string
dnAddToList() {
	local list item
	list="${1:-}" item="${2:-}"
	if [ -z "${list}" ]; then
		echo "${item}"
	else
		echo "${list} ${item}"
	fi
}
# Function: dnAlphaSortArray    {{{1
# Return sorted array (ascending alpha-sort)
#   params: 1+ - array elements
#   prints: sorted array elements
#   return: nil
#   usage:  eval "sorted=( $( dnAlphaSortArray "${unsorted[@]}" ) )"
#   notes:  any quote marks, including apostrophes (') , will be stripped out
#           it is vital to use 'eval' when calling function
# fn_tag dnAlphaSortArray purpose Sort array elements on ascending alpha sort
# fn_tag dnAlphaSortArray prints Sorted array
# fn_tag dnAlphaSortArray returns NIL
# fn_tag dnAlphaSortArray note It is vital that 'eval' be used when calling function
# fn_tag dnAlphaSortArray note Any quote marks in array elements will be stripped
# fn_tag dnAlphaSortArray usage eval "sorted=( $( dnAlphaSortArray "${unsorted[@]}" ) )"
# fn_tag dnAlphaSortArray param array purpose Array to be sorted
# fn_tag dnAlphaSortArray param array required yes
# fn_tag dnAlphaSortArray param array multipart yes
# fn_tag dnAlphaSortArray param array type string
dnAlphaSortArray() {
	# set and check variables
	# • sanity checks
	[ ${#} -le 1 ] && echo "${@}" && return
	# • other
	local -a array=("${@}")
	local temp sorted i j
	temp='' sorted='' i='' j=''
	# bubble sort until no swaps
	while ! dnFlagTrue ${sorted}; do
		sorted=0
		for ((j = 1; j < ${#array[*]}; j++)); do
			i=$((j - 1))
			if dnStringGreaterThan "${array[i]}" "${array[j]}"; then
				sorted=1
				temp="${array[j]}"
				array[j]="${array[i]}"
				array[i]="${temp}"
			fi
		done
	done
	# report results
	dnOutputArray "${array[@]}"
}
# Function: dnAlphaSortDualArrays    {{{1
# Return sorted secondary array (ascending alpha-sort)
#   params: 1+ - primary (sorting) array elements
#           n  - '^' -- caret demarcates between arrays
#           n+ - secondary array elements
#   prints: secondary array (sorted on primary array)
#   return: boolean (0=able to sort|1=unable to sort)
#   usage:  eval "sorted=( $( dnAlphaSortDualArrays "${primary[@]}" '^' "${secondary[@]}" ) )"
#   notes:  any quote marks, including apostrophes ('), will be stripped out
#           singleton caret element is reserved
#           it is vital to use 'eval' when calling function
#           when sorting multiple arrays make sure to sort primary key last
# fn_tag dnAlphaSortDualArrays purpose Sort one array based on values in another array
# fn_tag dnAlphaSortDualArrays prints Reordered secondary array
# fn_tag dnAlphaSortDualArrays returns Whether able to sort secondary array (Boolean)
# fn_tag dnAlphaSortDualArrays note Primary array elements are sorted by ascending alpha sort
# fn_tag dnAlphaSortDualArrays note Secondary array elements are reordered in same index sequence as sorted primary array elements
# fn_tag dnAlphaSortDualArrays note Unpredictable results can occur if arrays are of different lengths
# fn_tag dnAlphaSortDualArrays note Caret character is reserved and cannot be used in either array
# fn_tag dnAlphaSortDualArrays note All quote marks will be stripped from array elements
# fn_tag dnAlphaSortDualArrays note It is vital to use 'eval' when calling function
# fn_tag dnAlphaSortDualArrays usage "eval sorted=( $( dnAlphaSortDualArrays "${primary[@]}" '^' "${secondary[@]}" ) )"
# fn_tag dnAlphaSortDualArrays param primary purpose Primary array (to provide sort order)
# fn_tag dnAlphaSortDualArrays param primary required yes
# fn_tag dnAlphaSortDualArrays param primary multipart yes
# fn_tag dnAlphaSortDualArrays param primary type string
# fn_tag dnAlphaSortDualArrays param separator purpose Marker separating primary and secondary arrays
# fn_tag dnAlphaSortDualArrays param separator required yes
# fn_tag dnAlphaSortDualArrays param separator multipart no
# fn_tag dnAlphaSortDualArrays param separator type string
# fn_tag dnAlphaSortDualArrays param separator value ^
# fn_tag dnAlphaSortDualArrays param separator default ^
# fn_tag dnAlphaSortDualArrays param separator note Must be = '^'
# fn_tag dnAlphaSortDualArrays param secondary purpose Secondary array (to be reordered)
# fn_tag dnAlphaSortDualArrays param secondary required yes
# fn_tag dnAlphaSortDualArrays param secondary multipart yes
# fn_tag dnAlphaSortDualArrays param secondary type string
dnAlphaSortDualArrays() {
	# set and check variables
	# • sanity checks
	[ ${#} -ge 3 ] || return 1
	dnElementInArray '^' "${@}" || return 1
	# • load arrays (caret separates arrays)
	local -a key=()
	local -a sort=()
	# • key array first
	while [ "${1:-}" != '^' ]; do
		key+=("${1:-}")
		shift
	done
	shift # remove caret (separator) element
	# • then sort array
	while [ ${#} -gt 0 ]; do
		sort+=("${1}")
		shift
	done
	# • deal with small arrays and error check
	[ ${#key[*]} -eq ${#sort[*]} ] || return 1
	[ ${#key[*]} -eq 1 ] && echo "'${key[0]}'" && return 0
	[ ${#key[*]} -eq 0 ] && return 1
	# • other variables
	local temp sorted i j output
	temp='' sorted='' i='' j='' output=''
	# bubble sort until no swaps
	while ! dnFlagTrue ${sorted}; do
		sorted=0
		for ((j = 1; j < ${#key[*]}; j++)); do
			i=$((j - 1))
			if dnStringGreaterThan "${key[i]}" "${key[j]}"; then
				sorted=1
				# swap in key array
				temp="${key[j]}"
				key[j]="${key[i]}"
				key[i]="${temp}"
				# swap in sort array
				temp="${sort[j]}"
				sort[j]="${sort[i]}"
				sort[i]="${temp}"
			fi
		done
	done
	# report results
	dnOutputArray "${sort[@]}"
}
# Function: dnAnalyseSvnRepository    {{{1
# Get url|revision|module|type|name of svn repository, where
# 'type' is trunk/branch/tag and 'name' is name of branch or tag
#   params: 1 - directory|url of repository
#   prints: list = url, revision, module, type, name
#   return: nil
#   assume: refdb's svn repository follows standard practice of having
#             top level dirs 'trunk', 'branches' and 'tags'
#   assume: internet connection
#   use:    rep_details=( $( analyseRepository $( pwd ) ) )
#           rep_details=( $( analyseRepository ~/sources/refdb ) )
#           rep_details=( $( analyseRepository \
#               https://svn.sourceforge.net/svnroot/refdb/refdb/trunk ) )
# fn_tag dnAnalyseSvnRepository purpose Get information about svn repository
# fn_tag dnAnalyseSvnRepository prints Space-delimited list of repository url, revision, module, type, name
# fn_tag dnAnalyseSvnRepository returns NIL
# fn_tag dnAnalyseSvnRepository note Assumes svn repository has standard top level dirs: 'trunk', 'branches' and 'tags'
# fn_tag dnAnalyseSvnRepository note Assumes working internet connection
# fn_tag dnAnalyseSvnRepository usage rep_details=( $( analyseRepository $( pwd ) ) )
# fn_tag dnAnalyseSvnRepository usage rep_details=( $( analyseRepository ~/sources/refdb ) )
# fn_tag dnAnalyseSvnRepository usage rep_details=( $( analyseRepository \
# fn_tag dnAnalyseSvnRepository usage \thttps://svn.sourceforge.net/svnroot/refdb/refdb/trunk ) )
# fn_tag dnAnalyseSvnRepository param repository purpose Directory or url of svn repository
# fn_tag dnAnalyseSvnRepository param repository required yes
# fn_tag dnAnalyseSvnRepository param repository multipart no
# fn_tag dnAnalyseSvnRepository param repository type string
dnAnalyseSvnRepository() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No repository path provided"
	local repository url rev module type name dir output
	repository="${1}" url='' rev='' module='' type='' name='' dir='' output=''
	# determine type of repository
	# • step 1: if no dir|url given, assume cwd
	test -z "${repository}" && repository="$(pwd)"
	# • step 2: strip off file protocol notifier is present
	repository="${repository#file:\/\/}"
	# • step 3: check to see if is directory
	dir="$(dnNormalisePath "${repository}")"
	if dnDirValid "${dir}"; then
		repository="${dir}"
	else # must be url
		if ! [[ $repository =~ ^http ]]; then
			echo ''
			return
		fi
	fi
	# extract repository info
	# • 'svn info' exits with error code if repo dir is not a working repo copy
	local tmp_var
	tmp_var="$(svn info "${repository}")" ||
		dnEndScript 1 "Unable to access repository '${repository}'"
	local -a output=()
	mapfile -t output <<<"${tmp_var}"
	# extract URL and revision lines
	local url rev line
	url='' rev='' line=''
	for line in "${output[@]}"; do
		[[ $line =~ ^URL: ]] && url="${line}"
		[[ $line =~ ^Revision: ]] && rev="${line}"
	done
	# process revision line to get revision
	rev="${rev/#Revision: /}"
	# process URL line to get url, module, type and name
	url="${url/#URL: /}"
	local term_dir
	term_dir="$(dnTerminalSubdir "${url}")"
	local parent_dir
	parent_dir=''
	if [ "${term_dir}" = 'trunk' ]; then
		type='trunk'
		parent_dir="$(dnParentDir "${url}")" # prune off 'trunk'
		module="$(dnTerminalSubdir "${parent_dir}")"
		name=''
	else
		name="$(dnTerminalSubdir "${url}")"
		parent_dir="$(dnParentDir "${url}")"
		type="$(dnTerminalSubdir "${parent_dir}")"
		case "${type}" in
		'branches') type='branch' ;;
		'tags') type='tag' ;;
		*)
			local errmsg
			errmsg="Fatal error 10 in function '${FUNCNAME[0]}', script '${0}'"
			dnEndScript 1 "${errmsg}"
			;;
		esac
		parent_dir="$(dnParentDir "${parent_dir}")"
		module="$(dnTerminalSubdir "${parent_dir}")"
	fi
	# return result
	local -a rep_details=("${url}" "${rev}" "${module}" "${type}" "${name}")
	echo "${rep_details[@]}"
}
# Function: dnArrayToNullDelimitedString    {{{1
# Output array contents as a null-delimited string
#   params: 1+ - array elements
#   prints: null-delimited array elements
#   return: nil
#   usage:  eval "string=( dnArrayToNullDelimitedString "${array[@]}" )"
#   notes:  it is vital to use 'eval' for line
# fn_tag dnArrayToNullDelimitedString purpose Output array contents as a null-delimited string
# fn_tag dnArrayToNullDelimitedString prints Null-delimited array elements
# fn_tag dnArrayToNullDelimitedString returns NIL
# fn_tag dnArrayToNullDelimitedString usage eval "string=( dnArrayToNullDelimitedString "${array[@]}" )"
# fn_tag dnArrayToNullDelimitedString note It is vital to use 'eval' when setting variable using this function
# fn_tag dnArrayToNullDelimitedString param elements purpose Array elements to concatenate
# fn_tag dnArrayToNullDelimitedString param elements required yes
# fn_tag dnArrayToNullDelimitedString param elements multipart yes
# fn_tag dnArrayToNullDelimitedString param elements type string
dnArrayToNullDelimitedString() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local -a output=()
	while [ ${#} -gt 0 ]; do
		output+=("$(dnStripQuotes "${1}")")
		shift
	done
	echo "${output[*]}"
}
# Function: dnAudibleAlert    {{{1
# Sound audible alert
#   params: 1 - alert sound [optional]
#   prints: nil
#   return: nil
#   sounds: available sounds ['three'|'dramatic'|'bell' (default)]
#   needs:  tools [play]
#           sound files [see function code]
# fn_tag dnAudibleAlert purpose Sound audible alert
# fn_tag dnAudibleAlert prints NIL
# fn_tag dnAudibleAlert returns NIL
# fn_tag dnAudibleAlert note Requires play utility
# fn_tag dnAudibleAlert note DELETE both function notes
# fn_tag dnAudibleAlert param sound purpose Sound type
# fn_tag dnAudibleAlert param sound required no
# fn_tag dnAudibleAlert param sound multipart no
# fn_tag dnAudibleAlert param sound type string
# fn_tag dnAudibleAlert param sound value three
# fn_tag dnAudibleAlert param sound value dramatic
# fn_tag dnAudibleAlert param sound value bell
# fn_tag dnAudibleAlert param sound default bell
dnAudibleAlert() {
	# choose tone
	local play libdata tone sound
	play='play' libdata='@pkgdata_dir@' tone='' sound="${1:-}"
	case ${sound} in
	'three') tone="${libdata}/alert-tone-3-pulses.wav" ;;
	'dramatic') tone="${libdata}/dramatic_chord.wav" ;;
	*) tone='bell' ;;
	esac
	# use system bell if sound file missing
	[ "${tone}" != 'bell' ] && [ ! -r "${tone}" ] && tone='bell'
	# use system bell if sound file player missing
	which "${play}" &>/dev/null || tone='bell'
	# play tone
	case "${tone}" in
	'bell') echo -e "\a" ;;
	*) play "${tone}" &>/dev/null ;;
	esac
}
# Function: dnBlockExist    {{{1
# Block special exists
#   params: 1 - file
#   prints: nil
#   return: boolean (0=exists, 1=does not exist)
#   invoke: if dnBlockExist "${filename}" ; then ...
# fn_tag dnBlockExist purpose Determine whether block special device exists
# fn_tag dnBlockExist prints NIL
# fn_tag dnBlockExist returns Whether block special device exists (Boolean)
# fn_tag dnBlockExist usage if dnBlockExist "${filename}" ; then ...
# fn_tag dnBlockExist param block purpose Block special device to be analysed
# fn_tag dnBlockExist param block required yes
# fn_tag dnBlockExist param block multipart no
# fn_tag dnBlockExist param block type path
dnBlockExist() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[ -b "${1}" ]
	return ${?}
}
# Function: dnBlockValid    {{{1
# Block special exists and is readable
#   params: 1 - file
#   prints: nil
#   return: boolean (0=exists, 1=does not exist)
#   invoke: if dnBlockValid "${filename}" ; then ...
# fn_tag dnBlockValid purpose Determine whether block special device exists and is readable
# fn_tag dnBlockValid prints NIL
# fn_tag dnBlockValid returns Whether block special device exists and is readable (Boolean)
# fn_tag dnBlockValid usage if dnBlockValid "${filename}" ; then ...
# fn_tag dnBlockValid param block purpose Block special device to be analysed
# fn_tag dnBlockValid param block required yes
# fn_tag dnBlockValid param block multipart no
# fn_tag dnBlockValid param block type path
dnBlockValid() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[ -b "${1}" ] && [ -r "${1}" ]
	return ${?}
}
# Function: dnBlockValidNoSpaces    {{{1
# Block special exists and readable and filepath contains no spaces
#   params: 1 - file
#   prints: nil
#   return: boolean (0=exists, 1=does not exist)
#   invoke: if dnBlockValidNoSpaces "${filename}" ; then ...
#   needs:  functions [dnNoSpace]
# fn_tag dnBlockValidNoSpaces purpose Determine whether block special device exists, is readable and contains no spaces
# fn_tag dnBlockValidNoSpaces prints NIL
# fn_tag dnBlockValidNoSpaces returns Whether block special device exists, is readable and contains no spaces (Boolean)
# fn_tag dnBlockValidNoSpaces usage if dnBlockValidNoSpaces "${filename}" ; then ...
# fn_tag dnBlockValidNoSpaces param block purpose Block special device to be analysed
# fn_tag dnBlockValidNoSpaces param block required yes
# fn_tag dnBlockValidNoSpaces param block multipart no
# fn_tag dnBlockValidNoSpaces param block type path
dnBlockValidNoSpaces() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[[ -b "${1}" && -r "${1}" ]] && dnNoSpace "${1}"
	return ${?}
}
# Function: dnCalculateSeconds    {{{1
# Calculate seconds
#   params: 1 - hours
#           2 - minutes
#           3 - seconds
#   prints: int (seconds)
#   return: nil
# fn_tag dnCalculateSeconds purpose Calculate total time in seconds from hours, minutes and seconds
# fn_tag dnCalculateSeconds prints Total seconds (Integer)
# fn_tag dnCalculateSeconds returns NIL
# fn_tag dnCalculateSeconds param hours purpose Number of hours
# fn_tag dnCalculateSeconds param hours required yes
# fn_tag dnCalculateSeconds param hours multipart no
# fn_tag dnCalculateSeconds param hours type integer
# fn_tag dnCalculateSeconds param mins purpose Number of minutes
# fn_tag dnCalculateSeconds param mins required yes
# fn_tag dnCalculateSeconds param mins multipart no
# fn_tag dnCalculateSeconds param mins type integer
# fn_tag dnCalculateSeconds param secs purpose Number of seconds
# fn_tag dnCalculateSeconds param secs required yes
# fn_tag dnCalculateSeconds param secs multipart no
# fn_tag dnCalculateSeconds param secs type integer
dnCalculateSeconds() { echo "$((${1:-0} * 3600 + ${2:-0} * 60 + ${3:-0}))"; }
# Function: dnCheckInternet    {{{1
# Checks internet connection (exits if none found)
#   params: 1+ - urls to ping
#   prints: nil
#   return: 0|1 (ok|not ok)
#   invoke: dnCheckInternet ${url_list} || ...
# fn_tag dnCheckInternet purpose Determines whether the internet is accessible
# fn_tag dnCheckInternet prints NIL
# fn_tag dnCheckInternet returns Whether internet is accessible (Boolean)
# fn_tag dnCheckInternet usage dnCheckInternet ${dn_ping_urls[@]} || ...
# fn_tag dnCheckInternet note Pings a number of supplied URLs to determine internet accessibility
# fn_tag dnCheckInternet param url purpose URL to ping
# fn_tag dnCheckInternet param url required yes
# fn_tag dnCheckInternet param url multipart yes
# fn_tag dnCheckInternet param url type string
dnCheckInternet() {
	local url
	url=''
	for url in "${dn_ping_urls[@]}"; do
		ping -c 1 "${url}" &>/dev/null && return 0 # connected!
	done
	return 1 # not connected
}
# Function: dnColourToRGB    {{{1
# Convert colour name to RGB value
# note: Colour must be from dnPickColour
# note: Arrays in dnColourToRGB and dnPickColour must be kept in synchrony
#   params: 1 - colour
#   prints: RGB value
#   return: boolean (0=success|1=error)
# fn_tag dnColourToRGB purpose Convert colour name to RGB value
# fn_tag dnColourToRGB prints RGB value
# fn_tag dnColourToRGB returns Whether converted successfully (Boolean)
# fn_tag dnColourToRGB note All colours must also be in function 'dnPickColour'
# fn_tag dnColourToRGB note Arrays in functions 'dnColourToRGB' and 'dnPickColour' must be kept in synchrony
# fn_tag dnColourToRGB param colour purpose Colour name to be converted to RDB value
# fn_tag dnColourToRGB param colour required yes
# fn_tag dnColourToRGB param colour multipart no
# fn_tag dnColourToRGB param colour type string
# fn_tag dnColourToRGB param colour note Colour usually selected by calling 'dnPickColour'
dnColourToRGB() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local colour retval index rgb element
	colour="${1}" retval='' index='' rgb='' element=''
	# note: following two arrays match on element
	local -a colours=('black' 'blue' 'blue, midnight' 'blue, royal' 'cyan'
		'gold' 'gray' 'gray, dim' 'gray, slate'
		'green' 'green, dark' 'green, forest' 'green, pale'
		'magenta' 'navy' 'orange' 'orange, dark'
		'peach' 'pink' 'purple' 'red'
		'red, orange' 'rose, misty' 'slate, dark blue' 'tan'
		'violet' 'white' 'yellow')
	local -a rgbs=('0,0,0' '0,0,255' '25,25,112' '65,105,225' '0,255,255'
		'255,215,0' '190,190,190' '105,105,105' '112,128,144'
		'0,255,0' '0,100,0' '34,139,34' '152,251,152'
		'255,0,255' '0,0,128' '255,165,0' '255,140,0'
		'255,218,185' '255,192,203' '160,32,240' '255,0,0'
		'255,69,0' '255,228,225' '72,61,139' '210,180,140'
		'238,130,238' '255,255,255' '255,255,0')
	# get element match on colour
	for ((index = 0; index < ${#colours[*]}; index++)); do
		[ "${colours[index]}" = "${colour}" ] && element=${index} && break
	done
	# get rgb equivalent
	if [ -n "${element+x}" ] && [ ${element} -ge 0 ]; then
		rgb="${rgbs[element]}"
		retval=0
	else
		retval=1
	fi
	# return rgb and indicate success
	echo "${rgb}"
	return ${retval}
}
# Function: dnConcatArrayItems    {{{1
# Join all array items using a delimiter.
# Gracefully handles empty and single-item arrays.
# Gracefully handles an empty delimiter.
# The following results in unspecified behaviour: passing non-string,
# non-number values as delimiter or array values; passing a non-array where an
# array is expected.
#   params: delim     - delimiter
#           elements+ - items to be joined
#   prints: string containing joined items
#   return: nil
# fn_tag dnConcatArrayItems purpose Output array elements as a delimited string
# fn_tag dnConcatArrayItems prints Delimited array elements
# fn_tag dnConcatArrayItems returns NIL
# fn_tag dnConcatArrayItems note Gracefully handles missing, empty and single-item arrays
# fn_tag dnConcatArrayItems note Gracefully handles missing or empty delimiter
# fn_tag dnConcatArrayItems usage string="$(dnConcatArrayItems "${delim}" "${array[@]}")"
# fn_tag dnConcatArrayItems param delim purpose Output delimiter
# fn_tag dnConcatArrayItems param delim required yes
# fn_tag dnConcatArrayItems param delim multipart no
# fn_tag dnConcatArrayItems param delim type string
# fn_tag dnConcatArrayItems param elements purpose Array elements to concatenate
# fn_tag dnConcatArrayItems param elements required yes
# fn_tag dnConcatArrayItems param elements multipart yes
# fn_tag dnConcatArrayItems param elements type string
function dnConcatArrayItems() {
	local delimiter first_item
	delimiter="${1:-}"
	shift
	first_item="${1:-}"
	shift
	printf %b%s "${first_item}" "${@/#/$delimiter}"
}
# Function: dnConfigureSsh    {{{1
# Configure ssh tools for password-less operation
#   params: 1 - key file
#   prints: feedback (not for capture)
#   return: 0|1 (success|failure)
#   invoke: dnConfigureSsh /home/david/.ssh/id_dsa_cvs.sf.net || ...
#   notes:  Does no checking for validity of key file
# fn_tag dnConfigureSsh purpose Configure ssh tools for password-less operation
# fn_tag dnConfigureSsh prints Feedback
# fn_tag dnConfigureSsh returns Whether ssh tools successfully configured (Boolean)
# fn_tag dnConfigureSsh usage dnConfigureSsh /home/david/.ssh/id_dsa_cvs.sf.net || ...
# fn_tag dnConfigureSsh note Does not check whether key file is valid
# fn_tag dnConfigureSsh param key_file purpose Location of file containing cryptographic keys required by ssh tools
# fn_tag dnConfigureSsh param key_file required yes
# fn_tag dnConfigureSsh param key_file multipart no
# fn_tag dnConfigureSsh param key_file type path
dnConfigureSsh() {
	# check parameters
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local key_path key_file
	key_path='' key_file=''
	key_path="$(dnNormalisePath "${1}")"
	key_file="$(dnExtractFilename "${key_path}")"
	if [ -z "${key_path}" ]; then
		dnError 'No key file specified.' && return 1
	fi
	# grepping 'ps' output for key_path fails if path begins with '/'
	# (due to word boundary problems with '\b' marker)
	key_grep="${key_path}"
	while [[ $key_grep =~ ^\/ ]]; do
		key_grep="${key_grep/#\//}"
	done
	# set cvs authentication mode
	dnInfo 'Set cvs authentication variable.'
	if ! export CVS_RSH=ssh; then
		dnError 'Unable to set CVS_RSH=ssh' && return 1
	fi
	# start ssh-agent if not already running
	if [ "$(pgrep -a -c -- "\bssh-agent\b")" -lt 2 ]; then
		dnInfo "Starting 'ssh-agent'. "
		if ! ssh-agent &>/dev/null; then
			dnError 'Unable to start ssh-sgent.' && return 1
		fi
	else
		dnInfo "Program 'ssh-agent' is already running."
	fi
	# add key file if not already added
	if [ "$(ssh-add -l | grep -c -- "\b${key_grep}\b")" -gt 0 ]; then
		dnInfo "Key file '${key_file}' already added."
	else
		dnInfo "Adding key file '${key_file}'."
		if ! ssh-add "${key_path}"; then
			dnError 'Unable to add key.' && return 1
		fi
	fi
	# finished ok
	return 0
}
# Function: dnConfirm    {{{1
# Confirm (user enters y or n)
#   params: prompt (include terminal punctuation mark, no additional spaces)
#   prints: 'Yes'|'No'
#   return: 0|1 ('y'|'n')
#   invoke: if dnConfirm 'Proceed?' ; then ...
#   needs:  variables [dn_query_prefix]
# fn_tag dnConfirm purpose Ask user yes|no question
# fn_tag dnConfirm prints User choice: 'Yes' or 'No'
# fn_tag dnConfirm returns Whether user chose 'yes' or 'no' (Boolean)
# fn_tag dnConfirm param prompt purpose User prompt
# fn_tag dnConfirm param prompt required yes
# fn_tag dnConfirm param prompt multipart no
# fn_tag dnConfirm param prompt type string
# fn_tag dnConfirm param prompt note Include terminal punctuation (but no terminal spaces)
dnConfirm() {
	local prompt input
	prompt="${1:-}" input=''
	[ -n "${prompt}" ] || dnAbort "${FUNCNAME[0]}: No prompt provided"
	echo -n "${dn_query_prefix}${prompt} [y/n] " # print prompt
	while true; do
		read -r -n 1 -s input # get user input, break if y|Y|n|N
		input="${input,,}"    # convert to lowercase
		{ [[ $input =~ y ]] || [[ $input =~ n ]]; } && break
	done
	echo -en "\b\b\b\b\b\b" # erase '[y/n] ', echo instead 'Yes'|'No'
	if [ "${input}" = "y" ]; then echo "Yes  "; else echo "No   "; fi
	[ "${input}" = "y" ]
	return ${?}
}
# Function: dnConfirmDlg    {{{1
# Display query dialog asking user for a yes/no response
#   params: 1 - message (optional, default='Proceed?')
#           2 - title (optional, default=script name)
#   prints: nil
#   return: nil
# fn_tag dnConfirmDlg purpose Display confirmatory question in dialog
# fn_tag dnConfirmDlg prints NIL
# fn_tag dnConfirmDlg returns User response (Boolean)
# fn_tag dnConfirmDlg note User can choose 'Yes' or 'No' button
# fn_tag dnConfirmDlg usage if dnConfirmDlg 'Proceed?' ; then ...
# fn_tag dnConfirmDlg param message purpose Confirmatory question
# fn_tag dnConfirmDlg param message required no
# fn_tag dnConfirmDlg param message multipart no
# fn_tag dnConfirmDlg param message type string
# fn_tag dnConfirmDlg param message default Proceed?
# fn_tag dnConfirmDlg param title purpose Dialog title
# fn_tag dnConfirmDlg param title required no
# fn_tag dnConfirmDlg param title multipart no
# fn_tag dnConfirmDlg param title type string
# fn_tag dnConfirmDlg param title default script name
dnConfirmDlg() {
	# process parameters
	local title message
	title="${2:-${dn_self}}" message="${1:-Proceed?}"
	# set variables
	local dlg cmd
	cmd=''
	dlg="$(dnDialogType -c confirm -c newline_escape)"
	if [ -z "${dlg}" ]; then
		echo 'Unable to get confirmation dialog type' 1>&2
		return 1
	fi
	cmd="${dn_dlg_cmds_confirm[$dlg]}"
	if [ -z "${cmd}" ]; then
		echo 'Unable to get confirmation dialog command' 1>&2
		return 1
	fi
	# substitute placeholders in dialog command
	cmd="${cmd/<T>/${title}}"   # replace title placeholder token
	cmd="${cmd/<M>/${message}}" # replace message placeholder token
	# execute command ('eval' is required to handle quotes)
	eval "${cmd}"
	return ${?}
}
# Function: dnContainsSpace    {{{1
# Whether string contains a space
#   params: 1 - string
#   prints: nil
#   return: boolean (0=contains|1=does not contain)
# fn_tag dnContainsSpace purpose Returns whether string contains a space
# fn_tag dnContainsSpace prints NIL
# fn_tag dnContainsSpace returns Whether string contains a space (Boolean)
# fn_tag dnContainsSpace note Not all whitespace -- only the space character
# fn_tag dnContainsSpace param string purpose String to be searched
# fn_tag dnContainsSpace param string required yes
# fn_tag dnContainsSpace param string multipart no
# fn_tag dnContainsSpace param string type string
dnContainsSpace() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local string retval
	string="${1}" retval=1
	[[ $1 =~ $' ' ]] && retval=0
	return ${retval}
}
# Function: dnConvertAudioToWav    {{{1
# Convert audio file to WAV format
#   params: 1 - input file
#   prints: nil
#   return: boolean (0=success|1=failure)
#   assume: directory exists and is normalised
# fn_tag dnConvertAudioToWav purpose Convert audio file to WAV format
# fn_tag dnConvertAudioToWav prints NIL
# fn_tag dnConvertAudioToWav returns Whether new WAV audio file created successfully (Boolean)
# fn_tag dnConvertAudioToWav note Source file left in place
# fn_tag dnConvertAudioToWav note Create output file in same directory with same basename and 'wav' extension
# fn_tag dnConvertAudioToWav param input purpose Input audio file
# fn_tag dnConvertAudioToWav param input required yes
# fn_tag dnConvertAudioToWav param input multipart no
# fn_tag dnConvertAudioToWav param input type path
dnConvertAudioToWav() {
	local source_file key_file
	key_file=''
	source_file="$(dnNormalisePath "${1}")"
	dnFileValid "${source_file}" || return 1
	# target file uses same basename as source with WAV extension
	wav_file="$(dnParentDir "${source_file}")"
	wav_file="${wav_file}/$(dnExtractFileBase "${source_file}").wav"
	# convert file
	# options: -i = input file, -f = target audio format
	ffmpeg -i "${source_file}" -f wav "${wav_file}" &>/dev/null
	# indicate whether successful
	return ${?}
}
# Function: dnConvertNonPngToPng    {{{1
# Convert non-PNG image to PNG format
#   params: 1 - input filepath
#           2 - output filepath
#   prints: nil
#   return: boolean (0=success|1=failure)
#   assume: input pathname exists, output path exists but file does not
# fn_tag dnConvertNonPngToPng purpose Convert non-PNG image file to PNG format
# fn_tag dnConvertNonPngToPng prints NIL
# fn_tag dnConvertNonPngToPng returns Whether conversion occurred successfully (Boolean)
# fn_tag dnConvertNonPngToPng param input purpose Input image file
# fn_tag dnConvertNonPngToPng param input required yes
# fn_tag dnConvertNonPngToPng param input multipart no
# fn_tag dnConvertNonPngToPng param input type path
# fn_tag dnConvertNonPngToPng param output purpose Output PNG image file
# fn_tag dnConvertNonPngToPng param output required yes
# fn_tag dnConvertNonPngToPng param output multipart no
# fn_tag dnConvertNonPngToPng param output type path
dnConvertNonPngToPng() {
	local in_file out_file retval
	in_file="${1}" out_file="${2}" retval=0
	# normalise
	in_file="$(dnNormalisePath "${in_file}")"
	out_file="$(dnNormalisePath "${out_file}")"
	# perform conversion
	convert "${in_file}" "${out_file}" &>/dev/null || retval=1
	# indicate whether successful
	return ${retval}
}
# Function: dnConvertVobToMpg    {{{1
# Convert VOB video format to MPG format
#   params: 1 - input filepath
#   prints: feedback
#   return: boolean (0=success|1=failure)
#   assume: input pathname exists, output pathname does not
# fn_tag dnConvertVobToMpg purpose Convert VOB video file to MPG format
# fn_tag dnConvertVobToMpg prints Feedback
# fn_tag dnConvertVobToMpg returns Whether conversion successful (Boolean)
# fn_tag dnConvertVobToMpg note Output MPG file created in same directory as input file with same basename
# fn_tag dnConvertVobToMpg param input purpose Input VOB video file
# fn_tag dnConvertVobToMpg param input required yes
# fn_tag dnConvertVobToMpg param input multipart no
# fn_tag dnConvertVobToMpg param input type path
dnConvertVobToMpg() {
	# set and check variables
	local in_file file_base out_file tmp_dir m2v ac3 in_base
	in_file='' file_base='' out_file='' tmp_dir='' m2v='' ac3='' in_base=''
	in_file="$(dnNormalisePath "${1}")"
	file_base="$(dnExtractFileBase "${in_file}")"
	out_file="$(dnStripExtension "${in_file}").mpg"
	tmp_dir="$(mktemp -d)" ||
		dnEndScript 1 'Unable to make temp directory'
	dnTempTrap "${tmp_dir}"
	m2v="${tmp_dir}/${file_base}.m2v"
	ac3="${tmp_dir}/${file_base}.ac3"
	in_base="${tmp_dir}/${file_base}"
	# convert to intermediate formats
	dnInfon 'Extracting video stream from vob... '
	dnExtractM2vFromVob "${in_file}" "${m2v}"
	dnCritRep ${?} 'Unable to extract video stream from vob'
	dnInfon 'Extracting audio stream from vob... '
	dnExtractAc3FromVob "${in_file}" "${ac3}"
	dnCritRep ${?} 'Unable to extract audio stream from vob'
	# recombine into mpg
	dnInfon 'Multiplexing video and audio streams... '
	dnConvertM2vAc3ToMpg "${in_base}" "${out_file}" &>/dev/null
	dnCritRep ${?} 'Unable to multiplex'
	# clean up
	dnTempKill "${tmp_dir}"
}
# Function: dnConvertWavToAc3    {{{1
# Convert audio WAV file to AC3 format
#   params: 1 - input filepath
#           2 - output filepath
#   prints: nil
#   return: boolean (0=success|1=failure)
# fn_tag dnConvertWavToAc3 purpose Convert audio WAV file to AC3 format
# fn_tag dnConvertWavToAc3 prints NIL
# fn_tag dnConvertWavToAc3 returns Whether conversion completed successfully (Boolean)
# fn_tag dnConvertWavToAc3 param input purpose Input WAV audio file
# fn_tag dnConvertWavToAc3 param input required yes
# fn_tag dnConvertWavToAc3 param input multipart no
# fn_tag dnConvertWavToAc3 param input type path
# fn_tag dnConvertWavToAc3 param output purpose Output AC3 audio file
# fn_tag dnConvertWavToAc3 param output required yes
# fn_tag dnConvertWavToAc3 param output multipart no
# fn_tag dnConvertWavToAc3 param output type path
dnConvertWavToAc3() {
	local in_file out_file
	in_file="${1}" out_file="${2}"
	# normalise
	in_file="$(dnNormalisePath "${in_file}")"
	dnFileValid "${in_file}" || return 1
	out_file="$(dnNormalisePath "${out_file}")"
	# perform conversion
	# options: -i = input file, -ab = audio bitrate (kbit/s),
	#          -ar = audio sampling frequency (Hz)
	ffmpeg -i "${in_file}" -ab 224 -ar 48000 "${out_file}" &>/dev/null
	# indicate whether successful
	return ${?}
}
# Function: dnCountdownDelay    {{{1
# Displays countdown message in console
#   params: 1 - message prefix
#           2 - delay (seconds)
#   prints: countdown message
#   return: NIL
# fn_tag dnCountdownDelay purpose Displays countdown message in console
# fn_tag dnCountdownDelay prints Countdown message
# fn_tag dnCountdownDelay returns NIL
# fn_tag dnCountdownDelay note Takes integer 'x' and message 'msg' and initially displays
# fn_tag dnCountdownDelay note 'msg in x...'
# fn_tag dnCountdownDelay note then counts down from 'x' and finally displays
# fn_tag dnCountdownDelay note 'msg now'
# fn_tag dnCountdownDelay param prefix purpose Message prefixed to countdown
# fn_tag dnCountdownDelay param prefix required yes
# fn_tag dnCountdownDelay param prefix multipart no
# fn_tag dnCountdownDelay param prefix type string
# fn_tag dnCountdownDelay param prefix note Must make sense when suffixed with ' in 1...' and 'now'
# fn_tag dnCountdownDelay param prefix note Example: 'exiting'
# fn_tag dnCountdownDelay param delay purpose Time of countdown in seconds (integer)
# fn_tag dnCountdownDelay param delay required yes
# fn_tag dnCountdownDelay param delay multipart no
# fn_tag dnCountdownDelay param delay type integer
dnCountdownDelay() {
	# set variables
	local count msg
	count=${2}
	msg="${1} in ${count}..."
	# display countdown message
	dnInfon "${msg}"
	# do countdown
	sleep 1
	((count--)) || true
	while [ "${count}" -gt 0 ]; do
		echo -ne "\b\b\b\b${count}..."
		sleep 1
		((count--)) || true
	done
	# display final message
	echo -e "\b\b\b\b\b\b\bnow    "
	sleep 1
}
# Function: dnCountTarzip    {{{1
# Counts tarzip (*.tar.gz) archives in a directory
#   params: 1 - directory
#   prints: count
#   return: 0|1 (result valid|result invalid)
#   invoke: [ $( dnCountTarzip "${dir}" ) -eq 1 ] || ...
#   notes:  if invalid directory then printed result invalid
#   needs:  functions [dnNormalisePath ; dnDirValid]
# fn_tag dnCountTarzip purpose Count tarzipped archives in a directory
# fn_tag dnCountTarzip prints Count of tarzipped archives in directory (Integer)
# fn_tag dnCountTarzip returns Whether result is valid
# fn_tag dnCountTarzip note Counts files matching pattern '*.tar.gz'
# fn_tag dnCountTarzip usage [ $( dnCountTarzip "${dir}" ) -eq 1 ] || ...
# fn_tag dnCountTarzip param directory purpose Directory to be analysed
# fn_tag dnCountTarzip param directory required yes
# fn_tag dnCountTarzip param directory multipart no
# fn_tag dnCountTarzip param directory type path
# fn_tag dnCountTarzip param directory note If invalid directory then printed count also invalid
dnCountTarzip() {
	# normalise directory
	local dir
	dir="$(dnNormalisePath "${1}")"
	# count tarzip files
	dir -1 "${dir}"/*.tar.gz 2>/dev/null | wc -l
	# return error code if directory invalid
	dnDirValid "${dir}"
	return ${?}
}
# Function: dnCreateSilentAc3    {{{1
# Create silent AC3 audio track
#   params: 1 - output filepath
#           2 - length (seconds) (default=5) [optional]
#   prints: nil
#   return: boolean (0=success|1=failure)
# fn_tag dnCreateSilentAc3 purpose Create silent AC3 audio file
# fn_tag dnCreateSilentAc3 prints NIL
# fn_tag dnCreateSilentAc3 returns Whether file created successfully (Boolean)
# fn_tag dnCreateSilentAc3 param output-file purpose Output AC3 audio file
# fn_tag dnCreateSilentAc3 param output-file required yes
# fn_tag dnCreateSilentAc3 param output-file multipart no
# fn_tag dnCreateSilentAc3 param output-file type path
# fn_tag dnCreateSilentAc3 param duration purpose Length of audio track (seconds)
# fn_tag dnCreateSilentAc3 param duration required no
# fn_tag dnCreateSilentAc3 param duration multipart no
# fn_tag dnCreateSilentAc3 param duration type integer
# fn_tag dnCreateSilentAc3 param duration default 5
dnCreateSilentAc3() {
	# create and set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	local output length byte_count retval
	output="$(dnNormalisePath "${1}")"
	length="${2:-'5'}"
	byte_count=$((length * 24000))
	retval=1 # default
	# create silent file
	# options:
	#     dd: if = input file/device
	#         bs = block size (bytes)
	#         count = number of input blocks to copy
	#    sox: -t  = filetype (raw = no header, wav = WAV)
	#         -w  = unknown
	#         -s  = unknown
	#         -r  = sample rate (Hz)
	#          -  = input on stdin, output on stdout
	# ffmpeg: -i  = input (- = stdin)
	#         -ab = audio bitrate (kbits/s)
	#         -ar = sample rate (Hz)
	#         -ac = audio channels
	#         -y  = overwrite output file
	dd \
		if=/dev/zero \
		bs=4 \
		count=${byte_count} \
		2>/dev/null |
		sox \
			-t raw \
			-wsr 48000 \
			- \
			-t wav \
			-r 48000 \
			- \
			2>/dev/null |
		ffmpeg \
			-i - \
			-ab 224000 \
			-ar 48000 \
			-ac 2 \
			-y \
			"${output}" \
			2>/dev/null
	# determine and indicate outcome
	dnPipeSucceeded "${PIPESTATUS[*]}" && dnFileValid "${output}" && retval=0
	return ${retval}
}
# Function: dnCritRep    {{{1
# Critical report - exit if failed operation
#   params: 1 - exit status of operation ('0' = success)
#           2 - error message if failed
#   prints: 'OK'|'Failed'
#   return: nil
# fn_tag dnCritRep purpose Report operation outcome and exit  with message if it failed
# fn_tag dnCritRep prints Feedback: 'OK.' or 'Failed.'
# fn_tag dnCritRep returns NIL
# fn_tag dnCritRep param exit_status purpose Exit status of operation ('0'=success)
# fn_tag dnCritRep param exit_status required yes
# fn_tag dnCritRep param exit_status multipart no
# fn_tag dnCritRep param exit_status type boolean
# fn_tag dnCritRep param error_message purpose Error message to display on exit
# fn_tag dnCritRep param error_message required no
# fn_tag dnCritRep param error_message multipart no
# fn_tag dnCritRep param error_message type string
dnCritRep() {
	# display result of operation
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	dnReport "${1}"
	# exit with error message if operation failed
	test "${1}" -eq 0 || dnEndScript 1 "${2:-}"
}
# Function: dnDebug    {{{1
# Print debugging message to stdout
#   params: 1+ - message part(s)
#   prints: formatted message
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnDebug purpose Print informational message to standard output
# fn_tag dnDebug prints Formatted message
# fn_tag dnDebug returns NIL
# fn_tag dnDebug param part purpose Message part
# fn_tag dnDebug param part required yes
# fn_tag dnDebug param part multipart yes
# fn_tag dnDebug param part type string
dnDebug() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	dnMessage 'Debug' 1 "${@}"
}
# Function: dnDebugStderr    {{{1
# Print debugging message to stderr
#   params: 1+ - message part(s)
#   prints: formatted message
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnDebugStderr purpose Print debugging message to standard error
# fn_tag dnDebugStderr prints Formatted message
# fn_tag dnDebugStderr returns NIL
# fn_tag dnDebugStderr param part purpose Message part
# fn_tag dnDebugStderr param part required yes
# fn_tag dnDebugStderr param part multipart yes
# fn_tag dnDebugStderr param part type string
dnDebugStderr() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	dnMessageStderr 'Debug' 1 "${@}"
}
# Function: dnDecrement    {{{1
# Increment number
#   params: 1 - number to decrement
#           2 - value of decrement (optional, default=1)
#   prints: decremented value
#   return: boolean (0=success|1=error)
# fn_tag dnDecrement purpose Decrement number
# fn_tag dnDecrement prints Decremented number
# fn_tag dnDecrement returns Whether value was successfully decremented (Boolean)
# fn_tag dnDecrement param number purpose Number to be decremented
# fn_tag dnDecrement param number required yes
# fn_tag dnDecrement param number multipart no
# fn_tag dnDecrement param number type number
# fn_tag dnDecrement param decrement purpose Size of decrement
# fn_tag dnDecrement param decrement required yes
# fn_tag dnDecrement param decrement multipart no
# fn_tag dnDecrement param decrement type integer
# fn_tag dnDecrement param decrement default 1
dnDecrement() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No number provided"
	local val decrement
	val="${1}" decrement="${2:-1}"
	dnValidNumber "${val}" &>/dev/null || return 1
	echo "$((val - decrement))"
}
# Function: dnDialogType    {{{1
# Determine best dialog type available on system
#     opts: d - dialog type [optional, default=none]
#           c - dialog capability [optional, multiple, default='select', 'gui']
#   params: nil
#   prints: dialog type
#   return: boolean (0=found utility|1=didn't)
# fn_tag dnDialogType purpose Selects best available dialog type
# fn_tag dnDialogType prints Selected dialog type (dialog name)
# fn_tag dnDialogType returns Whether dialog type selected (Boolean)
# fn_tag dnDialogType note Function tries hard to return a dialog type despite nonsense options
# fn_tag dnDialogType note Warnings and errors are sent to stderr
# fn_tag dnDialogType option d purpose Specify the dialog type to use
# fn_tag dnDialogType option d required no
# fn_tag dnDialogType option d multiple no
# fn_tag dnDialogType option d type string
# fn_tag dnDialogType option d value dialog
# fn_tag dnDialogType option d value gxmessage
# fn_tag dnDialogType option d value kdialog
# fn_tag dnDialogType option d value xmessage
# fn_tag dnDialogType option d value zenity
# fn_tag dnDialogType option d note Default is no type specified
# fn_tag dnDialogType option d note Overrides auto-selection if available and meets capability requirements
# fn_tag dnDialogType option c purpose Specify required capabilities of dialog
# fn_tag dnDialogType option c required no
# fn_tag dnDialogType option c multiple yes
# fn_tag dnDialogType option c type string
# fn_tag dnDialogType option c value newline_character
# fn_tag dnDialogType option c value newline_escape
# fn_tag dnDialogType option c value info
# fn_tag dnDialogType option c value warn
# fn_tag dnDialogType option c value error
# fn_tag dnDialogType option c value popup
# fn_tag dnDialogType option c value confirm
# fn_tag dnDialogType option c value select
# fn_tag dnDialogType option c value dir
# fn_tag dnDialogType option c value file
# fn_tag dnDialogType option c value gui
# fn_tag dnDialogType option c value terminal
# fn_tag dnDialogType option c note Default: gui, select
# fn_tag dnDialogType option c note Where mutually exclusive values are provided, the last one wins
# fn_tag dnDialogType option c note Mutually exclusive: gui, select
# fn_tag dnDialogType option c note Mutually exclusive: info, warn, error, popup, confirm, select, dir, file
dnDialogType() {
	# get option values
	local opt_dialog OPTIONS
	opt_dialog='' OPTIONS=''
	local -a opt_capabilities=()
	if ! OPTIONS="$(
		getopt \
			--options d:c: \
			--long dialog:,capability: \
			--name "${BASH_SOURCE[0]}" \
			-- "${@}"
	)"; then
		# getopt displays errors
		exit 1
	fi
	eval set -- "${OPTIONS}"
	while true; do
		case "${1}" in
		-d | --dialog)
			opt_dialog="${2}"
			shift 2
			;;
		-c | --capability)
			opt_capabilities+=("${2}")
			shift 2
			;;
		--)
			shift
			break
			;;
		*) break ;;
		esac
	done
	for arg in "${@}"; do # remaining arguments
		echo "${BASH_SOURCE[0]}: ignoring parameter: ${arg}" 1>&2
	done
	# process option values
	# • dialog
	#   - start with base preference list
	local -a dlg_preferences=("${dn_dlgs[@]}")
	#   - check whether there is an override for the current desktop
	local -a desktops=()
	mapfile -t desktops <<<"${XDG_CURRENT_DESKTOP//:/$'\n'}" # colon-delimited
	for desktop in "${desktops[@]}"; do
		if dnElementInArray "${desktop}" "${!dn_dlg_desktop_overrides[@]}"; then
			dlg_preferences=(
				"${dn_dlg_desktop_overrides[${desktop}]}"
				"${dlg_preferences[@]}"
			)
		fi
	done
	#   - check for user-specified dialog
	[ -n "${opt_dialog+x}" ] && dlg_preferences=(
		"${opt_dialog}"
		"${dlg_preferences[@]}"
	)
	# • capabilities
	local kind type
	kind='gui'    # gui (default), terminal
	type='select' # info, warn, error, popup, confirm, or select (default)
	local -a required_capabilities=() unknown_capabilities=()
	for opt_capability in "${opt_capabilities[@]}"; do
		case "${opt_capability}" in
		newline_character | newline_escape) required_capabilities+=("${opt_capability}") ;;
		gui | terminal) kind="${opt_capability}" ;;
		info | warn | error | popup | confirm | select | dir | file) type="${opt_capability}" ;;
		*) unknown_capabilities+=("${opt_capability}") ;;
		esac
	done
	for unknown_capability in "${unknown_capabilities[@]}"; do
		echo "${BASH_SOURCE[0]}: unknown capability: ${unknown_capability}" 1>&2
	done
	required_capabilities+=("${kind}" "${type}")
	# select dialog that matches required capabilities
	local dialog
	dialog=''
	for dlg in "${dlg_preferences[@]}"; do
		# check dialog is valid
		if ! dnElementInArray "${dlg}" "${dn_dlgs[@]}"; then
			echo "${BASH_SOURCE[0]}: invalid dialog '${dlg}'" 1>&2
			continue
		fi
		# check capabilities
		# • get capabilities for this dialog
		local -a dlg_capabilities=()
		mapfile -t dlg_capabilities <<<"${dn_dlgs_capabilities[$dlg]// /$'\n'}"
		if [ "${#dlg_capabilities[@]}" -eq 0 ]; then
			echo "${BASH_SOURCE[0]}: unable to retieve capabilities for dialog: '${dlg}'" 1>&2
			continue
		fi
		# • check whether dialog capabilities include all required capabilities
		local dlg_has_all_required_capabilities
		dlg_has_all_required_capabilities=true
		for required_capability in "${required_capabilities[@]}"; do
			if ! dnElementInArray "${required_capability}" "${dlg_capabilities[@]}"; then
				dlg_has_all_required_capabilities=false
				break
			fi
		done
		if [[ $dlg_has_all_required_capabilities == true ]]; then
			dialog="${dlg}"
			break
		fi
	done
	# print result and return exit status
	if [ -n "${dialog+x}" ]; then
		echo "${dialog}"
		return 0
	else
		return 1
	fi
}
# Function: dnDirEmpty    {{{1
# Tests whether directory empty (assume directory exists)
#   params: 1 - directory
#   prints: nil
#   return: 0|1 (empty|not empty)
#   needs:  functions [dnNormalisePath]
# fn_tag dnDirEmpty purpose Detemine whether directory is empty
# fn_tag dnDirEmpty prints NIL
# fn_tag dnDirEmpty returns Whether directory is empty (Boolean)
# fn_tag dnDirEmpty note Functions assumes directory exists
# fn_tag dnDirEmpty param directory purpose Directory to be analysed
# fn_tag dnDirEmpty param directory required yes
# fn_tag dnDirEmpty param directory multipart no
# fn_tag dnDirEmpty param directory type path
dnDirEmpty() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	local dir content_count
	dir='' content_count=''
	dir="$(dnNormalisePath "${1}")"
	content_count=$(dnDirFileDirCount "${dir}")
	[ "${content_count}" -eq 0 ]
	return ${?}
}
# Function: dnDirFileCountXoX    {{{1
# Counts files in a directory with pattern 'xxx.x+'
#   params: 1 - directory name [optional] (default=current directory)
#   prints: number of files in directory matching pattern
#   return: 0|1 (valid directory|invalid directory)
#   needs:  functions [dnDirValid]
# fn_tag dnDirFileCountXoX purpose Count number of files having extensions in directory
# fn_tag dnDirFileCountXoX prints Number of files in directory matching pattern
# fn_tag dnDirFileCountXoX returns Whether directory is valid (Boolean)
# fn_tag dnDirFileCountXoX note Only counts files with extensions, e.g., 'file.ext'
# fn_tag dnDirFileCountXoX param directory purpose Directory to be analysed
# fn_tag dnDirFileCountXoX param directory required no
# fn_tag dnDirFileCountXoX param directory multipart no
# fn_tag dnDirFileCountXoX param directory type path
# fn_tag dnDirFileCountXoX param directory note Defaults to current directory if not supplied
dnDirFileCountXoX() {
	local dir
	dir="${1:-"$(pwd)"}"
	dir="$(dnNormalisePath "${dir}")"
	dnDirValid "${dir}" || return 1
	# remove directories from count by using '-F' flag and 'grep -v "\/$"'
	dir -1 -F -A -L "${dir}" |
		grep "[[:alnum:]]*\.[[:alnum:]]\+\(\*\|\@\)\?$" |
		grep -c -v "\/$"
	return 0
}
# Function: dnDirFileDirCount    {{{1
# Counts files/directories in a directory
#   params: 1 - directory name [optional] (default=current directory)
#   prints: number of files and subdirectories in directory
#   return: 0|1 (valid directory|invalid directory)
# fn_tag dnDirFileDirCount purpose Count file and subdirectories in a directory
# fn_tag dnDirFileDirCount prints Number of files and subdirectories in directory (Integer)
# fn_tag dnDirFileDirCount returns Whether directory is valid (Boolean)
# fn_tag dnDirFileDirCount param directory purpose Directory to be analysed
# fn_tag dnDirFileDirCount param directory required no
# fn_tag dnDirFileDirCount param directory multipart no
# fn_tag dnDirFileDirCount param directory type path
# fn_tag dnDirFileDirCount param directory note default to cwd if not supplied
dnDirFileDirCount() {
	local dir grep
	grep="()$"
	dir="${1:-"$(pwd)"}"
	dir="$(dnNormalisePath "${dir}")"
	dnDirValid "${dir}" || return 1
	# set directory command
	local cmd
	cmd="dir -1 -F -A -L" # -1 = one file/line
	# -F = append file type indicator
	# -A = show hidden files (not '.' and '..')
	# -L = follow symbolic links
	# get and return count
	"${cmd}" "${dir}" | grep -c -v "${grep}"
	return 0
}
# Function: dnDirFileOnlyCount    {{{1
# Counts files in a directory
#   params: 1 - directory name [optional] (default=current directory)
#   prints: number of files in directory
#   return: 0|1 (valid directory|invalid directory)
# fn_tag dnDirFileOnlyCount purpose Counts files in a directory
# fn_tag dnDirFileOnlyCount prints Number of files in a directory (Integer)
# fn_tag dnDirFileOnlyCount returns Whether directory is valid (Boolean)
# fn_tag dnDirFileOnlyCount note Does not include subdirectories
# fn_tag dnDirFileOnlyCount param directory purpose Directory to be analysed
# fn_tag dnDirFileOnlyCount param directory required no
# fn_tag dnDirFileOnlyCount param directory multipart no
# fn_tag dnDirFileOnlyCount param directory type path
# fn_tag dnDirFileOnlyCount param directory note default to cwd if not supplied
dnDirFileOnlyCount() {
	local dir grep
	grep="\/$"
	dir="${1:-"$(pwd)"}"
	dir="$(dnNormalisePath "${dir}")"
	dnDirValid "${dir}" || return 1
	# set directory command
	local cmd
	cmd="dir -1 -F -A -L" # -1 = one file/line
	# -F = append file type indicator
	# -A = show hidden files (not '.' and '..')
	# -L = follow symbolic links
	# get and return count
	${cmd} "${dir}" | grep -c -v "${grep}"
	return 0
}
# Function: dnDirValid    {{{1
# Directory exists and readable
#   params: 1 - directory
#   prints: nil
#   return: 0|1 (exists|does not exist)
#   invoke: if dnDirValid "${dirname}" ; then ...
# fn_tag dnDirValid purpose Determine whether directory exists and is readable
# fn_tag dnDirValid prints NIL
# fn_tag dnDirValid returns Whether directory exists and is readable (Boolean)
# fn_tag dnDirValid usage if dnDirValid "${dirname}" ; then ...
# fn_tag dnDirValid param directory purpose Directory to be analysed
# fn_tag dnDirValid param directory required yes
# fn_tag dnDirValid param directory multipart no
# fn_tag dnDirValid param directory type path
dnDirValid() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	[ -d "${1}" ] && [ -r "${1}" ]
	return ${?}
}
# Function: dnDirValidNoSpaces    {{{1
# Directory exists and readable and directory path contains no spaces
#   params: 1 - directory
#   prints: nil
#   return: 0|1 (exists|does not exist)
#   invoke: if dnDirValidNoSpaces "${dirname}" ; then ...
#   needs:  functions [dnNoSpace]
# fn_tag dnDirValidNoSpaces purpose Determine whether directory path exists, is readable and contains no spaces
# fn_tag dnDirValidNoSpaces prints NIL
# fn_tag dnDirValidNoSpaces returns Whether directory exists, is readable and contains no spaces (Boolean)
# fn_tag dnDirValidNoSpaces usage if dnDirValidNoSpaces "${dirname}" ; then ...
# fn_tag dnDirValidNoSpaces param directory purpose Directory to be analysed
# fn_tag dnDirValidNoSpaces param directory required yes
# fn_tag dnDirValidNoSpaces param directory multipart no
# fn_tag dnDirValidNoSpaces param directory type path
dnDirValidNoSpaces() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	[[ -d "${1}" && -r "${1}" ]] && dnNoSpace "${1}"
	return ${?}
}
# Function: dnDiscMount    {{{1
# Common routine for mounting disc
#   params: 1 - drive name,
#           2 - drive device
#   prints: feedback (not for capture)
#   return: 0|1 (success|failure)
#   needs:  functions [dnReport]
# fn_tag dnDiscMount purpose Mount disc in drive
# fn_tag dnDiscMount prints Feedback
# fn_tag dnDiscMount returns Whether disc mounted successfully (Boolean)
# fn_tag dnDiscMount note Attempts to close drive tray before mounting disc
# fn_tag dnDiscMount param name purpose Human-readable drive name
# fn_tag dnDiscMount param name required yes
# fn_tag dnDiscMount param name multipart no
# fn_tag dnDiscMount param name type string
# fn_tag dnDiscMount param device purpose Drive device location
# fn_tag dnDiscMount param device required yes
# fn_tag dnDiscMount param device multipart no
# fn_tag dnDiscMount param device type path
dnDiscMount() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No drive path provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No drive name provided"
	local name device exit_status
	name="${1}" device="${2}" exit_status=''
	# load disc
	dnTrayClose "${name}" "${device}"
	# mount
	dnInfon "mounting ${name}... "
	mount "${device}" &>/dev/null
	exit_status=${?}
	dnReport ${exit_status}
	return ${exit_status}
}
# Function: dnDiscUnmount    {{{1
# Common routine for unmounting disc
#   params: 1 - drive name,
#           2 - drive device
#   prints: feedback (not for capture)
#   return: 0|1 (success|failure)
#   needs:  functions [dnReport]
# fn_tag dnDiscUnmount purpose Unmount disc in drive
# fn_tag dnDiscUnmount prints Feedback
# fn_tag dnDiscUnmount returns Whether disc successfully unmounted
# fn_tag dnDiscUnmount param name purpose Human-readable drive name
# fn_tag dnDiscUnmount param name required yes
# fn_tag dnDiscUnmount param name multipart no
# fn_tag dnDiscUnmount param name type string
# fn_tag dnDiscUnmount param device purpose Drive device location
# fn_tag dnDiscUnmount param device required yes
# fn_tag dnDiscUnmount param device multipart no
# fn_tag dnDiscUnmount param device type path
dnDiscUnmount() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No drive path provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No drive name provided"
	local exit_status
	exit_status=''
	dnInfon "unmounting ${name}... "
	umount "${2}" &>/dev/null
	exit_status=${?}
	dnReport ${exit_status}
	return ${exit_status}
}
# Function: dnDisplayFilesGitRepoStatus    {{{1
# Display status of directory files with regard to local git repo
#   params: nil
#   prints: file status
#   return: nil
#   note:   intended for repo consisting only of current directory
#   note:   if repo covers more than current directory may get unexpected results
# fn_tag dnDisplayFilesGitRepoStatus purpose Display status of directory files with regard to local git repo
# fn_tag dnDisplayFilesGitRepoStatus prints Status of files in directory
# fn_tag dnDisplayFilesGitRepoStatus returns NIL
# fn_tag dnDisplayFilesGitRepoStatus usage See dnUpdateRemoteGitRepo for example using this function
# fn_tag dnDisplayFilesGitRepoStatus note Intended for local repo consisting only of current directory
# fn_tag dnDisplayFilesGitRepoStatus note If local repo covers more than current dir may get unexpected results
# fn_tag dnDisplayFilesGitRepoStatus note Covers only simple states: modified, added, deleted, renamed, untracked
# fn_tag dnDisplayFilesGitRepoStatus note Does not cover more complex states, such as merges, which all show as unknown
dnDisplayFilesGitRepoStatus() {
	# variables
	local -a modified=() added=() renamed=() deleted=() untracked=() unknown=()
	local file_status file_name output
	file_status='' file_name='' output=''
	### make alterations to status flags here ###
	# • file status '??' is extracted as '?' in BASH_REMATCH[1]
	#   so make untrack_flags ('??' '?') instead of ('??')
	local -a untrack_flags=('??' '?')
	local -a mod_flags=(MM M) add_flags=(A)
	local -a rename_flags=(R) delete_flags=(D)
	#############################################
	output="$(git status --porcelain)"
	# loop through git status report recording file status
	while read -r line; do
		if ! [[ $line =~ ^[[:space:]]*([^[:space:]])+[[:space:]]+(.*)$ ]]; then
			echo "Unable to parse git-status output: '$line'" 1>&2
			continue
		fi
		file_status="${BASH_REMATCH[1]}"
		file_name="${BASH_REMATCH[2]}"
		dnElementInArray "${file_status}" "${mod_flags[@]}" && modified+=("${file_name}") && continue
		dnElementInArray "${file_status}" "${add_flags[@]}" && added+=("${file_name}") && continue
		dnElementInArray "${file_status}" "${rename_flags[@]}" && renamed+=("${file_name}") && continue
		dnElementInArray "${file_status}" "${delete_flags[@]}" && deleted+=("${file_name}") && continue
		dnElementInArray "${file_status}" "${untrack_flags[@]}" && untracked+=("${file_name}") && continue
		unknown+=("${file_name}")
	done <<<"${output}"
	# display files status
	dnInfo 'Local git repo status of directory files:'
	echo "${dn_divider}"
	if [ ${#modified[@]} -gt 0 ]; then
		echo 'Modified since last git commit:'
		for file in "${modified[@]}"; do
			echo "  ${file}"
		done
	fi
	if [ ${#added[@]} -gt 0 ]; then
		echo 'Added since last git commit:'
		for file in "${added[@]}"; do
			echo "  ${file}"
		done
	fi
	if [ ${#renamed[@]} -gt 0 ]; then
		echo 'Renamed since last git commit:'
		for file in "${renamed[@]}"; do
			echo "  ${file}"
		done
	fi
	if [ ${#deleted[@]} -gt 0 ]; then
		echo 'Deleted since last git commit:'
		for file in "${deleted[@]}"; do
			echo "  ${file}"
		done
	fi
	if [ ${#untracked[@]} -gt 0 ]; then
		echo 'Not tracked by git repo:'
		for file in "${untracked[@]}"; do
			echo "  ${file}"
		done
	fi
	if [ ${#unknown[@]} -gt 0 ]; then
		echo 'Status unknown:'
		for file in "${unknown[@]}"; do
			echo "  ${file}"
		done
		echo '*******************************************************'
		echo "* Investigate using 'git status --porcelain' output   *"
		echo '*                                                     *'
		echo "* In libdncommon-bash file 'libprogram-interaction'   *"
		echo "* examine functions 'dnDisplayFilesGitRepoStatus' and *"
		echo '* dnLocalGitRepoUptodate, and amend them accordingly  *'
		echo '*                                                     *'
		echo '* When there are files with unknown status you cannot *'
		echo '* trust any report that the local repo is up to date  *'
		echo '*******************************************************'
	fi
	echo "${dn_divider}"
}
# Function: dnDlg    {{{1
# Dialog engine
#   params: 1 - type ('info', 'warn', 'error', 'popup')
#           2 - title (''|'-' = script_name)
#           3 - message
#   prints: nil
#   return: 0|1 (Boolean)
#     todo: ensure support for dnList[Tag]Dlg and dnSelect[Tag]Dlg
#           ensure support for input box
# fn_tag dnDlg purpose Dialog/popup engine
# fn_tag dnDlg prints NIL
# fn_tag dnDlg returns Boolean
# fn_tag dnDlg note All dialogs automatically return true boolean value
# fn_tag dnDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnDlg note If variable dn_app_icon_all_dialogs true then also use for warn|error dlgs
# fn_tag dnDlg param dialog purpose Determines type of dialog displayed
# fn_tag dnDlg param dialog required yes
# fn_tag dnDlg param dialog multipart no
# fn_tag dnDlg param dialog type string
# fn_tag dnDlg param dialog value info
# fn_tag dnDlg param dialog value warn
# fn_tag dnDlg param dialog value error
# fn_tag dnDlg param dialog value popup
# fn_tag dnDlg param title purpose Dialog title
# fn_tag dnDlg param title required yes
# fn_tag dnDlg param title multipart no
# fn_tag dnDlg param title type string
# fn_tag dnDlg param title default -
# fn_tag dnDlg param title note If empty string or '-' then defaults to name of running script
# fn_tag dnDlg param message purpose Dialog message
# fn_tag dnDlg param message required yes
# fn_tag dnDlg param message multipart no
# fn_tag dnDlg param message type string
# fn_tag dnDlg param message note Message can contain newline tokens ('\n').
dnDlg() {
	# set variables and sanity checks
	[ -n "${3+x}" ] || dnAbort "${FUNCNAME[0]}: No dialog message provided"
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No dialog title provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No dialog type provided"
	local type title message
	type="${1}" title="${2:-${dn_self}}" message="${3}"
	local icon x11user valid_types duration
	icon='' x11user='' valid_types='info warn error popup'
	duration=10000 # duration is popup display time in milliseconds
	if ! dnElementInList "${type}" "${valid_types}"; then
		dnErrorStderr "invalid dialog type '${type}'"
		return 1
	fi
	case "${type}" in
	'info' | 'popup') icon="@pkgdata_dir@/info.xpm" ;;
	'warn') icon="@pkgdata_dir@/warn.xpm" ;;
	'error') icon="@pkgdata_dir@/error.xpm" ;;
	esac
	if [ -n "${dn_app_icon+x}" ] && [ -f "${dn_app_icon}" ]; then
		# user has overridden icon
		case "${type}" in
		'info' | 'popup') icon="${dn_app_icon}" ;;
		'warn' | 'error') dnFlagTrue "$(
			# shellcheck disable=SC2154
			dnStandardiseBoolean "${dn_app_icon_all_dialogs}"
		)" && icon="${dn_app_icon}" ;;
		esac
	fi
	# if root there are some difficulties sending notification
	if test "${USER}" = 'root'; then
		# must have at least one user with active X session in order
		# to display GUI message
		x11user="$(who | grep ":0" | cut -d ' ' -f 1 | sort | uniq | head -n 1)"
		if [ -z "${x11user}" ]; then
			dnLog 'cannot display notification -- no active X session'
			return
		fi
		su - "${x11user}" \
			-c "DISPLAY=:0 notify-send \
				-i \"${icon}\" \
				-t ${duration} \
				\"${title}\" \
				\"${message}\""
		dnFlagTrue "${?}" || dnErrorStderr 'unable to send system notification'
	else # regular user
		notify-send \
			-i "${icon}" \
			-t ${duration} \
			"${title}" \
			"${message}"
		dnFlagTrue "${?}" || dnLog 'unable to send system notification'
	fi
}

# Function: dnElementInArray    {{{1
# Determine whether string present in array
#   params: 1  - element
#           2+ - array elements
#   prints: nil
#   return: boolean (0=present|1=not present)
#   usage:  if dnElementInArray "${element}" "${array[@]}" ; then ...
# fn_tag dnElementInArray purpose Determine whether element present in array
# fn_tag dnElementInArray prints NIL
# fn_tag dnElementInArray returns Whether element in array (Boolean)
# fn_tag dnElementInArray usage if dnElementInArray "${element}" "${array[@]}" ; then ...
# fn_tag dnElementInArray param element purpose Array element to search for
# fn_tag dnElementInArray param element required yes
# fn_tag dnElementInArray param element multipart no
# fn_tag dnElementInArray param element type string
# fn_tag dnElementInArray param array purpose Array to search
# fn_tag dnElementInArray param array required yes
# fn_tag dnElementInArray param array multipart yes
# fn_tag dnElementInArray param array type string
dnElementInArray() {
	[ ${#} -gt 1 ] || return 1 # sanity check
	local element
	element="${1}"
	shift
	while [ "${#}" -gt 0 ]; do # loop through array elements
		[ "${1}" = "${element}" ] && return 0
		shift
	done
	return 1
}
# Function: dnElementInList    {{{1
# Check whether element in list
#   params: 1 - search term [required]
#           2 - list to be searched [required]
#           3 - list delimiter (default=SPC) [optional]
#   prints: nil
#   return: boolean (0=in list, 1=not in list)
# fn_tag dnElementInList purpose Determine whether list contains a particular element
# fn_tag dnElementInList prints NIL
# fn_tag dnElementInList returns Whether list contains element
# fn_tag dnElementInList param element purpose Element to be searched for in list
# fn_tag dnElementInList param element required yes
# fn_tag dnElementInList param element multipart no
# fn_tag dnElementInList param element type string
# fn_tag dnElementInList param list purpose List to be searched
# fn_tag dnElementInList param list required yes
# fn_tag dnElementInList param list multipart no
# fn_tag dnElementInList param list type string
# fn_tag dnElementInList param list note The list is a simple string -- not a complex data type
# fn_tag dnElementInList param delimiter purpose List delimiter
# fn_tag dnElementInList param delimiter required no
# fn_tag dnElementInList param delimiter multipart no
# fn_tag dnElementInList param delimiter type string
# fn_tag dnElementInList param delimiter default 'Space'
dnElementInList() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No list provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No element provided"
	local element string delim item
	element="${1}" string="${2}" delim="${3:-' '}" item=''
	local -a ary=()
	IFS="${delim}" read -r -a ary <<<"${string}"
	for item in "${ary[@]}"; do
		[ "${item}" = "${element}" ] && return 0
	done
	return 1
}
# Function: dnEndScript    {{{1
# Common exit point from script
#   option: t  - print stack trace (optional)
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1  - exit status
#                ('0'=success|'-'=success with no feedback|*=failed)
#                [default='-']
#           2+ - message
#   prints: nil
#   return: nil
# fn_tag dnEndScript purpose Common exit point from script
# fn_tag dnEndScript prints Feedback
# fn_tag dnEndScript returns Whether script exiting successfully (Boolean)
# fn_tag dnEndScript note First prints any messages passed as parameters
# fn_tag dnEndScript note Next prints success or failure message unless suppressed
# fn_tag dnEndScript note Then prints stack trace if requested
# fn_tag dnEndScript note Finally prints exit message
# fn_tag dnEndScript option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnEndScript option t required no
# fn_tag dnEndScript option t multiple no
# fn_tag dnEndScript option t type none
# fn_tag dnEndScript option t note Will print trace regardless of 'exit-status' param
# fn_tag dnEndScript option s purpose Number of function calls to skip in trace output
# fn_tag dnEndScript option s required no
# fn_tag dnEndScript option s multiple no
# fn_tag dnEndScript option s type integer
# fn_tag dnEndScript option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnEndScript option s note This option implies the 't' option
# fn_tag dnEndScript param exit-status purpose Indicates whether exiting successfully or not
# fn_tag dnEndScript param exit-status required yes
# fn_tag dnEndScript param exit-status multipart no
# fn_tag dnEndScript param exit-status type string
# fn_tag dnEndScript param exit-status value 0
# fn_tag dnEndScript param exit-status value -
# fn_tag dnEndScript param exit-status value 1
# fn_tag dnEndScript param exit-status note '0' = exiting sucessfully and display success message
# fn_tag dnEndScript param exit-status note '-' = exiting successfully but suppress success message
# fn_tag dnEndScript param exit-status note * (any other value) = exiting unsuccessfully and display failure message
# fn_tag dnEndScript param message purpose Exit message
# fn_tag dnEndScript param message required no
# fn_tag dnEndScript param message multipart yes
# fn_tag dnEndScript param message type string
dnEndScript() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# variables
	local exit_status
	exit_status=${1:-'-'}
	shift
	# display messages
	case ${exit_status} in
	'0')
		[ ${#} -gt 0 ] && dnInfo "${@}"
		dnInfo "${dn_self} succeeded"
		;;
	'-') ;; # no feedback
	*)
		[ ${#} -gt 0 ] && dnError "${@}"
		dnError "${dn_self} failed"
		;;
	esac
	# • print stack trace if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfo 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfo "  ${i}"
			done
		)
	fi
	dnInfo "...${dn_self} is finished"
	# exit
	[ "${exit_status}" = '-' ] && exit_status=0
	exit "${exit_status}"
}
# Function: dnEndScriptDlg    {{{1
# Common exit point from script
#   option: t  - print stack trace to stdout (optional)
#              - stack trace is not included in dialog output
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1  - exit status
#                ('0'=success|'-'=no status|*=failed)
#                [default='-']
#           2+ - message
#   prints: nil
#   return: nil
#   needs:  functions [dnInfo ; dnError]
# fn_tag dnEndScriptDlg purpose Common exit point from script
# fn_tag dnEndScriptDlg prints Feedback
# fn_tag dnEndScriptDlg returns Whether script exiting successfully (Boolean)
# fn_tag dnEndScriptDlg note Acts as 'dnEndScript' but also displays messages in dialog
# fn_tag dnEndScriptDlg note Dialog includes any messages passed as parameters
# fn_tag dnEndScriptDlg note Dialog also includes success or failure message unless suppressed
# fn_tag dnEndScriptDlg note Dialog finally includes an exit message
# fn_tag dnEndScriptDlg option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnEndScriptDlg option t required no
# fn_tag dnEndScriptDlg option t multiple no
# fn_tag dnEndScriptDlg option t type none
# fn_tag dnEndScriptDlg option t note Will print trace regardless of 'exit-status' param
# fn_tag dnEndScriptDlg option s purpose Number of function calls to skip in trace output
# fn_tag dnEndScriptDlg option s required no
# fn_tag dnEndScriptDlg option s multiple no
# fn_tag dnEndScriptDlg option s type integer
# fn_tag dnEndScriptDlg option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnEndScriptDlg option s note This option implies the 't' option
# fn_tag dnEndScriptDlg param exit-status purpose Indicates whether exiting successfully or not
# fn_tag dnEndScriptDlg param exit-status required yes
# fn_tag dnEndScriptDlg param exit-status multipart no
# fn_tag dnEndScriptDlg param exit-status type string
# fn_tag dnEndScriptDlg param exit-status value 0
# fn_tag dnEndScriptDlg param exit-status value -
# fn_tag dnEndScriptDlg param exit-status value 1
# fn_tag dnEndScriptDlg param exit-status note '0' = exiting sucessfully and include success message
# fn_tag dnEndScriptDlg param exit-status note '-' = exiting successfully but do not include success message
# fn_tag dnEndScriptDlg param exit-status note * (any other value) = exiting unsuccessfully and include failure message
# fn_tag dnEndScriptDlg param message purpose Exit message
# fn_tag dnEndScriptDlg param message required no
# fn_tag dnEndScriptDlg param message multipart yes
# fn_tag dnEndScriptDlg param message type string
dnEndScriptDlg() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# variables
	local exit_status msg_dlg msg
	exit_status=${1:-'-'} msg_dlg='' msg=''
	shift
	# get compound message for dialog
	for msg in "${@}"; do
		if [ -z "${msg_dlg}" ]; then
			msg_dlg="${msg}."
		else
			msg_dlg="${msg_dlg}\n${msg}."
		fi
	done
	# output to terminal and dialog
	case ${exit_status} in
	'0')
		[ ${#} -gt 0 ] && dnInfo "${@}"
		dnInfo "${dn_self} succeeded"
		dnInfoDlg "${msg_dlg}"
		;;
	'-') ;; # no feedback
	*)
		[ ${#} -gt 0 ] && dnError "${@}"
		dnError "${dn_self} failed"
		dnErrorDlg "${msg_dlg}"
		;;
	esac
	# • print stack trace (to stdout only) if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfo 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfo "  ${i}"
			done
		)
	fi
	dnInfo "...${dn_self} is finished"
	# exit
	[ "${exit_status}" = '-' ] && exit_status=0
	exit "${exit_status}"
}
# Function: dnEndScriptPrompt    {{{1
# Common exit point from script requiring prompt
#   option: t  - print stack trace (optional)
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1  - exit status
#                ('0'=success|'-'=success with no feedback|*=failed)
#                [default='-']
#           2+ - message
#   prints: nil
#   return: nil
# fn_tag dnEndScriptPrompt purpose Common exit point from script requiring prompt
# fn_tag dnEndScriptPrompt prints Feedback
# fn_tag dnEndScriptPrompt returns Whether script exiting successfully (Boolean)
# fn_tag dnEndScriptPrompt note First prints any messages passed as parameters
# fn_tag dnEndScriptPrompt note Next prints success or failure message unless suppressed
# fn_tag dnEndScriptPrompt note Then prints stack trace if requested
# fn_tag dnEndScriptPrompt note Next prints exit message
# fn_tag dnEndScriptPrompt note Finally prompts user before exiting
# fn_tag dnEndScriptPrompt option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnEndScriptPrompt option t required no
# fn_tag dnEndScriptPrompt option t multiple no
# fn_tag dnEndScriptPrompt option t type none
# fn_tag dnEndScriptPrompt option t note Will print trace regardless of 'exit-status' param
# fn_tag dnEndScriptPrompt option s purpose Number of function calls to skip in trace output
# fn_tag dnEndScriptPrompt option s required no
# fn_tag dnEndScriptPrompt option s multiple no
# fn_tag dnEndScriptPrompt option s type integer
# fn_tag dnEndScriptPrompt option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnEndScriptPrompt option s note This option implies the 't' option
# fn_tag dnEndScriptPrompt param exit-status purpose Indicates whether exiting successfully or not
# fn_tag dnEndScriptPrompt param exit-status required yes
# fn_tag dnEndScriptPrompt param exit-status multipart no
# fn_tag dnEndScriptPrompt param exit-status type string
# fn_tag dnEndScriptPrompt param exit-status value 0
# fn_tag dnEndScriptPrompt param exit-status value -
# fn_tag dnEndScriptPrompt param exit-status value 1
# fn_tag dnEndScriptPrompt param exit-status note '0' = exiting sucessfully and display success message
# fn_tag dnEndScriptPrompt param exit-status note '-' = exiting successfully but suppress success message
# fn_tag dnEndScriptPrompt param exit-status note * (any other value) = exiting unsuccessfully and display failure message
# fn_tag dnEndScriptPrompt param message purpose Exit message
# fn_tag dnEndScriptPrompt param message required no
# fn_tag dnEndScriptPrompt param message multipart yes
# fn_tag dnEndScriptPrompt param message type string
dnEndScriptPrompt() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# variables
	local exit_status
	exit_status=${1:-'-'}
	shift
	# print messages
	case ${exit_status} in
	'0')
		[ ${#} -gt 0 ] && dnInfo "${@}"
		dnInfo "${dn_self} succeeded"
		;;
	'-') ;; # no feedback
	*)
		[ ${#} -gt 0 ] && dnError "${@}"
		dnError "${dn_self} failed"
		;;
	esac
	# • print stack trace if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfo 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfo "  ${i}"
			done
		)
	fi
	dnInfo "...${dn_self} is finished"
	[ "${exit_status}" = '-' ] && exit_status=0
	# prompt user and exit
	dnPrompt
	exit "${exit_status}"
}
# Function: dnEndScriptStderr    {{{1
# Common exit point from script
#   option: t  - print stack trace to stdout (optional)
#              - stack trace is not included in dialog output
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1  - exit status
#                ('0'=success|'-'=success with no feedback|*=failed)
#                [default='-']
#           2+ - message
#   prints: nil
#   return: nil
# fn_tag dnEndScriptStderr purpose Common exit point from script
# fn_tag dnEndScriptStderr prints Feedback
# fn_tag dnEndScriptStderr returns Whether script exiting successfully (Boolean)
# fn_tag dnEndScriptStderr note First prints any messages passed as parameters
# fn_tag dnEndScriptStderr note Next prints success or failure message unless suppressed
# fn_tag dnEndScriptStderr note Then prints stack trace if requested
# fn_tag dnEndScriptStderr note Finally prints exit message
# fn_tag dnEndScriptStderr option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnEndScriptStderr option t required no
# fn_tag dnEndScriptStderr option t multiple no
# fn_tag dnEndScriptStderr option t type none
# fn_tag dnEndScriptStderr option t note Will print trace regardless of 'exit-status' param
# fn_tag dnEndScriptStderr option s purpose Number of function calls to skip in trace output
# fn_tag dnEndScriptStderr option s required no
# fn_tag dnEndScriptStderr option s multiple no
# fn_tag dnEndScriptStderr option s type integer
# fn_tag dnEndScriptStderr option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnEndScriptStderr option s note This option implies the 't' option
# fn_tag dnEndScriptStderr param exit-status purpose Indicates whether exiting successfully or not
# fn_tag dnEndScriptStderr param exit-status required yes
# fn_tag dnEndScriptStderr param exit-status multipart no
# fn_tag dnEndScriptStderr param exit-status type string
# fn_tag dnEndScriptStderr param exit-status value 0
# fn_tag dnEndScriptStderr param exit-status value -
# fn_tag dnEndScriptStderr param exit-status value 1
# fn_tag dnEndScriptStderr param exit-status note '0' = exiting sucessfully and display success message
# fn_tag dnEndScriptStderr param exit-status note '-' = exiting successfully but suppress success message
# fn_tag dnEndScriptStderr param exit-status note * (any other value) = exiting unsuccessfully and display failure message
# fn_tag dnEndScriptStderr param message purpose Exit message
# fn_tag dnEndScriptStderr param message required no
# fn_tag dnEndScriptStderr param message multipart yes
# fn_tag dnEndScriptStderr param message type string
dnEndScriptStderr() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# variables
	local exit_status
	exit_status=${1:-'-'}
	shift
	# print messages
	case ${exit_status} in
	'0')
		[ ${#} -gt 0 ] && dnInfoStderr "${@}"
		dnInfoStderr "${dn_self} succeeded"
		;;
	'-') ;; # no feedback
	*)
		[ ${#} -gt 0 ] && dnErrorStderr "${@}"
		dnErrorStderr "${dn_self} failed"
		;;
	esac
	# • print stack trace if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfoStderr 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfoStderr "  ${i}"
			done
		)
	fi
	dnInfoStderr "...${dn_self} is finished"
	# exit
	[ "${exit_status}" = '-' ] && exit_status=0
	exit "${exit_status}"
}
# Function: dnEquals    {{{1
# Case-insensitive comparison of two values
#   params: 1 - string
#           2 - string
#   prints: nil
#   return: boolean (0=equal|1=not equal)
# fn_tag dnEquals purpose Returns whether two strings are (case-insensitive) equal
# fn_tag dnEquals prints NIL
# fn_tag dnEquals returns Whether string comparison successful (Boolean)
# fn_tag dnEquals param first-string purpose First string to be compared
# fn_tag dnEquals param first-string required yes
# fn_tag dnEquals param first-string multipart no
# fn_tag dnEquals param first-string type string
# fn_tag dnEquals param second-string purpose Second string to be compared
# fn_tag dnEquals param second-string required yes
# fn_tag dnEquals param second-string multipart no
# fn_tag dnEquals param second-string type string
dnEquals() {
	[ "$(dnLowercase "${1:-}")" = "$(dnLowercase "${2:-}")" ]
	return ${?}
}
# Function: dnEraseText    {{{1
# Erase text by backspacing
#   params: 1 - text of equal length to erasure
#   prints: nil
#   return: nil
# fn_tag dnEraseText purpose Erase text by backspacing
# fn_tag dnEraseText prints NIL
# fn_tag dnEraseText returns NIL
# fn_tag dnEraseText param erase-text purpose Text of same length as erasure
# fn_tag dnEraseText param erase-text required yes
# fn_tag dnEraseText param erase-text multipart no
# fn_tag dnEraseText param erase-text type string
# fn_tag dnEraseText param erase-text note Need not be same text as that being erased
dnEraseText() {
	local i length
	i='' length=$(dnStrLen "${1:-}")
	for ((i = 0; i < length; i++)); do echo -ne "\b \b"; done
}
# Function: dnError    {{{1
# Print error message to stdout
#   params: 1+ - message part(s)
#   prints: formatted message
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnError purpose Print informational message to standard output
# fn_tag dnError prints Formatted message
# fn_tag dnError returns NIL
# fn_tag dnError param part purpose Message part
# fn_tag dnError param part required yes
# fn_tag dnError param part multipart yes
# fn_tag dnError param part type string
dnError() { dnMessage 'Error' 1 "${@}"; }
# Function: dnErrorDlg    {{{1
# Display error dialog message
#   params: 1 - message
#           2 - title (optional)
#   prints: nil
#   return: nil
# fn_tag dnErrorDlg purpose Display error message in dialog
# fn_tag dnErrorDlg prints NIL
# fn_tag dnErrorDlg returns NIL
# fn_tag dnErrorDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnErrorDlg note If variable dn_app_icon_all_dialogs true then also use for warn|error dlgs
# fn_tag dnErrorDlg param message purpose Dialog message
# fn_tag dnErrorDlg param message required yes
# fn_tag dnErrorDlg param message multipart no
# fn_tag dnErrorDlg param message type string
# fn_tag dnErrorDlg param title purpose Dialog title
# fn_tag dnErrorDlg param title required no
# fn_tag dnErrorDlg param title multipart no
# fn_tag dnErrorDlg param title type string
# fn_tag dnErrorDlg param title note Empty title is converted by subsidiary function to script name
dnErrorDlg() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	dnDlg 'error' "${2:-}" "${1}"
}
# Function: dnErrorStderr    {{{1
# Print error message to stderr
#   params: 1+ - message part(s)
#   prints: formatted message
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnErrorStderr purpose Print error message to standard error
# fn_tag dnErrorStderr prints Formatted message
# fn_tag dnErrorStderr returns NIL
# fn_tag dnErrorStderr param part purpose Message part
# fn_tag dnErrorStderr param part required yes
# fn_tag dnErrorStderr param part multipart yes
# fn_tag dnErrorStderr param part type string
dnErrorStderr() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	dnMessageStderr 'Error' 1 "${@}"
}
# Function: dnEscapeChar    {{{1
# Escape character in string
#   params: 1 - string
#           2 - character to escape (optional, default=' ')
#           3 - number of escape characters per space (optional, default=1)
#           4 - escape character (optional, default='\')
#   prints: altered string
#   return: nil
# fn_tag dnEscapeChar purpose Escape character in string
# fn_tag dnEscapeChar prints Altered string
# fn_tag dnEscapeChar returns NIL
# fn_tag dnEscapeChar usage escaped_spaces="$( dnEscapeChar "${input}" )"
# fn_tag dnEscapeChar param string purpose String in which character is to be escaped
# fn_tag dnEscapeChar param string required yes
# fn_tag dnEscapeChar param string multipart no
# fn_tag dnEscapeChar param string type string
# fn_tag dnEscapeChar param char purpose Character to escape
# fn_tag dnEscapeChar param char required no
# fn_tag dnEscapeChar param char multipart no
# fn_tag dnEscapeChar param char type string
# fn_tag dnEscapeChar param char default SPACE
# fn_tag dnEscapeChar param number purpose Number of escape characters to precede each space
# fn_tag dnEscapeChar param number required no
# fn_tag dnEscapeChar param number multipart no
# fn_tag dnEscapeChar param number type integer
# fn_tag dnEscapeChar param number default 1
# fn_tag dnEscapeChar param escape purpose Escape character to use for each space
# fn_tag dnEscapeChar param escape required no
# fn_tag dnEscapeChar param escape multipart no
# fn_tag dnEscapeChar param escape type string
# fn_tag dnEscapeChar param escape default \
dnEscapeChar() {
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string char number escape escape_sequence
	string="${1}" char="${2:-' '}" number="${3:-'1'}"
	escape="${4:-"\\\\"}" escape_sequence=''
	char="$(cut -c 1 <<<"${char}")" # first char only
	while [ "${number}" -gt 0 ]; do # get desired number of escapes
		escape_sequence="${escape_sequence}${escape}"
		((number--)) || true
	done
	# insert escapes
	string="${string//${char}/${escape_sequence}${char}}"
	# print value
	echo "${string}"
}
# Function: dnExtractExtension    {{{1
# Extract extension from path
#   params: 1 - filepath
#   prints: extension
#   return: nil
# fn_tag dnExtractExtension purpose Extract extension from filepath
# fn_tag dnExtractExtension prints Extension
# fn_tag dnExtractExtension returns NIL
# fn_tag dnExtractExtension param filepath purpose Filepath to analyse
# fn_tag dnExtractExtension param filepath required yes
# fn_tag dnExtractExtension param filepath multipart no
# fn_tag dnExtractExtension param filepath type string
dnExtractExtension() {
	echo "${1##*.}"
}
# Function: dnExtractFileBase    {{{1
# Extract file basename (without extension) from path
#   params: 1 - filepath
#   prints: basename
#   return: nil
# fn_tag dnExtractFileBase purpose Extract file basename from filepath
# fn_tag dnExtractFileBase prints Basename
# fn_tag dnExtractFileBase returns NIL
# fn_tag dnExtractFileBase note Basename is filename without extension
# fn_tag dnExtractFileBase param filename purpose Filepath to be analysed
# fn_tag dnExtractFileBase param filename required yes
# fn_tag dnExtractFileBase param filename multipart no
# fn_tag dnExtractFileBase param filename type path
dnExtractFileBase() {
	# strip directory
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	local base
	base="$(basename "${1}")"
	# strip extension
	base="${base%.*}"
	# print result
	echo "${base}"
}
# Function: dnExtractFilename    {{{1
# Extract filename from path
#   params: 1 - filepath
#   prints: filename
#   return: nil
# fn_tag dnExtractFilename purpose Extract filename from filepath
# fn_tag dnExtractFilename prints Filename
# fn_tag dnExtractFilename returns NIL
# fn_tag dnExtractFilename param filepath purpose Filepath to be analysed
# fn_tag dnExtractFilename param filepath required yes
# fn_tag dnExtractFilename param filepath multipart no
# fn_tag dnExtractFilename param filepath type path
dnExtractFilename() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	awk -F '/' '{ print $NF }' <<<"${1}"
}
# Function: dnExtractHttpHost    {{{1
# Extract host from http url
# e.g., from 'https://svn.sourceforge.net/svnroot/refdb/refdb/trunk'
# extract 'svn.sourceforge.net'
#   params: 1 - full http url
#   prints: host
#   return: nil
# fn_tag dnExtractHttpHost purpose Extract server name from http url
# fn_tag dnExtractHttpHost prints Host server
# fn_tag dnExtractHttpHost returns NIL
# fn_tag dnExtractHttpHost note Example: from 'https://my.server.com/docs/sales.html' will extract 'my.server.com'
# fn_tag dnExtractHttpHost param url purpose Full url to parse
# fn_tag dnExtractHttpHost param url required yes
# fn_tag dnExtractHttpHost param url multipart no
# fn_tag dnExtractHttpHost param url type string
dnExtractHttpHost() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No url provided"
	local url server
	url="${1}" server=''
	# strip leading protocol, e.g., 'http://; or 'https://'
	# • stripping 'http[s]://' requires extended pattern matching ('extglob')
	[[ "$(shopt extglob || true)" == 'extglob        	on' ]] && extglob_was_set=0 || extglob_was_set=1
	shopt -s extglob
	server="${url/#?(http|https):\/\//}"
	{ { { ((extglob_was_set == 0)); } && shopt -s extglob; } || shopt -u extglob; }
	# strip all trailing subdirectories
	server="$(awk -F '/' '{ print $1 }' <<<"${server}")"
	# return result
	echo "${server}"
}
# Function: dnExtractPath    {{{1
# Extract path from filepath
#   params: 1 - filepath
#   prints: directory path
#   return: boolean (0=extracted path|1=file only)
# fn_tag dnExtractPath purpose Extract directory path from file path
# fn_tag dnExtractPath prints Directory path (empty string if only file name)
# fn_tag dnExtractPath returns Whether string contains directory part, i.e., not just file name (Boolean)
# fn_tag dnExtractPath param filepath purpose Filepath to analyse
# fn_tag dnExtractPath param filepath required yes
# fn_tag dnExtractPath param filepath multipart no
# fn_tag dnExtractPath param filepath type path
dnExtractPath() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	if [[ $1 =~ \/ ]]; then
		dirname "${1}"
		return 0
	else
		echo ""
		return 1
	fi
}
# Function: dnFailDlg    {{{1
#   params: 1  - title (if ''|'-' than use script name)
#           2+ - message(s) (if last part == '0' then run dialog detached)
#   prints: nil (displays dialog)
#   return: nil
# fn_tag dnFailDlg purpose Exit with failure notice
# fn_tag dnFailDlg prints NIL
# fn_tag dnFailDlg returns Boolean fail
# fn_tag dnFailDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnFailDlg note If variable dn_app_icon_all_dialogs true then also use for warn|error dlgs
# fn_tag dnFailDlg param title purpose Dialog title
# fn_tag dnFailDlg param title required yes
# fn_tag dnFailDlg param title multipart no
# fn_tag dnFailDlg param title type string
# fn_tag dnFailDlg param title note If ''|'-' use script name
# fn_tag dnFailDlg param part purpose Message part
# fn_tag dnFailDlg param part required no
# fn_tag dnFailDlg param part multipart yes
# fn_tag dnFailDlg param part type string
# fn_tag dnFailDlg param part default Script failed.[CR]Aborting.
dnFailDlg() {
	local title msg
	title="${1:-"${dn_self}"}" msg=''
	[[ "${title}" = '-' ]] && title="${dn_self}"
	shift
	# set message
	[ ${#} -eq 0 ] && msg="Script failed.\nAborting."
	while [ ${#} -ne 0 ]; do
		[ -n "${msg+x}" ] && msg="${msg}\n"
		msg="${msg}${1}"
		shift
	done
	# display dialog
	dnErrorDlg "${msg}" "${title}"
	# exit
	exit ${dn_false}
}
# Function: dnFailScript    {{{1
# Script fails before user interaction begins
#   option: t  - print stack trace (optional)
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1+ - message
#   prints: feedback
#   return: nil
# fn_tag dnFailScript purpose Exit script with feedback
# fn_tag dnFailScript prints Error messages
# fn_tag dnFailScript returns Failure value (Boolean)
# fn_tag dnFailScript note Designed to be used instead of 'dnEndScript'
# fn_tag dnFailScript note Designed for exiting script before user feedback given
# fn_tag dnFailScript note Prints any error messages passed to it (or default message)
# fn_tag dnFailScript note Then prints a brief help message
# fn_tag dnFailScript option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnFailScript option t required no
# fn_tag dnFailScript option t multiple no
# fn_tag dnFailScript option t type none
# fn_tag dnFailScript option s purpose Number of function calls to skip in trace output
# fn_tag dnFailScript option s required no
# fn_tag dnFailScript option s multiple no
# fn_tag dnFailScript option s type integer
# fn_tag dnFailScript option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnFailScript option s note This option implies the 't' option
# fn_tag dnFailScript param message purpose Error messages to be displayed before exiting
# fn_tag dnFailScript param message required no
# fn_tag dnFailScript param message multipart yes
# fn_tag dnFailScript param message type string
# fn_tag dnFailScript param message default Aborting script
dnFailScript() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# set variables
	local -a msg=()
	msg+=("${@:-'Aborting script'}")
	# display messages
	dnFatal "${msg[*]}."
	dnInfo "Try '${dn_self} -h'."
	# • print stack trace if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfo 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfo "  ${i}"
			done
		)
	fi
	# exit script
	exit 1
}
# Function: dnFailScriptDlg    {{{1
# Script fails before user interaction begins
#   option: t  - print stack trace to stdout (optional)
#              - stack trace is not included in dialog output
#   option: s  - number of functions to skip (optional)
#              - passed to dnStackTrace (see that function for default value)
#   params: 1+ - message
#   prints: feedback
#   return: nil
# fn_tag dnFailScriptDlg purpose Exit script with feedback
# fn_tag dnFailScriptDlg prints Error messages
# fn_tag dnFailScriptDlg returns Failure value (Boolean)
# fn_tag dnFailScriptDlg note Designed to be used instead of 'dnEndScriptDlg'
# fn_tag dnFailScriptDlg note Designed for exiting script before user feedback given
# fn_tag dnFailScriptDlg note Similar to 'dnFailScript' but also displays error and help messages in dialog
# fn_tag dnFailScriptDlg option t purpose Causes stack trace to be printed by 'dnStackTrace'
# fn_tag dnFailScriptDlg option t required no
# fn_tag dnFailScriptDlg option t multiple no
# fn_tag dnFailScriptDlg option t type none
# fn_tag dnFailScriptDlg option s purpose Number of function calls to skip in trace output
# fn_tag dnFailScriptDlg option s required no
# fn_tag dnFailScriptDlg option s multiple no
# fn_tag dnFailScriptDlg option s type integer
# fn_tag dnFailScriptDlg option s note Value is passed to dnStackTrace using its 's' option -- see it for option information
# fn_tag dnFailScriptDlg option s note This option implies the 't' option
# fn_tag dnFailScriptDlg param message-line purpose One line of exit message
# fn_tag dnFailScriptDlg param message-line required no
# fn_tag dnFailScriptDlg param message-line multipart yes
# fn_tag dnFailScriptDlg param message-line type string
# fn_tag dnFailScriptDlg param message-line default Aborting script
dnFailScriptDlg() {
	# process options
	local skip do_trace
	skip='' do_trace=${dn_false}
	while getopts ':ts:' opt; do
		case ${opt} in
		't') do_trace=${dn_true} ;;
		's') if dnValidPosInteger "${OPTARG}"; then
			skip="${OPTARG}"
			do_trace=${dn_true}
		fi ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# set and check variables
	local msg_try
	msg_try="Try '${dn_self} -h'"
	local -a msg_par=("${@}")
	[ ${#msg_par[*]} -gt 0 ] || msg_par=('Aborting script')
	local msg_dlg i msg
	msg_dlg='' i='' msg=''
	# get compound message for dialog
	for ((i = 0; i < ${#msg_par[*]}; i++)); do
		if [ -z "${msg_dlg}" ]; then
			msg_dlg="${msg_par[i]}."
		else
			msg_dlg="${msg_dlg}\n${msg_par[i]}."
		fi
	done
	msg_dlg="${msg_dlg}\n${msg_try}."
	# display messages in dialog and terminal
	dnErrorDlg "${msg_dlg}"
	dnInfo "${msg_par[*]}" "${msg_try}"
	# • print stack trace (to stdout only) if requested
	if dnFlagTrue ${do_trace}; then
		if [ -n "${skip+x}" ]; then
			trace="$(dnStackTrace -s "${skip}")"
		else
			trace="$(dnStackTrace)"
		fi
		dnInfo 'Stack trace:'
		# use subshell to quarantine change to IFS
		(
			IFS=$'\n'
			for i in ${trace}; do
				dnInfo "  ${i}"
			done
		)
	fi
	# exit script
	exit 1
}
# Function: dnFatal    {{{1
# Print fatal error message to stdout
#   params: 1+ - message part(s)
#   prints: formatted message
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnFatal purpose Print fatal error message to standard output
# fn_tag dnFatal prints Formatted message
# fn_tag dnFatal returns NIL
# fn_tag dnFatal param part purpose Message part
# fn_tag dnFatal param part required yes
# fn_tag dnFatal param part multipart yes
# fn_tag dnFatal param part type string
dnFatal() { dnMessage 'Fatal error' 1 "${@}"; }
# Function: dnFatalStderr    {{{1
# Print fatal error message to stderr
#   params: 1+ - message part(s)
#   prints: formatted message
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnFatalStderr purpose Print fatal error message to standard error
# fn_tag dnFatalStderr prints Formatted message
# fn_tag dnFatalStderr returns NIL
# fn_tag dnFatalStderr param part purpose Message part
# fn_tag dnFatalStderr param part required yes
# fn_tag dnFatalStderr param part multipart yes
# fn_tag dnFatalStderr param part type string
dnFatalStderr() { dnMessageStderr 'Fatal error' 1 "${@}"; }
# Function: dnFileEmpty    {{{1
# Tests whether file empty (assume file exists)
#   params: 1 - file
#   prints: nil
#   return: 0|1 (empty|not empty)
# fn_tag dnFileEmpty purpose Determine whether file is empty
# fn_tag dnFileEmpty prints NIL
# fn_tag dnFileEmpty returns Whether file is empty (Boolean)
# fn_tag dnFileEmpty note Function assumes file exists
# fn_tag dnFileEmpty param filepath purpose File to be analysed
# fn_tag dnFileEmpty param filepath required yes
# fn_tag dnFileEmpty param filepath multipart no
# fn_tag dnFileEmpty param filepath type path
dnFileEmpty() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No file provided"
	# must cat file to 'wc' to avoid filename in 'wc' output
	[ "$(wc --bytes <"${1}")" -eq 0 ]
	return ${?}
}
# Function: dnFileSize    {{{1
# Return file size (bytes)
#   params: 1 - filepath [required]
#           2 - modify feedback (e|p|t|g|m|k|b|h) [optional]
#                               (default=b)
#   prints: size
#   return: boolean (0=success|1=failure)
#   note:   feedback modiers either:
#           a) specify numeric result in particular units (e|p|t|g|m|k|b)
#              (= exa-, peta-, tera-, giga-, mega-, kilobytes, bytes)
#                              or
#           b) or in human-readable format (h)
#   needs:  apps [du]
#           functions [dnNormalisePath]
# fn_tag dnFileSize purpose Determine file size in bytes
# fn_tag dnFileSize prints File size
# fn_tag dnFileSize returns Whether able to determine file size (Boolean)
# fn_tag dnFileSize note Requires utility 'du'
# fn_tag dnFileSize param filepath purpose File to be analysed
# fn_tag dnFileSize param filepath required yes
# fn_tag dnFileSize param filepath multipart no
# fn_tag dnFileSize param filepath type path
# fn_tag dnFileSize param units purpose Units of size (in bytes)
# fn_tag dnFileSize param units required no
# fn_tag dnFileSize param units multipart no
# fn_tag dnFileSize param units type string
# fn_tag dnFileSize param units value e
# fn_tag dnFileSize param units value p
# fn_tag dnFileSize param units value t
# fn_tag dnFileSize param units value g
# fn_tag dnFileSize param units value m
# fn_tag dnFileSize param units value k
# fn_tag dnFileSize param units value b
# fn_tag dnFileSize param units value h
# fn_tag dnFileSize param units default b
# fn_tag dnFileSize param units note e=exabyte, p=petabyte, t=terabyte, g=gigabyte, m=megabyte, k=kilobyte, b=byte, h=human-readable
dnFileSize() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local size unit units human_readable retval du file
	size='' unit='' units='b' human_readable=1 retval=1 du='' file=''
	file="$(dnNormalisePath "${1}")"
	local modifier du_mods hr_mods du_base
	modifier="${2:-'b'}" du_mods='EPTGMK1' hr_mods='EPTGMKB'
	du_base='du --total --human-readable --dereference --apparent-size'
	du_base="${du_base} --block-size="
	modifier="${modifier^^}" # convert to uppercase
	case ${modifier} in
	'E' | 'P' | 'T' | 'G' | 'M' | 'K') units="${modifier}" ;;
	'B') units='1' ;;
	'H') human_readable=0 ;;
	*) dnFatal "${FUNCNAME[0]}: Case mismatch" && exit 1 ;;
	esac
	dnFileValid "${file}" || exit 1
	# first, deal with request for human-readable file size
	if dnFlagTrue "${human_readable}"; then
		for unit in E P T G M K 1; do
			du="${du_base}${unit}"
			size="$(${du} "${file}" | grep total |
				tr -d '[:space:]' | tr -d '[:alpha:]')"
			retval=${PIPESTATUS[0]}
			if [ "${size}" -gt 1 ]; then # if < 1 returns 1
				size="${size}$(tr "${du_mods}" "${hr_mods}" <<<"${server}")"
				break
			fi
		done
	else # here deal with request for integer result of nominated size
		du="${du_base}${units}"
		size="$(${du} "${file}" | grep total |
			tr -d '[:space:]' | tr -d '[:alpha:]')"
		retval=${PIPESTATUS[0]}
	fi
	# return result and exit status
	echo "${size}"
	return "${retval}"
}
# Function: dnFileValid    {{{1
# File exists and readable
#   params: 1 - file
#   prints: nil
#   return: boolean (0=exists, 1=does not exist)
#   invoke: if dnFileValid "${filename}" ; then ...
# fn_tag dnFileValid purpose Determine whether file exists and is readable
# fn_tag dnFileValid prints NIL
# fn_tag dnFileValid returns Whether file exists and is readable (Boolean)
# fn_tag dnFileValid usage if dnFileValid "${filename}" ; then ...
# fn_tag dnFileValid param filepath purpose Filepath to be analysed
# fn_tag dnFileValid param filepath required yes
# fn_tag dnFileValid param filepath multipart no
# fn_tag dnFileValid param filepath type path
dnFileValid() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	[ -f "${1}" ] && [ -r "${1}" ]
	return ${?}
}
# Function: dnFileValidNoSpaces    {{{1
# File exists and readable and filepath contains no spaces
#   params: 1 - file
#   prints: nil
#   return: boolean (0=exists, 1=does not exist)
#   invoke: if dnFileValidNoSpaces "${filename}" ; then ...
#   needs:  functions [dnNoSpace]
# fn_tag dnFileValidNoSpaces purpose Determine whether file exists, is readable and contains no spaces
# fn_tag dnFileValidNoSpaces prints NIL
# fn_tag dnFileValidNoSpaces returns Whether file exists, is readable and contains no spaces (Boolean)
# fn_tag dnFileValidNoSpaces usage if dnFileValidNoSpaces "${filename}" ; then ...
# fn_tag dnFileValidNoSpaces param filepath purpose Filepath to be analysed
# fn_tag dnFileValidNoSpaces param filepath required yes
# fn_tag dnFileValidNoSpaces param filepath multipart no
# fn_tag dnFileValidNoSpaces param filepath type path
dnFileValidNoSpaces() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	[[ -f "${1}" && -r "${1}" ]] && dnNoSpace "${1}"
	return ${?}
}
# Function: dnFilesAvailable    {{{1
# Checks for all needed files
#   params: list of files
#   prints: message listing missing files
#   return: 0|1 (files all present|files NOT all present)
#   invoke: dnFilesAvailable "${file_list}" || dnEndScript
# fn_tag dnFilesAvailable purpose Checks list of files to determine whether all are available
# fn_tag dnFilesAvailable prints Message listing missing file(s)
# fn_tag dnFilesAvailable returns Whether all files are available (Boolean)
# fn_tag dnFilesAvailable usage dnFilesAvailable "${files_list}" || dnEndScript
# fn_tag dnFilesAvailable param file purpose Name of file to check
# fn_tag dnFilesAvailable param file required yes
# fn_tag dnFilesAvailable param file multipart yes
# fn_tag dnFilesAvailable param file type string
dnFilesAvailable() {
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No file list provided"
	local file retval
	file='' retval=0
	# check for files
	for file in ${1}; do
		if [ -f "${file}" ]; then
			retval=1
			echo "Warning: missing file '${file}'"
		fi
	done
	# return exit status
	return ${retval}
}
# Function: dnFilesystemMounted    {{{1
# Determines whether a filesystem is mounted
#   params: 1 - block special device or remote filesystem
#   return: boolean (0=mounted, 1=not mounted)
#   invoke: if dnFilesystemMounted "${fs}" ; then...
# fn_tag dnFilesystemMounted purpose Determine whether a block special device or remote filesystem is mounted
# fn_tag dnFilesystemMounted prints NIL
# fn_tag dnFilesystemMounted returns Whether mounted (0=mounted,1=not mounted,2=error (multiple mtab matches))
# fn_tag dnFilesystemMounted usage if dnFilesystemMounted "${fs}" ; then...
# fn_tag dnFilesystemMounted param device-filesystem purpose Block special device or remote filesystem to be analysed
# fn_tag dnFilesystemMounted param device-filesystem required yes
# fn_tag dnFilesystemMounted param device-filesystem multipart no
# fn_tag dnFilesystemMounted param device-filesystem type path
dnFilesystemMounted() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local mtab test_filesystem
	mtab='/etc/mtab'
	test_filesystem="$(dnRemoveEndSlash "${1}")"
	local -a mounted_filesystems=()
	mapfile -t mounted_filesystems < <(cut -d ' ' -f 1 <"${mtab}")
	for mounted_filesystem in "${mounted_filesystems[@]}"; do
		[ "${test_filesystem}" = "${mounted_filesystem}" ] && return 0
	done
	return 1
}
# Function: dnFlagTrue    {{{1
# Check if flag variable equal to zero
#   params: 1 - flag variable
#   prints: nil
#   return: boolean (0=flag true|1=flag false)
# fn_tag dnFlagTrue purpose Check if flag value is true (equal to zero)
# fn_tag dnFlagTrue prints NIL
# fn_tag dnFlagTrue returns Whether flag is true (Boolean)
# fn_tag dnFlagTrue param flag purpose Value to be tested
# fn_tag dnFlagTrue param flag required yes
# fn_tag dnFlagTrue param flag multipart no
# fn_tag dnFlagTrue param flag type integer
dnFlagTrue() {
	[ ${#} -gt 0 ] || return 1 # empty flag variable is false
	return "${1}"
}
# Function: dnFontFormat    {{{1
# Get ANSI escape sequences to set terminal font colour and effects.
# Any string constructed using these escape sequences must be echoed to the
# console with the '-e' option to enable escapes.
# The order of font effects is signficant. Any font effects followed by the
# font effect 'reset' will have no effect. Any font effect occurring before
# its 'off' complement will be negated.
#   params: 1 - font effects [optional, can be comma-delimited list of
#               {"", bold,bold_off,uline,uline_off,blink,blink_off,reverse,
#                reverse_off,conceal,conceal_off,bright_fg,bright_bg,reset}]
#           2 - foreground colour [optional, can be
#               {"", black,red,green,yellow,blue,magenta,cyan,white}]
#           3 - background colour [optional, can be
#               {"", black,red,green,yellow,blue,magenta,cyan,white}]
#   prints: ANSI escape sequence
#   return: boolean
# fn_tag dnFontFormat purpose Print font-related ANSI escape sequences
# fn_tag dnFontFormat prints String containing selected ANSI escape sequences
# fn_tag dnFontFormat returns NIL
# fn_tag dnFontFormat usage string="$(dnFontFormat 'reset,bold' 'red')Red text!$(dnFontFormat 'reset')"
# fn_tag dnFontFormat usage echo -e "$string"
# fn_tag dnFontFormat note Must echo string with '-e' option to enable escape sequences
# fn_tag dnFontFormat note The order of font effects is significant
# fn_tag dnFontFormat note The font effect 'reset' negates all previous font effects
# fn_tag dnFontFormat note An '_off' font effect negates any previous instance of its complement effect
# fn_tag dnFontFormat param string-A purpose Font effects
# fn_tag dnFontFormat param string-A required yes
# fn_tag dnFontFormat param string-A multipart no
# fn_tag dnFontFormat param string-A type string
# fn_tag dnFontFormat param string-A note can be empty string
# fn_tag dnFontFormat param string-A note can be comma-delimited list of {bold,bold_off,uline,uline_off,blink,blink_off,reverse,reverse_off,conceal,conceal_off,bright_fg,bright_bg,reset}
# fn_tag dnFontFormat param string-B purpose Foreground colour
# fn_tag dnFontFormat param string-B required no
# fn_tag dnFontFormat param string-B multipart no
# fn_tag dnFontFormat param string-B type string
# fn_tag dnFontFormat param string-B default empty string
# fn_tag dnFontFormat param string-B note can be empty string
# fn_tag dnFontFormat param string-B note can be one of {black,red,green,yellow,blue,magenta,cyan,white}
# fn_tag dnFontFormat param string-C purpose Background colour
# fn_tag dnFontFormat param string-C required no
# fn_tag dnFontFormat param string-C multipart no
# fn_tag dnFontFormat param string-C type string
# fn_tag dnFontFormat param string-C default empty string
# fn_tag dnFontFormat param string-C note can be empty string
# fn_tag dnFontFormat param string-C note can be one of {black,red,green,yellow,blue,magenta,cyan,white}
dnFontFormat() {
	# font effects
	local -A font_effect=(
		[bold]=1 [bold_off]=22
		[uline]=4 [uline_off]=24
		[blink]=5 [blink_off]=25
		[reverse]=7 [reverse_off]=27
		[conceal]=8 [conceal_off]=28
		[bright_fg]='_' [bright_bg]='_'
		[reset]=0
	)
	# font colours
	local -A font_colour=(
		[black]=30
		[red]=31
		[green]=32
		[yellow]=33
		[blue]=34
		[magenta]=35
		[cyan]=36
		[white]=37
	)
	local bg_addition bright_addition
	bg_addition=10 bright_addition=60
	# process arguments
	# • fg
	local fg_arg fg
	fg_arg="${2:-}" fg=''
	if [[ -n "${fg_arg+x}" ]]; then
		if [[ -v font_colour["${fg_arg}"] ]]; then
			fg="${font_colour["${fg_arg}"]}"
		else
			echo "Invalid foreground colour ('${fg_arg}') provided to ${FUNCNAME[0]}" 1>&2
		fi
	fi
	# • bg
	local bg_arg bg
	bg_arg="${3:-}" bg=''
	if [[ -n "${bg_arg+x}" ]]; then
		if [[ -v font_colour["${bg_arg}"] ]]; then
			bg="${font_colour["${bg_arg}"]}"
			((bg += bg_addition)) || true
		else
			echo "Invalid background colour ('${bg_arg}') provided to ${FUNCNAME[0]}" 1>&2
		fi
	fi
	# • effects
	local effects_arg
	effects_arg="${1:-}"
	IFS=',' read -r -a effects <<<"${effects_arg}"
	local -a numeric_codes=()
	for effect in "${effects[@]}"; do
		case ${effect} in
		bold | bold_off | uline | uline_off | blink | blink_off | reverse | reverse_off | conceal | conceal_off | reset)
			numeric_codes+=("${font_effect["${effect}"]}")
			;;
		bright_fg) { [[ -n "${fg+x}" ]] && ((fg += bright_addition)); } || true ;;
		bright_bg) { [[ -n "${bg+x}" ]] && ((bg += bright_addition)); } || true ;;
		*) echo "Invalid font effect ('${effect}') passed to ${FUNCNAME[0]}" 1>&2 ;;
		esac
	done
	# get font code string
	local font_codes first_loop
	font_codes="\\\\033[" first_loop=true
	for numeric_code in "${numeric_codes[@]}"; do
		if [[ "${first_loop}" = true ]]; then
			font_codes+="${numeric_code}"
			first_loop=false
		else
			font_codes+=";${numeric_code}"
		fi
	done
	[[ -n "${fg+x}" ]] && font_codes+=";${fg}"
	[[ -n "${bg+x}" ]] && font_codes+=";${bg}"
	font_codes+='m'
	echo -e "${font_codes}"
}
# Function: dnFormatList    {{{1
# Format list of valid options for display
#   params: 1 - list of options (space-delimited)
#   prints: formatted list (e.g. "one two" -' "'one'|'two'")
#   return: nil
# fn_tag dnFormatList purpose Format list for display
# fn_tag dnFormatList prints Formatted list
# fn_tag dnFormatList returns NIL
# fn_tag dnFormatList note Encapsulates each element in single quotes and separates elements with vertical bars
# fn_tag dnFormatList note Requires list to be space-delimited
# fn_tag dnFormatList note Example: "one two" -> "'one'|'two'"
# fn_tag dnFormatList param list purpose List of elements
# fn_tag dnFormatList param list required yes
# fn_tag dnFormatList param list multipart no
# fn_tag dnFormatList param list type string
# fn_tag dnFormatList param list note Must be space-delimited
dnFormatList() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local output
	output="${1}"
	# add inter-option formatting
	output="${output// /\'|\'}"
	# add initial and terminal quotes and print output for capture
	echo "'${output}'"
}
# Function: dnFormatSvnRepDetails    {{{1
# Format svn repository details, e.g., to give
# 'module-x: trunk (revision 99)' or
# "module-x: branch 'refdb-0.9.7-pre6' (revision 66)"
#   params: 1 - url
#           2 - revision
#           3 - module
#           4 - type ('trunk'|'branches'|'tag')
#           5 - name (for branch and tag types only)
#   prints: formatted details
#   return: nil
#   note:   accepts params in same order as output by 'dnAnalyseRepository'
#   use:    rep_detail=( $( dnAnalyseRepository "$( pwd )" ) )
#           display_details="$( dnFormatSvnRepDetails "${rep_details[@]}" )"
# fn_tag dnFormatSvnRepDetails purpose Format svn repository details
# fn_tag dnFormatSvnRepDetails prints Formatted svn repository details (String)
# fn_tag dnFormatSvnRepDetails returns NIL
# fn_tag dnFormatSvnRepDetails example output = 'module-x: trunk (revision 99)'
# fn_tag dnFormatSvnRepDetails example output = "module-x: branch 'refdb-0.9.7-pre6' (revision 66)"
# fn_tag dnFormatSvnRepDetails note Input parameters are same as output paramters from function 'dnAnalyseSvnRepository'
# fn_tag dnFormatSvnRepDetails param url purpose Repository url
# fn_tag dnFormatSvnRepDetails param url required yes
# fn_tag dnFormatSvnRepDetails param url multipart no
# fn_tag dnFormatSvnRepDetails param url type string
# fn_tag dnFormatSvnRepDetails param url note Not actually used but used as parameter to ensure compatibility with output of function 'dnAnalyseSvnRepository'
# fn_tag dnFormatSvnRepDetails param revision purpose Repository revision
# fn_tag dnFormatSvnRepDetails param revision required yes
# fn_tag dnFormatSvnRepDetails param revision multipart no
# fn_tag dnFormatSvnRepDetails param revision type integer
# fn_tag dnFormatSvnRepDetails param module purpose Revision module
# fn_tag dnFormatSvnRepDetails param module required yes
# fn_tag dnFormatSvnRepDetails param module multipart no
# fn_tag dnFormatSvnRepDetails param module type string
# fn_tag dnFormatSvnRepDetails param type purpose Revision type
# fn_tag dnFormatSvnRepDetails param type required yes
# fn_tag dnFormatSvnRepDetails param type multipart no
# fn_tag dnFormatSvnRepDetails param type type string
# fn_tag dnFormatSvnRepDetails param type value trunk
# fn_tag dnFormatSvnRepDetails param type value branches
# fn_tag dnFormatSvnRepDetails param type value tag
# fn_tag dnFormatSvnRepDetails param type note While not mandatory, these are the customary top-level directories in an svn repository
# fn_tag dnFormatSvnRepDetails param name purpose Revision name (for branch and tag types only)
# fn_tag dnFormatSvnRepDetails param name required no
# fn_tag dnFormatSvnRepDetails param name multipart no
# fn_tag dnFormatSvnRepDetails param name type string
dnFormatSvnRepDetails() {
	[ -n "${4+x}" ] || dnAbort "${FUNCNAME[0]}: No type provided"
	[ -n "${3+x}" ] || dnAbort "${FUNCNAME[0]}: No module provided"
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No revision provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No url provided"
	local url rev module type name msg errmsg
	url="${1}" rev="${2}" module="${3}" type="${4}" name="${5:-}"
	errmsg="Fatal error 10 in function '${FUNCNAME[0]}', script '${0}'"
	case "${type}" in
	'trunk') msg="${msg} ${module}: trunk" ;;
	'branch' | 'tag') msg="${msg} ${module}: ${type} '${name}'" ;;
	*) dnEndScript 1 "${errmsg}" ;;
	esac
	msg="${msg} (revision ${rev})"
	echo "${msg}"
}
# Function: dnFormatTime    {{{1
# Format time (from seconds)
#   params: 1 - time (in seconds)
#           2 - format code (optional) (default=':')
#   prints: string - formatted time ('hh:mm:ss')
#   return: nil
#   notes:  format code -- a = alpha ('5h 12m 3s')
#                          : = colons ('05:12:03 ')
# fn_tag dnFormatTime purpose Convert count in seconds to formatted time
# fn_tag dnFormatTime prints Formatted time string
# fn_tag dnFormatTime returns NIL
# fn_tag dnFormatTime param time purpose Time in seconds
# fn_tag dnFormatTime param time required yes
# fn_tag dnFormatTime param time multipart no
# fn_tag dnFormatTime param time type integer
# fn_tag dnFormatTime param format-code purpose How to format time string
# fn_tag dnFormatTime param format-code required no
# fn_tag dnFormatTime param format-code multipart no
# fn_tag dnFormatTime param format-code type string
# fn_tag dnFormatTime param format-code value a
# fn_tag dnFormatTime param format-code value :
# fn_tag dnFormatTime param format-code default :
# fn_tag dnFormatTime param format-code note 'a' = alpha (example is '5h 12m 3s')
# fn_tag dnFormatTime param format-code note ':' = colons (example is '05:12:03')
dnFormatTime() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local s format h m
	s="${1}" format="${2:-':'}"
	# get hours
	h="$((s / 3600))"
	s="$((s - h * 3600))"
	# get minutes
	m="$((s / 60))"
	s="$((s - m * 60))"
	# two-digit times
	local hh mm ss
	hh="${h}" mm="${m}" ss="${s}"
	if [[ "${hh}" =~ ^[0-9]$ ]]; then
		hh="0${hh}"
	fi
	if [[ "${mm}" =~ ^[0-9]$ ]]; then
		mm="0${mm}"
	fi
	if [[ "${ss}" =~ ^[0-9]$ ]]; then
		ss="0${ss}"
	fi
	# format time
	local retval
	retval=''
	case ${format} in
	'a')
		[ ${h} -gt 0 ] && retval="${h}h "
		[ ${m} -gt 0 ] && retval="${retval}${m}m "
		[ ${s} -gt 0 ] && retval="${retval}${s}s"
		;;
	*) # also ':' since that is default
		[ "${hh}" -gt 0 ] && retval="${retval}${hh}:"
		[ "${mm}" -gt 0 ] && retval="${retval}${mm}:"
		retval="${retval}${ss}"
		;;
	esac
	echo "${retval}"
}
# Function: dnFunctionsAvailable    {{{1
# Checks for all needed functions
#   params: list of functions
#   prints: message listing missing functions
#   return: 0|1 (functions all present|functions NOT all present)
#   invoke: dnFunctionsAvailable "${function_list}" || dnEndScript
# fn_tag dnFunctionsAvailable purpose Checks list of functions to determine whether all are available
# fn_tag dnFunctionsAvailable prints Message listing missing function(s)
# fn_tag dnFunctionsAvailable returns Whether all functions are available (Boolean)
# fn_tag dnFunctionsAvailable usage dnFunctionsAvailable "${functions_list}" || dnEndScript
# fn_tag dnFunctionsAvailable param function purpose Name of function to check
# fn_tag dnFunctionsAvailable param function required yes
# fn_tag dnFunctionsAvailable param function multipart yes
# fn_tag dnFunctionsAvailable param function type string
dnFunctionsAvailable() {
	# sanity checks
	# shellcheck disable=SC2154
	# • 'dn_commonbash_fns is referenced but not assigned'
	# • variable is provided by libvariables
	if [ -z "${dn_commonbash_fns+x}" ]; then
		echo "Error: variable 'dn_commonbash_fns' is not set"
		echo 'Warning: is libdncommon-bash fully installed and loaded?'
		return 1
	fi
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local function retval found_function dn_commonbash_fn
	function='' retval=0 found_function=1 dn_commonbash_fn=''
	local -a functions=()
	IFS=' ' read -r -a functions <<<"${1}"
	# check for functions
	for function in "${functions[@]}"; do
		found_function=1
		for dn_commonbash_fn in "${dn_commonbash_fns[@]}"; do
			if [ "${function}" = "${dn_commonbash_fn}" ]; then
				found_function=0
				break
			fi
		done
		if [ ${found_function} -ne 0 ]; then
			retval=1
			echo "Warning: missing function '${function}'" 1>&2
		fi
	done
	# return exit status
	return ${retval}
}
# Function: dnGetDir    {{{1
# Select dir from dialog
#   params: 1 - select prompt (''|'-' = default to 'Select Directory')
#           2 - initial directory (''|'-' = default to cwd)
#   prints: filepath
#   return: nil
#   invoke: dir="$( dnGetDir "${prompt}" "${start_dir}" )"
#     note: selects only an existing directory
#     note: when this function is called as part of a command substitution,
#           for example:
#             dir="$(dnGetDir "${prompt}" "${start_dir}")"
#           any attempt to display help text in a dialog msgbox, such as:
#             dialog --title "$title" --clear --erase-on-exit --msgbox "${dlg_help}" 0 0
#           fails: the command executes successfully (since you have to dismiss
#           it to proceed), but it does not display, so the workaround used
#           in this function is to echo the help text to stderr
# fn_tag dnGetDir purpose Select directory using a dialog
# fn_tag dnGetDir prints Directory path
# fn_tag dnGetDir returns NIL
# fn_tag dnGetDir usage filename="$( dnGetFilepath "${title}" "${start_dir}" )"
# fn_tag dnGetDir note Can select only existing directories
# fn_tag dnGetDir param prompt purpose User prompt
# fn_tag dnGetDir param prompt required no
# fn_tag dnGetDir param prompt multipart no
# fn_tag dnGetDir param prompt type string
# fn_tag dnGetDir param prompt note If not provided, or is an empty string or '-', defaults to 'Select directory'
# fn_tag dnGetDir param initial_dir purpose Initial directory
# fn_tag dnGetDir param initial_dir required no
# fn_tag dnGetDir param initial_dir multipart no
# fn_tag dnGetDir param initial_dir type path
# fn_tag dnGetDir param initial_dir note If not provided, or is an empty string or '-', defaults to current directory
dnGetDir() {
	# set and check variables
	[ ${#} -gt 2 ] &&
		dnEndScriptDlg 1 "${FUNCNAME[0]}: expected 0-2 params, got ${#}"
	# • set defaults
	local default_prompt default_start_dir
	default_prompt='Select directory' default_start_dir="$(pwd)"
	# • cue (prompt): use default if ''|'-'
	local cue
	cue="${1:-${default_prompt}}"
	[ -z "${cue}" ] || [ "${cue}" = '-' ] && cue="${default_prompt}"
	# • initial directory
	local start_dir
	start_dir="${2:-${default_start_dir}}"
	[ -z "${start_dir}" ] || [ "${start_dir}" = '-' ] && start_dir="${default_start_dir}"
	start_dir="$(dnNormalisePath "${start_dir}")"
	if ! [ -d "${start_dir}" ]; then
		dnErrorStderr 'Invalid start directory:' "  '${start_dir}'" \
			'Using current directory:' "  '${default_start_dir}'"
		start_dir="${default_start_dir}"
	fi
	dnHasEndSlash "${start_dir}" || start_dir+='/'
	# • dialog command
	local dlg_type dlg_cmd
	dlg_type="$(dnDialogType -c "gui" -c "dir")"
	dlg_cmd="${dn_dlg_cmds_dir_select[$dlg_type]}"
	dlg_cmd="${dlg_cmd/<C>/${cue}}"
	dlg_cmd="${dlg_cmd/<P>/${start_dir}}"
	# execute dialog command
	local dir
	dir=''
	# • 'dialog' gets special treatment because:
	#   - its exit status needs to be captured
	#   - it has a help screen that can be displayed
	if [ "${dlg_type}" = 'dialog' ]; then
		local exit_status dlg_help term_width fmt_width
		exit_status='' dlg_help="${dn_dlg_text_help_dir_select}"
		term_width='' fmt_width=''
		term_width=$(tput cols)
		fmt_width=$((term_width - 2))
		shopt -s inherit_errexit
		[[ "$(shopt -o errexit || true)" == 'errexit        	on' ]] && errexit_was_set=0 || errexit_was_set=1
		shopt -o -u errexit
		while true; do
			dir="$(eval "${dlg_cmd}")"
			exit_status="${?}"
			((exit_status != 2)) && break
			echo -e "$(fmt --width=$fmt_width <<<"${dlg_help}")" 1>&2
			echo "" 1>&2
			dnPromptStderr
		done
		{ { { ((errexit_was_set == 0)); } && shopt -o -s errexit; } || shopt -o -u errexit; }
	else
		dir="$(eval "${dlg_cmd}")"
	fi
	[ -n "${dir+x}" ] && dir="$(realpath "${dir}")"
	echo "${dir}"
}
# Function: dnGetFilepath    {{{1
# Select file from dialog
#   params: 1 - dialog title (''|'-' = default to 'Select File')
#           2 - initial directory (''|'-' = default to cwd)
#           3 - filter [optional] (''|'-' = not used)
#   prints: filepath
#   return: nil
#   invoke: filename="$( dnGetFilepath "${title}" "${start_dir}" )"
#     note: file filter - uses same specifiers used with ls|dir commands
#                       - must be enclosed in quotes if includes wildcards
#                       - examples: '*.xpm', "lib*", '*.[1-9]'
#                       - only works with some dialogs, e.g., with kdialog
#                         but not dialog
#     note: selects only an existing file
#     note: when this function is called as part of a command substitution,
#           for example:
#             fp="$(tmpGetFilePath "${prompt}" "${start_dir}")"
#           any attempt to display help text in a dialog msgbox, such as:
#             dialog --title "$title" --clear --erase-on-exit --msgbox "${dlg_help}" 0 0
#           fails: the command executes successfully (since you have to dismiss
#           it to proceed), but it does not display, so the workaround used
#           in this function is to echo the help text to stderr
# fn_tag dnGetFilePath purpose Select file using a dialog
# fn_tag dnGetFilePath prints Filepath
# fn_tag dnGetFilePath returns NIL
# fn_tag dnGetFilePath note Can only select existing file
# fn_tag dnGetFilePath usage filename="$( dnGetFilepath "${title}" "${start_dir}" )"
# fn_tag dnGetFilePath param title purpose Dialog title
# fn_tag dnGetFilePath param title required yes
# fn_tag dnGetFilePath param title multipart no
# fn_tag dnGetFilePath param title type string
# fn_tag dnGetFilePath param title note If ''|'-' defaults to 'Select File'
# fn_tag dnGetFilePath param initial_dir purpose Initial directory
# fn_tag dnGetFilePath param initial_dir required yes
# fn_tag dnGetFilePath param initial_dir multipart no
# fn_tag dnGetFilePath param initial_dir type path
# fn_tag dnGetFilePath param initial_dir note If ''|'-' defaults to current directory
# fn_tag dnGetFilePath param filter purpose Specifies which files will be displayed in the dialog
# fn_tag dnGetFilePath param filter required no
# fn_tag dnGetFilePath param filter multipart no
# fn_tag dnGetFilePath param filter type string
# fn_tag dnGetFilePath param filter note Uses same specifiers as 'ls' and 'dir' commands
# fn_tag dnGetFilePath param filter note If filter includes wildcard must enclose in quotes, e.g., '*.1'
# fn_tag dnGetFilePath param filter note Only works with some dialogs, e.g., works with kdialog but not dialog
dnGetFilePath() {
	# set and check variables
	[ ${#} -gt 3 ] &&
		dnEndScriptDlg 1 "${FUNCNAME[0]}: expected 0-3 params, got ${#}"
	# • set defaults
	local default_prompt default_filter default_start_dir
	default_prompt='Select file' default_filter='*' default_start_dir="$(pwd)"
	# • cue (prompt)
	local cue
	cue="${1:-${default_prompt}}"
	[ -z "${cue}" ] || [ "${cue}" = '-' ] && cue="${default_prompt}"
	# • initial directory
	local start_dir
	start_dir="${2:-${default_start_dir}}"
	[ -z "${start_dir}" ] || [ "${start_dir}" = '-' ] && start_dir="${default_start_dir}"
	local start_dir
	start_dir="$(dnNormalisePath "${start_dir}")"
	if ! [ -d "${start_dir}" ]; then
		dnErrorStderr 'Invalid start directory:' "  '${start_dir}'" \
			'Using current directory:' "  '${default_start_dir}'"
		start_dir="${default_start_dir}"
	fi
	dnHasEndSlash "${start_dir}" || start_dir+='/'
	# • filter
	local filter
	filter="${1:-${default_filter}}"
	# • dialog command
	local dlg_type dlg_cmd
	dlg_type="$(dnDialogType -c "gui" -c "dir")"
	dlg_cmd="${dn_dlg_cmds_file_select[$dlg_type]}"
	dlg_cmd="${dlg_cmd/<C>/${cue}}"
	dlg_cmd="${dlg_cmd/<P>/${start_dir}}"
	dlg_cmd="${dlg_cmd/<F>/${filter}}"
	# execute dialog command
	local file
	file=''
	# • 'dialog' gets special treatment because:
	#   - its exit status needs to be captured
	#   - it has help text that can be displayed
	if [ "${dlg_type}" = 'dialog' ]; then
		local exit_status dlg_help term_width fmt_width
		exit_status='' dlg_help="${dn_dlg_text_help_file_select}"
		term_width='' fmt_width=''
		term_width=$(tput cols)
		fmt_width=$((term_width - 2))
		shopt -s inherit_errexit
		[[ "$(shopt -o errexit || true)" == 'errexit        	on' ]] && errexit_was_set=0 || errexit_was_set=1
		shopt -o -u errexit
		while true; do
			dir="$(eval "${dlg_cmd}")"
			exit_status="${?}"
			((exit_status != 2)) && break
			echo -e "$(fmt --width=$fmt_width <<<"${dlg_help}")" 1>&2
			echo "" 1>&2
			dnPromptStderr
		done
		{ { { ((errexit_was_set == 0)); } && shopt -o -s errexit; } || shopt -o -u errexit; }
	else
		dir="$(eval "${dlg_cmd}")"
	fi
	[ -n "${dir+x}" ] && dir="$(realpath "${dir}")"
	echo "${dir}"
}
# Function: dnGetFirstFile    {{{1
# Get first file from directory
#   params: 1 - directory
#           2 - extension [optional] (filters search)
#   prints: first file from directory
#   return: boolean (0=success|1=failure)
# fn_tag dnGetFirstFile purpose Get first file from a directory
# fn_tag dnGetFirstFile prints Filename
# fn_tag dnGetFirstFile returns NIL
# fn_tag dnGetFirstFile note Prints filename without path
# fn_tag dnGetFirstFile param directory purpose Directory to analyse
# fn_tag dnGetFirstFile param directory required yes
# fn_tag dnGetFirstFile param directory multipart no
# fn_tag dnGetFirstFile param directory type path
# fn_tag dnGetFirstFile param extension purpose Extension used to filter files displayed for selection
# fn_tag dnGetFirstFile param extension required no
# fn_tag dnGetFirstFile param extension multipart no
# fn_tag dnGetFirstFile param extension type string
# fn_tag dnGetFirstFile param extension note Do not prepend with period
dnGetFirstFile() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No dirpath provided"
	local retval dir ext file dir_cmd
	retval=0 dir="${1}" ext="${2:-}" file='' dir_cmd='dir -1'
	# assemble directory command
	[ -n "${ext+x}" ] && dir_cmd="${dir_cmd} *.${ext}"
	# get filename
	dir="$(dnNormalisePath "${dir}")" &>/dev/null || retval=1
	cd "${dir}" &>/dev/null || retval=1
	file="$(${dir_cmd} | head --lines=1)" || retval=1
	# print filename and indicate success
	echo "${file}"
	return ${retval}
}
# Function: dnGetInput    {{{1
# User enters input
#   params: -p - prompt text (optional, default='Enter input: ')
#           -d - default input (optional)
#   prints: entered text
#   return: nil
# fn_tag dnGetInput purpose Get user input
# fn_tag dnGetInput prints User input
# fn_tag dnGetInput returns NIL
# fn_tag dnGetInput usage input="$( dnGetInput )"
# fn_tag dnGetInput usage station="$( dnGetInput -p "Enter station: " -d "Central" )"
# fn_tag dnGetInput usage dob="$( dnGetInput -p "Enter date of birth: " )"
# fn_tag dnGetInput option p purpose User prompt
# fn_tag dnGetInput option p required no
# fn_tag dnGetInput option p multiple no
# fn_tag dnGetInput option p type string
# fn_tag dnGetInput option p default Enter input:
# fn_tag dnGetInput option d purpose Default input value
# fn_tag dnGetInput option d required no
# fn_tag dnGetInput option d multiple no
# fn_tag dnGetInput option d type string
dnGetInput() {
	# set variables
	local prompt default
	prompt='' default=''
	# process options
	while getopts ':p:d:' opt; do
		case ${opt} in
		'p') prompt="${OPTARG}" ;;
		'd') default="${OPTARG}" ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	[ -n "${prompt+x}" ] || prompt='Enter input: '
	# get user input
	read -r -e -i "${default}" -p "${prompt}" input
	# return user input
	echo "${input}"
}

# Function: dnGetPosInteger    {{{1
# User enters number
#   params: 1 - prompt text (optional, default='Enter integer: ')
#   prints: entered number
#   return: boolean (0=success|1=error)
# fn_tag dnGetPosInteger purpose User enter positive integer
# fn_tag dnGetPosInteger prints Number entered by user
# fn_tag dnGetPosInteger returns Whether number entered by user (Boolean)
# fn_tag dnGetPosInteger param prompt purpose User prompt
# fn_tag dnGetPosInteger param prompt required no
# fn_tag dnGetPosInteger param prompt multipart no
# fn_tag dnGetPosInteger param prompt type string
# fn_tag dnGetPosInteger param prompt default Enter integer:
dnGetPosInteger() {
	local prompt retval
	prompt="${1:-"${dn_query_prefix}Enter integer: "}" retval=''
	# get input
	until [ -n "${retval+x}" ] && dnValidNonZeroPosInt "${retval}"; do
		read -r -p "${prompt}" retval
	done
	echo "${retval}"
}
# Function: dnGlobValid    {{{1
# Glob matches at least one file/directory
#   params: 1 - file glob
#   prints: nil
#   return: boolean (0=matches, 1=no matches)
#   invoke: if dnGlobValid "${Globname}" ; then ...
# fn_tag dnGlobValid purpose Determine whether there are any matches for glob
# fn_tag dnGlobValid prints NIL
# fn_tag dnGlobValid returns Whether matches exist for glob (Boolean)
# fn_tag dnGlobValid usage if dnGlobValid "${Globname}" ; then ...
# fn_tag dnGlobValid param Globpath purpose glob to be analysed
# fn_tag dnGlobValid param Globpath required yes
# fn_tag dnGlobValid param Globpath multipart no
# fn_tag dnGlobValid param Globpath type path
dnGlobValid() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No glob provided"
	return "$(dnToggleFlag "$(dir "${1}" 2>/dev/null | wc -l)")"
}
# Function: dnHasEndSlash    {{{1
# Whether string has a terminal slash ('/')
#   params: 1 - string
#   prints: nil
#   return: boolean (0=does, does not)
# fn_tag dnHasEndSlash purpose Determine whether string has a terminal (forward) slash
# fn_tag dnHasEndSlash prints NIL
# fn_tag dnHasEndSlash returns Whether string has terminal slash (Boolean)
# fn_tag dnHasEndSlash param string purpose String to test
# fn_tag dnHasEndSlash param string required yes
# fn_tag dnHasEndSlash param string multipart no
# fn_tag dnHasEndSlash param string type string
dnHasEndSlash() {
	[[ $1 =~ \/$ ]]
	return ${?}
}
# Function: dnHighlightHotkey    {{{1
# Colour hotkey in string
#   params: 1 - string
#           2 - hotkey
#           3 - colour (optional) [default=red]
#   prints: altered string
#   return: boolean [ 0 = able to highlight hotkey | 1 = unable to do so ]
# fn_tag dnHighlightHotkey purpose Highlight hotkey in string with different colour
# fn_tag dnHighlightHotkey prints Altered string
# fn_tag dnHighlightHotkey returns Whether hotkey was highlighted
# fn_tag dnHighlightHotkey note Colours are derived from 'fg_*' colours supplied by libdncommon-bash library
# fn_tag dnHighlightHotkey param string purpose String containing hotkey
# fn_tag dnHighlightHotkey param string required yes
# fn_tag dnHighlightHotkey param string multipart no
# fn_tag dnHighlightHotkey param string type string
# fn_tag dnHighlightHotkey param hotkey purpose The character to highlight as hotkey
# fn_tag dnHighlightHotkey param hotkey required yes
# fn_tag dnHighlightHotkey param hotkey multipart no
# fn_tag dnHighlightHotkey param hotkey type string
# fn_tag dnHighlightHotkey param hotkey note Must be single character contained in string
# fn_tag dnHighlightHotkey param hotkey note If hotkey character occurs twice in string, only first occurrence is highlighted
# fn_tag dnHighlightHotkey param colour purpose Colour to highlight hotkey with
# fn_tag dnHighlightHotkey param colour required no
# fn_tag dnHighlightHotkey param colour multipart no
# fn_tag dnHighlightHotkey param colour type string
# fn_tag dnHighlightHotkey param colour default red
# fn_tag dnHighlightHotkey param colour note Must be one of {black,red,green,yellow,blue,magenta,cyan,white}
dnHighlightHotkey() {
	# set variables
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No hotkey provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string hotkey colour
	string="${1}" hotkey="$(dnLowercase "${2}")" colour="${3:-"red"}"
	local i len new_string char done_hotkey
	i='' new_string='' char='' done_hotkey=1 len=$(dnStrLen "${string}")
	# cycle through string and add formatting to hotkey
	for ((i = 0; i < len; i++)); do
		char="${string:${i}:1}"
		if [ "$(dnLowercase "${char}")" = "${hotkey}" ] &&
			[ ${done_hotkey} -ne 0 ]; then
			new_string="${new_string}$(dnFontFormat "" "red")${char}$(dnFontFormat "reset")"
			done_hotkey=0
		else
			new_string="${new_string}${char}"
		fi
	done
	# done
	echo "${new_string}"
	return ${done_hotkey} # succeeded if formatted hotkey
}
# Function: dnIncrement    {{{1
# Increment number
#   params: 1 - number to increment
#           2 - value of increment (optional, default=1)
#   prints: incremented value
#   return: boolean (0=success|1=error)
# fn_tag dnIncrement purpose Increment number
# fn_tag dnIncrement prints Incremented number
# fn_tag dnIncrement returns Whether value was successfully incremented (Boolean)
# fn_tag dnIncrement param number purpose Number to be incremented
# fn_tag dnIncrement param number required yes
# fn_tag dnIncrement param number multipart no
# fn_tag dnIncrement param number type number
# fn_tag dnIncrement param increment purpose Size of increment
# fn_tag dnIncrement param increment required yes
# fn_tag dnIncrement param increment multipart no
# fn_tag dnIncrement param increment type integer
# fn_tag dnIncrement param increment default 1
dnIncrement() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local val increment
	val="${1}" increment="${2:-1}"
	dnValidNumber "${val}" &>/dev/null || return 1
	echo "$((val + increment))"
}
# Function: dnInfo    {{{1
# Print informational message to stdout with trailing newline
#   params: 1+ - message part(s)
#   prints: formatted message to stdout
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnInfo purpose Print informational message to standard output with trailing newline
# fn_tag dnInfo prints Formatted message
# fn_tag dnInfo returns NIL
# fn_tag dnInfo param part purpose Message part
# fn_tag dnInfo param part required yes
# fn_tag dnInfo param part multipart yes
# fn_tag dnInfo param part type string
dnInfo() { dnMessage 'Info' 1 "${@}"; }
# Function: dnInfoDlg    {{{1
# Display info dialog message
#   params: 1 - message
#           2 - title (optional)
#   prints: nil
#   return: nil
# fn_tag dnInfoDlg purpose Display informational message in dialog
# fn_tag dnInfoDlg prints NIL
# fn_tag dnInfoDlg returns NIL
# fn_tag dnInfoDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnInfoDlg param message purpose Dialog message
# fn_tag dnInfoDlg param message required yes
# fn_tag dnInfoDlg param message multipart no
# fn_tag dnInfoDlg param message type string
# fn_tag dnInfoDlg param title purpose Dialog title
# fn_tag dnInfoDlg param title required no
# fn_tag dnInfoDlg param title multipart no
# fn_tag dnInfoDlg param title type string
# fn_tag dnInfoDlg param title note Empty title is converted by subsidiary function to script name
dnInfoDlg() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	dnDlg 'info' "${2:-}" "${1}"
}
# Function: dnInfoStderr    {{{1
# Print informational message to stderr with trailing newline
#   params: 1+ - message part(s)
#   prints: formatted message to stderr with trailing newline
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnInfoStderr purpose Print informational message to standard error with trailing newline
# fn_tag dnInfoStderr prints Formatted message
# fn_tag dnInfoStderr returns NIL
# fn_tag dnInfoStderr param part purpose Message part
# fn_tag dnInfoStderr param part required yes
# fn_tag dnInfoStderr param part multipart yes
# fn_tag dnInfoStderr param part type string
dnInfoStderr() { dnMessageStderr 'Info' 1 "${@}"; }
# Function: dnInfon    {{{1
# Print informational message to stdout without trailing newline
#   params: 1+ - message part(s)
#   prints: formatted message to stdout without trailing newline
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnInfon purpose Print informational message to standard output without trailing newline
# fn_tag dnInfon prints Formatted message
# fn_tag dnInfon returns NIL
# fn_tag dnInfon param part purpose Message part
# fn_tag dnInfon param part required yes
# fn_tag dnInfon param part multipart yes
# fn_tag dnInfon param part type string
# fn_tag dnInfon param part note No terminal newline is printed
dnInfon() { dnMessage 'Info' 0 "${@}"; }
# Function: dnInfonStderr    {{{1
# Print informational message to stderr without trailing newline
#   params: 1+ - message part(s)
#   prints: formatted message to stderr without trailing newline
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnInfonStderr purpose Print informational message to standard error
# fn_tag dnInfonStderr prints Formatted message
# fn_tag dnInfonStderr returns NIL
# fn_tag dnInfonStderr param part purpose Message part
# fn_tag dnInfonStderr param part required yes
# fn_tag dnInfonStderr param part multipart yes
# fn_tag dnInfonStderr param part type string
dnInfonStderr() { dnMessageStderr 'Info' 0 "${@}"; }
# Function: dnInitialCap    {{{1
# Converts first byte of string to uppercase
#   params: 1 - string
#   prints: string
#   return: nil
# Note: subsequent characters are not changed
# Note: does not check that first byte is alphabetic character
# fn_tag dnInitialCap purpose Convert first byte of string to upper case
# fn_tag dnInitialCap prints Edited string
# fn_tag dnInitialCap returns NIL
# fn_tag dnInitialCap note Does not check that first byte is an alphabetical character
# fn_tag dnInitialCap note Second and subsequent characters are not altered
# fn_tag dnInitialCap note Requires bash version >= 5.1 for 'u' parameter operator
# fn_tag dnInitialCap param string purpose String to be converted
# fn_tag dnInitialCap param string required yes
# fn_tag dnInitialCap param string multipart no
# fn_tag dnInitialCap param string type string
dnInitialCap() {
	echo "${1@u}"
}
# Function: dnIsCvsTree    {{{1
# Is this source tree a CVS tree?
#   params: 1 - (optional) dirpath [default = cwd]
#   prints: nil
#   return: boolean (0|*)
#   note:   check for 'Root' file in CVS subdir to determine if CVS tree
#   needs:  functions [dnNormalisePath]
# fn_tag dnIsCvsTree purpose Determine whether source tree is a CVS tree (Boolean)
# fn_tag dnIsCvsTree prints NIL
# fn_tag dnIsCvsTree returns Whether source tree is a CVS tree
# fn_tag dnIsCvsTree note Assumes is CVS tree if finds 'Root' file in 'CVS' subdirectory
# fn_tag dnIsCvsTree param directory purpose Root directory of source tree
# fn_tag dnIsCvsTree param directory required no
# fn_tag dnIsCvsTree param directory multipart no
# fn_tag dnIsCvsTree param directory type path
# fn_tag dnIsCvsTree param directory note default to cwd if not supplied
dnIsCvsTree() {
	# set directory
	local dir
	dir="${1:-"$(pwd)"}"
	dir="$(dnNormalisePath "${dir}")"
	# check whether cvs tree
	return "$(dir "${dir}"/CVS/Root &>/dev/null)"
}
# Function: dnIsSvnTree    {{{1
# Is this source tree a subversion tree?
#   params: 1 - (optional) dirpath [default = cwd]
#   prints: nil
#   return: boolean (0|*)
#   note:   check for 'all-wcprops' file in '.svn' subdir
#   needs:  functions [dnNormalisePath]
# fn_tag dnIsSvnTree purpose Determine whether source tree is a subversion tree
# fn_tag dnIsSvnTree prints NIL
# fn_tag dnIsSvnTree returns Whether source tree is a subversion tree (Boolean)
# fn_tag dnIsSvnTree note Assumes is subversion tree if finds 'all-wcpropos' file in '.svn' subdirectory
# fn_tag dnIsSvnTree param directory purpose Root directory of source tree
# fn_tag dnIsSvnTree param directory required no
# fn_tag dnIsSvnTree param directory multipart no
# fn_tag dnIsSvnTree param directory type path
# fn_tag dnIsSvnTree param directory note default to cwd if not supplied
dnIsSvnTree() {
	# set directory
	local dir
	dir="${1:-"$(pwd)"}"
	dir="$(dnNormalisePath "${dir}")"
	# check whether subversion tree
	return "$(dir "${dir}"/.svn/all-wcprops &>/dev/null)"
}
# Function: dnKeepProgAlive    {{{1
# Restarts program if it stops
#   params: 1 - grep string [string]
#           2 - program filepath [string]
#   prints: nil
#   return: 0|1 (no errors detected|failed to execute correctly)
#   note:   never returns '0' because routine never exits normally
#           writes error message to log if routine fails
#           checks whether program is running every ten minutes
#           works best with programs that only run a single instance
#           if program runs multiple instances you may have difficulty
#             specifying a particular instance
# fn_tag dnKeepProgAlive purpose Endlessly restarts nominated program if it stops
# fn_tag dnKeepProgAlive prints NIL
# fn_tag dnKeepProgAlive returns Error if fails to run correctly (Boolean)
# fn_tag dnKeepProgAlive note This function is an endless loop and never exits normally
# fn_tag dnKeepProgAlive note Checks whether program is running every ten minutes
# fn_tag dnKeepProgAlive note Works best with programs that only run a single instance
# fn_tag dnKeepProgAlive note If program runs multiple instances you may have
# fn_tag dnKeepProgAlive note difficulty specifying a particular instance
# fn_tag dnKeepProgAlive param grep_string purpose String used by psgrep to check whether program is running
# fn_tag dnKeepProgAlive param grep_string required yes
# fn_tag dnKeepProgAlive param grep_string multipart no
# fn_tag dnKeepProgAlive param grep_string type string
# fn_tag dnKeepProgAlive param grep_string note Must be unique enough to match only desired program
# fn_tag dnKeepProgAlive param filepath purpose Filepath of program executable -- used to restart program
# fn_tag dnKeepProgAlive param filepath required yes
# fn_tag dnKeepProgAlive param filepath multipart no
# fn_tag dnKeepProgAlive param filepath type path
dnKeepProgAlive() {
	# check parameters
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No grep string provided"
	[ -x "${2}" ] || dnAbort "${FUNCNAME[0]}: Program '${2}' is not executable"
	[ ${#} -eq 2 ] || dnAbort "${FUNCNAME[0]}: Need 2 params, got ${#}"
	# assign variables
	local grep_string prog
	grep_string="${1}" prog="${2}"
	# set display for gui apps
	export DISPLAY=:0
	# do loop restarting prog if it has stopped
	while true; do
		[ ! $(pgrep "${grep_string}") ] && ${prog} >/dev/null 2>&1
		sleep 600
	done
}

# Function: dnKillPid    {{{1
# Kill process by pid
#   params: 1 - pid of process
#   prints: nil
#   return: boolean (0=success|1=failed)
# fn_tag dnKillPid purpose Kill process
# fn_tag dnKillPid prints NIL
# fn_tag dnKillPid returns Whether process killed successfully (Boolean)
# fn_tag dnKillPid note This is a hard kill using signal 9 and this can sometimes mean the process does not shut down cleanly
# fn_tag dnKillPid param pid purpose ID of process to kill
# fn_tag dnKillPid param pid required yes
# fn_tag dnKillPid param pid multipart no
# fn_tag dnKillPid param pid type integer
dnKillPid() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No pid provided"
	kill -9 "${1}" &>/dev/null
	return ${?}
}
# Function: dnLastChar    {{{1
# Get last character from a string
#   params: 1 - string
#   prints: last char
#   return: nil
# fn_tag dnLastChar purpose Gets last character from a string
# fn_tag dnLastChar prints Last character in string
# fn_tag dnLastChar returns NIL
# fn_tag dnLastChar param string purpose String to be operated on
# fn_tag dnLastChar param string required yes
# fn_tag dnLastChar param string multipart no
# fn_tag dnLastChar param string type string
dnLastChar() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string strlen last_char_index last_char
	string="${1}"
	strlen=${#string}
	last_char_index=$((strlen - 1))
	last_char="${string:${last_char_index}:1}"
	echo "${last_char}"
}
# Function: dnLeftPad    {{{1
# Left pad a string
#   params: 1 - number of characters to pad
#           2 - string to left pad (optional, default = empty string)
#           3 - character to pad with (optional, default = space)
#   prints: padded string
#   return: nil
# fn_tag dnLeftPad purpose Left pad a string
# fn_tag dnLeftPad prints Padded string
# fn_tag dnLeftPad returns NIL
# fn_tag dnLeftPad param pad-length purpose Length that string is to be padded to (i.e., target string length)
# fn_tag dnLeftPad param pad-length required yes
# fn_tag dnLeftPad param pad-length multipart no
# fn_tag dnLeftPad param pad-length type integer
# fn_tag dnLeftPad param string purpose String to be padded
# fn_tag dnLeftPad param string required no
# fn_tag dnLeftPad param string multipart no
# fn_tag dnLeftPad param string type string
# fn_tag dnLeftPad param string default empty string
# fn_tag dnLeftPad param string note If string is longer than pad-length then supplied string printed unchanged
# fn_tag dnLeftPad param pad-character purpose Character to pad with
# fn_tag dnLeftPad param pad-character required no
# fn_tag dnLeftPad param pad-character multipart no
# fn_tag dnLeftPad param pad-character type string
# fn_tag dnLeftPad param pad-character default <Space>
dnLeftPad() {
	# check params
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No pad length provided"
	local target_len string char i pad_len str_len
	target_len=${1} string="${2:-''}" char="${3:-' '}" i='' pad_len='' str_len=''
	[ -z "${char}" ] && char=' '
	char="$(cut -c 1 <<<"${char}")"
	# determine how much to pad
	str_len=$(dnStrLen "${string}")
	pad_len=$((target_len - str_len))
	# pad
	for ((i = 0; i < pad_len; i++)); do
		string="${char}${string}"
	done
	# done
	echo "${string}"
}
# Function: dnListCount    {{{1
# The number of items in a list
#   params: 1 - list
#           2 - delimiter (default=SPC) [optional]
#   prints: count
#   return: nil
#   invoke: dnListCount "${foo[*]}" ' '
# fn_tag dnListCount purpose Count the number of elements in a list
# fn_tag dnListCount prints Element count
# fn_tag dnListCount returns NIL
# fn_tag dnListCount usage dnListCount "${foo[*]}" ' '
# fn_tag dnListCount param list purpose List whose elements are to be counted
# fn_tag dnListCount param list required yes
# fn_tag dnListCount param list multipart no
# fn_tag dnListCount param list type string
# fn_tag dnListCount param delimiter purpose List delimiter
# fn_tag dnListCount param delimiter required no
# fn_tag dnListCount param delimiter multipart no
# fn_tag dnListCount param delimiter type string
# fn_tag dnListCount param delimiter note Default = 'Space'
dnListCount() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No list string provided"
	local list delim
	list="${1}" delim="${2:-' '}"
	awk -F "${delim}" '{ print NF }' <<<"${list}"
	## another method that can be used with space-delimited lists
	#for item in ${list} ; do count=$(( ++count )) ; done
}
# Function: dnListDlg    {{{1
# Select options from checklist dialog
#   params: 1 - resource file
#   prints: selections -- options or indices, based on user preference
#                         (space-separated list, options quote-enclosed)
#   return: boolean (0=selection made|1=no selection made)
#           can also evaluate success on printed output
#           -- any output=success, empty string=failure
#   resource: file consists of name value pairs with whitespace delimiter
#             names are --
#               title:  menu title [optional] (default=script_name)
#               prompt: menu prompt [optional] (default='Select options: ')
#               return: 'option'|'index' [optional] (default='option')
#               option: menu option [required]
#                       =default_status[whitespace]option
#   warning: quote marks will be stripped from tags and options
#   note:    options can be captured to array thus:
#               declare -a opts
#               eval "opts=( $( dnListDlg "${tmp_file}" ) )"
#            if 'eval' not used all options collapsed into one array value
# fn_tag dnListDlg purpose Select multiple options from GUI list
# fn_tag dnListDlg prints User list selections -- option strings or indices depending on user preference (space-separated list, options are quote-enclosed)
# fn_tag dnListDlg returns Whether selections made (Boolean)
# fn_tag dnListDlg note Can capture options to array but must use 'eval'
# fn_tag dnListDlg note Using 'eval' prevents all options collapsing into one array value
# fn_tag dnListDlg usage declare -a opts
# fn_tag dnListDlg usage eval "opts=( $( dnListDlg "${tmp_file}" ) )"
# fn_tag dnListDlg purpose Select option from GUI list
# fn_tag dnListDlg prints User list selection -- option tag, string or index depending on user preference
# fn_tag dnListDlg returns Whether selection made (Boolean)
# fn_tag dnListDlg param resource purpose Resource file
# fn_tag dnListDlg param resource required yes
# fn_tag dnListDlg param resource multipart no
# fn_tag dnListDlg param resource type path
# fn_tag dnListDlg param resource note File consists of name-value pairs with whitespace delimiter
# fn_tag dnListDlg param resource note Name 'title' = menu title [optional] (default=script_name)
# fn_tag dnListDlg param resource note Name 'prompt' = menu prompt [optional] (default='Select option: ')
# fn_tag dnListDlg param resource note Name 'return' = 'option'|'index' [optional] (default='option')
# fn_tag dnListDlg param resource note Name 'option' = a menu option [required, multiple]
# fn_tag dnListDlg param resource note Name 'option' format =default_status[whitespace]option
# fn_tag dnListDlg param resource note Warning: quote marks will be stripped from options
dnListDlg() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local title prompt return_val valid_return_vals
	title="$(basename "$0")"
	prompt='Select options: '
	return_val='option'
	valid_return_vals='index option'
	local -a tags=() defaults=() options=() picks_array=()
	local resources msg
	resources="$(dnNormalisePath "${1}")"
	msg="${FUNCNAME[0]}: Invalid resource filename"
	[ -r "${resources}" ] || dnEndScript 1 "${msg}"
	local dlg_type i pick picks retval
	dlg_type='' i='' pick='' picks='' retval=''
	local menu_count menu_height menu_width
	menu_count=0 menu_height=0 menu_width=0
	local height_char_pixels width_char_pixels
	height_char_pixels=25 width_char_pixels=9 # char -> pixels
	local option_length option_length_max
	option_length='' option_length_max=0
	local name val tag default option
	name='' val='' tag='' default='' option=''
	msg="${FUNCNAME[0]}: Unable to create temporary file"
	local pick_file
	pick_file="$(dnTempFile)" || dnEndScript 1 "${msg}"
	local -a cmd=()
	# process resources file
	while read -r name val; do
		if [ -n "${val+x}" ]; then
			# option *may* have two values needing stripping
			[ "${name}" != 'option' ] &&
				val="$(dnStripEnclosingQuotes "${val}")"
			# load vars depending on name
			case ${name} in
			'title') title="${val}" ;;
			'prompt') prompt="${val}" ;;
			'return')
				dnElementInList "${val}" "${valid_return_vals}" &&
					return_val="${val}"
				;;
			'option')
				[[ $val =~ ^[[:space:]]*([^[:space:]]+)[[:space:]]+(.*)$ ]]
				default="${BASH_REMATCH[1]}"
				option="${BASH_REMATCH[2]}"
				# standardise default status
				default="$(dnStandardiseBoolean "${default}")"
				case ${default} in
				'0') default='true' ;;
				'1') default='false' ;;
				esac
				# internal possessive apostrophes can cause problems
				# add to arrays
				defaults+=("$(dnStripQuotes "${default}")")
				options+=("$(dnStripQuotes "${option}")")
				tags+=("${#tags[*]}")
				;;
			esac
		fi
	done <"${resources}"
	# get dialog type
	dlg_type="$(dnLowercase "$(dnDialogType)")" || dnEndScript 1 \
		"${FUNCNAME[0]}: Unable to locate dialog command" \
		'Perhaps this is a non-graphical environment?'
	# set menu dimensions
	for ((i = 0; i < ${#tags[*]}; i++)); do # get max option length
		option_length=$(dnStrLen "${options[i]}")
		[ "${option_length}" -gt "${option_length_max}" ] &&
			option_length_max=${option_length}
	done
	case ${dlg_type} in
	'kdialog')
		# menu dimensions in pixels
		menu_height=$(((${#tags[*]} + 5) * height_char_pixels))
		menu_width=$(((option_length_max + 5) * width_char_pixels))
		;;
	'dialog')
		# dialog uses sensible defaults so no changes necessary
		;;
	esac
	# build dialog command
	case ${dlg_type} in
	'kdialog')
		cmd=(
			kdialog
			--geometry "${menu_width}x${menu_height}"
			--title "${title}"
			--separate-output
			--checklist
			"${prompt}"
		)
		;;
	'zenity')
		cmd=(
			zenity
			"--title='${title}'"
			'--width=200'
			'--height=300'
			--list
			"--text='${prompt}'"
			'--hide-column=2'
			"--separator=' '"
			--checklist
			"--column='Picks'"
			"--column='Tags'"
			"--column='Options'"
		)
		;;
	'dialog')
		cmd=(
			dialog
			--stdout
			--title "${title}"
			--separate-output
			--checklist
			"${prompt}"
			"${menu_height}"
			"${menu_width}"
			"${menu_count}"
		)
		;;
	esac
	for ((i = 0; i < ${#tags[*]}; i++)); do
		case ${dlg_type} in
		'kdialog' | 'dialog')
			cmd+=("${tags[i]}" "${options[i]}" "${defaults[i]}")
			;;
		'zenity')
			cmd+=("${defaults[i]}" "${tags[i]}" "${options[i]}")
			;;
		esac
	done
	# make selection and capture output in temporary file
	"${cmd[@]}" 1>"${pick_file}"
	picks="$(cat "${pick_file}")"
	dnTempKill "${pick_file}"
	[ -n "${picks+x}" ] || return 1
	# process picks into array
	for pick in "${picks[@]}"; do
		picks_array+=("$(dnStripQuotes "${pick}")")
	done
	# decide upon, and return, return value
	# we have tags in variable 'picks_array'
	# finds first match (if duplicate tags)
	for ((i = 0; i < ${#tags[*]}; i++)); do
		if dnElementInList "${tags[i]}" "${picks_array[*]}"; then
			case ${return_val} in
			'option') retval="${retval} \"${options[i]}\"" ;;
			'index') retval="${retval} ${i}" ;;
			esac
		fi
	done
	retval="$(dnStripEnclosingSpaces "${retval}")"
	[ -n "${retval+x}" ] || return 1
	echo "${retval}"
}
# Function: dnListExtra    {{{1
# Determine which items in first list are not in second list
# [i.e., 'extra' in first list]
#   params: 1 - base list
#           2 - comparison list
#   prints: list of extra items in first list
#   return: nil
#   usage:  echo "Additional: '$( dnListExtra "${a1[*]}" "${a2[*]}" )'"
# fn_tag dnListExtra purpose compare two lists and determine which items in the first list are not in the second list
# fn_tag dnListExtra prints list of extra items
# fn_tag dnListExtra returns NIL
# fn_tag dnListExtra note determines which items are 'extra' in the first list
# fn_tag dnListExtra param base_list purpose list whose extra items will be determined
# fn_tag dnListExtra param base_list required yes
# fn_tag dnListExtra param base_list multipart no
# fn_tag dnListExtra param base_list type string
# fn_tag dnListExtra param comparison_list purpose list whose items will be compared to the base list
# fn_tag dnListExtra param comparison_list required yes
# fn_tag dnListExtra param comparison_list multipart no
# fn_tag dnListExtra param comparison_list type string
dnListExtra() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No comparison list provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No base list provided"
	dnListMissing "${2}" "${1}"
}

# Function: dnListMissing    {{{1
# Determine which items in second list are not in first list
# [i.e., 'missing' from first list]
#   params: 1 - base list
#           2 - comparison list
#   prints: list of items missing from first list
#   return: nil
#   usage:  echo "Missing '$( dnListMissing "${a1[*]}" "${a2[*]}" )'"
# fn_tag dnListMissing purpose compare two lists and determine which items in the second list are not in the first list
# fn_tag dnListMissing prints list of missing items
# fn_tag dnListMissing returns NIL
# fn_tag dnListMissing note determines which items are 'missing' from the first list
# fn_tag dnListMissing param base_list purpose list whose missing items will be determined
# fn_tag dnListMissing param base_list required yes
# fn_tag dnListMissing param base_list multipart no
# fn_tag dnListMissing param base_list type string
# fn_tag dnListMissing param comparison_list purpose list whose items will be compared to the base list
# fn_tag dnListMissing param comparison_list required yes
# fn_tag dnListMissing param comparison_list multipart no
# fn_tag dnListMissing param comparison_list type string
dnListMissing() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No comparison list provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No base list provided"
	local base_list test_list
	base_list="${1}" test_list="${2}"
	local result base_val test_val base_list_has_element
	result='' base_val='' test_val='' base_list_has_element=''
	for test_val in ${test_list}; do
		base_list_has_element='no'
		for base_val in ${base_list}; do
			[ "${test_val}" = "${base_val}" ] && base_list_has_element='yes'
		done
		if [ "${base_list_has_element}" = 'no' ]; then
			result="$(dnAddToList "${result}" "${test_val}")"
		fi
	done
	echo "${result}"
}
# Function: dnListSubset    {{{1
# Check whether one list contains another
#   params: 1 - master list (space-delimited)
#           2 - subset list (space-delimited)
#   prints: nil
#   return: boolean (0=subset|1=not a subset)
#   invoke: dnListSubset "${foo[*]}" "${elements[*]}"
# fn_tag dnListSubset purpose Check whether one list contains another
# fn_tag dnListSubset prints NIL
# fn_tag dnListSubset returns Whether second list is a subset of the first (Boolean)
# fn_tag dnListSubset usage dnListSubset "${foo[*]}" "${elements[*]}"
# fn_tag dnListSubset param master-list purpose List which may contain the other list
# fn_tag dnListSubset param master-list required yes
# fn_tag dnListSubset param master-list multipart no
# fn_tag dnListSubset param master-list type string
# fn_tag dnListSubset param master-list note Space-delimited
# fn_tag dnListSubset param subset-list purpose List which may be subset of master list
# fn_tag dnListSubset param subset-list required yes
# fn_tag dnListSubset param subset-list multipart no
# fn_tag dnListSubset param subset-list type string
# fn_tag dnListSubset param subset-list note Space-delimited
dnListSubset() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No subset list provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No master list provided"
	local -a list subset
	local retval found
	retval=0 found=''
	list="$(dnStripEnclosingSpaces "${1}")"
	subset="$(dnStripEnclosingSpaces "${2}")"
	for element in ${subset}; do
		found=1
		for item in ${list}; do
			[ "${element}" = "${item}" ] && found=0
		done
		dnFlagTrue "${found}" || retval=1
	done
	unset element list
	return ${retval}
}
# Function: dnListTagDlg    {{{1
# Select options from checklist dialog
#   params: 1 - resource file
#   prints: selections -- tags, options or indices, based on user preference
#                         (space-separated list)
#   return: boolean (0=selection made|1=no selection made)
#           can also evaluate success on printed output
#           -- any output=success, empty string=failure
#   resource: file consists of name value pairs with whitespace delimiter
#             names are --
#               title:  menu title [optional] (default=script_name)
#               prompt: menu prompt [optional] (default='Select options: ')
#               return: 'tag'|'index'|'option' [optional] (default='tag')
#               option: menu option [required]
#                       =tag[whitespace]default_status[whitespace]option
#   warning: quote marks will be stripped from tags and options
#   warning: tags must not contain whitespace
#   warning: tags must be unique or results may be unpredictable
#   note:    options can be captured to array thus:
#               declare -a opts
#               eval "opts=( $( dnListTagDlg "${tmp_file}" ) )"
#            if 'eval' not used all options collapsed into one array value
#   note:    if return value is options list each option is quote-enclosed
# fn_tag dnListTagDlg purpose Select multiple options from GUI list
# fn_tag dnListTagDlg prints User list selections -- option tags, strings or indices depending on user preference (space-separated list, options are quote-enclosed)
# fn_tag dnListTagDlg returns Whether selections made (Boolean)
# fn_tag dnListTagDlg note Can capture options to array but must use 'eval'
# fn_tag dnListTagDlg note Using 'eval' prevents all options collapsing into one array value
# fn_tag dnListTagDlg usage declare -a opts
# fn_tag dnListTagDlg usage eval "opts=( $( dnListTagDlg "${tmp_file}" ) )"
# fn_tag dnListTagDlg param resource purpose Resource file
# fn_tag dnListTagDlg param resource required yes
# fn_tag dnListTagDlg param resource multipart no
# fn_tag dnListTagDlg param resource type path
# fn_tag dnListTagDlg param resource note Warning: tags must not contain whitespace
# fn_tag dnListTagDlg param resource note Warning: tags must be unique or results may be unpredictable
# fn_tag dnListTagDlg param resource note File consists of name-value pairs with whitespace delimiter
# fn_tag dnListTagDlg param resource note Name 'title' = menu title [optional] (default=script_name)
# fn_tag dnListTagDlg param resource note Name 'prompt' = menu prompt [optional] (default='Select option: ')
# fn_tag dnListTagDlg param resource note Name 'return' = 'tag'|'option'|'index' [optional] (default='tag')
# fn_tag dnListTagDlg param resource note Name 'option' = a menu option [required, multiple]
# fn_tag dnListTagDlg param resource note Name 'option' format =tag[whitespace]default_status[whitespace]option
# fn_tag dnListTagDlg param resource note Warning: quote marks will be stripped from options
dnListTagDlg() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local title prompt return_val valid_return_vals
	title="$(basename "$0")"
	prompt='Select options: '
	return_val='tag'
	valid_return_vals='index tag option'
	local -a tags=() defaults=() options=() picks_array=()
	local resources msg
	resources="$(dnNormalisePath "${1}")"
	msg="${FUNCNAME[0]}: Invalid resource filename"
	[ -r "${resources}" ] || dnEndScript 1 "${msg}"
	local dlg_type i pick picks retval
	dlg_type='' i='' pick='' picks='' retval=''
	local menu_count menu_height menu_width
	menu_count=0 menu_height=0 menu_width=0
	local height_char_pixels width_char_pixels
	height_char_pixels=25 width_char_pixels=9 # char -> pixels
	local option_length option_length_max
	option_length='' option_length_max=0
	local name val tag default option pick_file
	name='' val='' tag='' default='' option='' pick_file=''
	msg="${FUNCNAME[0]}: Unable to create temporary file"
	pick_file="$(dnTempFile)" || dnEndScript 1 "${msg}"
	local -a cmd=()
	# process resources file
	while read -r name val; do
		if [ -n "${val+x}" ]; then
			# option *may* have two values needing stripping
			[ "${name}" != 'option' ] &&
				val="$(dnStripEnclosingQuotes "${val}")"
			# load vars depending on name
			case ${name} in
			'title') title="${val}" ;;
			'prompt') prompt="${val}" ;;
			'return')
				dnElementInList "${val}" "${valid_return_vals}" &&
					return_val="${val}"
				;;
			'option')
				local re
				re="^[[:space:]]*([^[:space:]]+)[[:space:]]+([^[:space:]]+)"
				re+="[[:space:]]+(.*)$"
				[[ $val =~ $re ]]
				tag="${BASH_REMATCH[1]}"
				default="${BASH_REMATCH[2]}"
				option="${BASH_REMATCH[3]}"
				# standardise default status
				default="$(dnStandardiseBoolean "${default}")"
				case ${default} in
				'0') default='true' ;;
				'1') default='false' ;;
				esac
				# internal possessive apostrophes can cause problems
				# add to arrays
				tags+=("$(dnStripQuotes "${tag}")")
				defaults+=("$(dnStripQuotes "${default}")")
				options+=("$(dnStripQuotes "${option}")")
				;;
			esac
		fi
	done <"${resources}"
	# get dialog type
	dlg_type="$(dnLowercase "$(dnDialogType)")" || dnEndScript 1 \
		"${FUNCNAME[0]}: Unable to locate dialog command" \
		'Perhaps this is a non-graphical environment?'
	# set menu dimensions
	for ((i = 0; i < ${#tags[*]}; i++)); do # get max option length
		option_length=$(dnStrLen "${options[i]}")
		[ "${option_length}" -gt "${option_length_max}" ] &&
			option_length_max=${option_length}
	done
	case ${dlg_type} in
	'kdialog')
		# menu dimensions in pixels
		menu_height=$(((${#tags[*]} + 5) * height_char_pixels))
		menu_width=$(((option_length_max + 5) * width_char_pixels))
		;;
	'dialog')
		# dialog uses sensible defaults so no changes necessary
		;;
	esac
	# build dialog command
	case ${dlg_type} in
	'kdialog')
		cmd=(
			kdialog
			--geometry "${menu_width}x${menu_height}"
			--title "${title}"
			--separate-output
			--checklist "${prompt}"
		)
		;;
	'zenity')
		cmd=(
			zenity
			--title "${title}"
			--width=200
			--height=300
			--list
			"--text='${prompt}'"
			--hide-column=2
			--separator=' '
			--checklist
			--column='Picks'
			--column='Tags'
			--column='Options'
		)
		;;
	'dialog')
		cmd=(
			dialog
			--title "${title}"
			--stdout
			--separate-output
			--checklist
			"${prompt}"
			"${menu_height}"
			"${menu_width}"
			"${menu_count}"
		)
		;;
	esac
	for ((i = 0; i < ${#tags[*]}; i++)); do
		case ${dlg_type} in
		'kdialog' | 'dialog')
			cmd+=("${tags[i]}" "${options[i]}" "${defaults[i]}")
			;;
		'zenity')
			cmd+=("${defaults[i]}" "${tags[i]}" "${options[i]}")
			;;
		esac
	done
	# make selection
	"${cmd[@]}" 1>"${pick_file}" # capture output in temporary file
	picks="$(cat "${pick_file}")"
	dnTempKill "${pick_file}"
	[ -n "${picks+x}" ] || return 1
	# process picks into array
	for pick in "${picks[@]}"; do
		picks_array+=("$(dnStripQuotes "${pick}")")
	done
	# decide upon, and return, return value
	# we have tags in variable 'picks_array'
	# finds first match (if duplicate tags)
	for ((i = 0; i < ${#tags[*]}; i++)); do
		if dnElementInList "${tags[i]}" "${picks_array[*]}"; then
			case ${return_val} in
			'tag') retval="${retval} ${tags[i]}" ;;
			'option') retval="${retval} \"${options[i]}\"" ;;
			'index') retval="${retval} ${i}" ;;
			esac
		fi
	done
	retval="$(dnStripEnclosingSpaces "${retval}")"
	[ -n "${retval+x}" ] || return 1
	echo "${retval}"
}
# Function: dnListUsers    {{{1
# Lists all users with accounts and directory under /home/
#   params: nil
#   prints: space-delimited list of users
#   return: nil
#   usage:  for user in $( dnListUsers ) ; do ...
# fn_tag dnListUsers purpose List all users
# fn_tag dnListUsers prints Space-delimited list of users
# fn_tag dnListUsers returns NIL
# fn_tag dnListUsers usage for user in $( dnListUsers ) ; do ...
# fn_tag dnListUsers note Lists only users with accounts and directories under /home/
dnListUsers() {
	local user subdir
	user='' subdir=''
	local -a users=() subdirs=()
	mapfile -t users < <(cut -d: -f1 </etc/passwd)
	mapfile -t subdirs < <(dir -1 /home/ | grep -v 'lost+found')
	for subdir in "${subdirs[@]}"; do
		for user in "${users[@]}"; do
			[ "${user}" = "${subdir}" ] && echo "${user}"
		done
	done
}
# Function: dnListsIntersect    {{{1
# Check whether lists share element(s)
#   params: 1 - list (space-delimited)
#           2 - list (space-delimited)
#   prints: nil
#   return: boolean (0=intersects|1=does not)
#   invoke: dnListsIntersect "${foo[*]}" "${elements[*]}"
# fn_tag dnListsIntersect purpose Determine whether two lists intersect -- share at least one element
# fn_tag dnListsIntersect prints NIL
# fn_tag dnListsIntersect returns Whether lists intersect (Boolean)
# fn_tag dnListsIntersect usage dnListsIntersect "${foo[*]}" "${elements[*]}"
# fn_tag dnListsIntersect param list-A purpose First list to compare
# fn_tag dnListsIntersect param list-A required yes
# fn_tag dnListsIntersect param list-A multipart no
# fn_tag dnListsIntersect param list-A type string
# fn_tag dnListsIntersect param list-A note Space-delimited
# fn_tag dnListsIntersect param list-B purpose Second list to compare
# fn_tag dnListsIntersect param list-B required yes
# fn_tag dnListsIntersect param list-B multipart no
# fn_tag dnListsIntersect param list-B type string
# fn_tag dnListsIntersect param list-B note Space-delimited
dnListsIntersect() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: First list not provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: Second list not provided"
	local list_a list_b retval
	list_a="${1}" list_b="${2}" retval=1
	list_a="$(dnStripEnclosingSpaces "${list_a}")"
	list_b="$(dnStripEnclosingSpaces "${list_b}")"
	for a in ${list_a}; do
		for b in ${list_b}; do
			[ "${a}" = "${b}" ] && retval=0
		done
	done
	unset a b
	return ${retval}
}
# Function: dnLocalGitRepoUptodate    {{{1
# Determine whether local git repo is up to date
#   params: nil
#   prints: nil
#   return: boolean (0=not up to date|1=up to date)
#   note:   intended for repo consisting only of current directory
#   note:   if repo covers more than current directory may get unexpected results
# fn_tag dnLocalGitRepoUptodate purpose Determine whether local git repo is up to date
# fn_tag dnLocalGitRepoUptodate prints NIL
# fn_tag dnLocalGitRepoUptodate returns Whether local git repo is up to date (Boolean)
# fn_tag dnLocalGitRepoUptodate usage See dnUpdateRemoteGitRepo for example using this function
# fn_tag dnLocalGitRepoUptodate note Intended for repo consisting only of current directory
# fn_tag dnLocalGitRepoUptodate note If repo covers more than current directory may get unexpected results
dnLocalGitRepoUptodate() {
	[ -z "$(git status --porcelain)" ]
	return ${?}
}
# Function: dnLog    {{{1
# Write log message to system log
#   params: 1+ - message part
#   prints: nil
#   return: nil
# fn_tag dnLog purpose Write message to system log
# fn_tag dnLog prints NIL
# fn_tag dnLog returns NIL
# fn_tag dnLog note Log message will be tagged with name of calling script
# fn_tag dnLog param message purpose Message part to be written to system log
# fn_tag dnLog param message required yes
# fn_tag dnLog param message multipart yes
# fn_tag dnLog param message type string
dnLog() {
	while [ ${#} -gt 0 ]; do
		logger -t "${dn_self}" "${1}"
		shift
	done
}
# Function: dnLowercase    {{{1
# Change uppercase to lowercase
#   params: 1 - string
#   prints: string
#   return: nil
# fn_tag dnLowercase purpose Convert upper case characters in string to lower case
# fn_tag dnLowercase prints Edited string
# fn_tag dnLowercase returns NIL
# fn_tag dnLowercase param string purpose String to be converted
# fn_tag dnLowercase param string required yes
# fn_tag dnLowercase param string multipart no
# fn_tag dnLowercase param string type string
dnLowercase() {
	echo "${1,,}"
}
# Function: dnMakeUniqueArrayElement    {{{1
# Return unique element by appending '_(x)' where 'x' is an integer
#   params: 1  - element (raw element, NOT regex or wildcards)
#           2+ - array elements
#   prints: unique element
#   return: nil
#   usage:  array+=("$(dnMakeUniqueArrayElement "${element}" "${array[@]}")")
# fn_tag dnMakeUniqueArrayElement purpose Ensure element would be unique in array
# fn_tag dnMakeUniqueArrayElement prints Unique element
# fn_tag dnMakeUniqueArrayElement returns NIL
# fn_tag dnMakeUniqueArrayElement usage array+=("$(dnMakeUniqueArrayElement "${element}" "${array[@]}")")
# fn_tag dnMakeUniqueArrayElement note Makes unique by appending '_(x)' where 'x' is lowest possible integer
# fn_tag dnMakeUniqueArrayElement param element purpose Element to make unique
# fn_tag dnMakeUniqueArrayElement param element required yes
# fn_tag dnMakeUniqueArrayElement param element multipart no
# fn_tag dnMakeUniqueArrayElement param element type string
# fn_tag dnMakeUniqueArrayElement param array purpose Array within which element would have to be unique
# fn_tag dnMakeUniqueArrayElement param array required yes
# fn_tag dnMakeUniqueArrayElement param array multipart yes
# fn_tag dnMakeUniqueArrayElement param array type string
dnMakeUniqueArrayElement() {
	# set and check variables
	# • sanity checks
	[ ${#} -ge 2 ] || return 1
	local element
	element="${1}"
	shift
	if ! dnElementInArray "${element}" "${@}"; then
		echo "${element}"
		return
	fi
	# • array
	local -a array=()
	#array=( "${@}" )
	for item in "${@}"; do
		array+=("${item}")
	done
	# • miscellaneous
	local got_unique unique_element index
	got_unique=1 unique_element='' index=1 # after increment starts at 2
	# append incrementing number until get a match
	while ! dnFlagTrue "${got_unique}"; do
		((index++)) || true
		unique_element="${element}_(${index})"
		dnElementInArray "${unique_element}" "${array[@]}" || got_unique=0
	done
	# report results
	echo "${unique_element}"
}
# Function: dnMessage    {{{1
# Print message
#   params: 1  - message type (e.g. 'Info'|'Warning'|'Error' etc.)
#           2  - suppress newline (0|1 = suppress|don't suppress)
#           3+ - message part(s)
#   prints: formatted message
#   return: nil
# fn_tag dnMessage purpose Print message to standard output
# fn_tag dnMessage prints Formatted message
# fn_tag dnMessage returns NIL
# fn_tag dnMessage param type purpose Message type
# fn_tag dnMessage param type required yes
# fn_tag dnMessage param type multipart no
# fn_tag dnMessage param type type string
# fn_tag dnMessage param suppress_newline purpose Whether to suppress terminal newline
# fn_tag dnMessage param suppress_newline required yes
# fn_tag dnMessage param suppress_newline multipart no
# fn_tag dnMessage param suppress_newline type boolean
# fn_tag dnMessage param part purpose Message part
# fn_tag dnMessage param part required yes
# fn_tag dnMessage param part multipart yes
# fn_tag dnMessage param part type string
dnMessage() {
	[ -n "${3+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No newline flag provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No type provided"
	# set message type
	dnPushIFS  # need space in IFS
	dnResetIFS # else $echo_cmd is interpreted as single token
	local type echo_cmd
	type="${1}" echo_cmd=''
	shift
	# set echo command
	case ${1} in
	0) echo_cmd="echo -e -n" ;;
	*) echo_cmd="echo -e" ;;
	esac
	shift
	# display messages
	while [[ ${#} -gt 0 ]]; do
		${echo_cmd} "${type}: ${1}"
		shift
	done
	dnPopIFS
}
# Function: dnMessageStderr    {{{1
# Print message to stderr
#   params: 1  - message type (e.g. 'Info'|'Warning'|'Error' etc.)
#           2  - suppress newline (0|1 = suppress|don't suppress)
#           3+ - message part(s)
#   prints: formatted message
#   return: nil
# fn_tag dnMessageStderr purpose Print message to standard error
# fn_tag dnMessageStderr prints Formatted message
# fn_tag dnMessageStderr returns NIL
# fn_tag dnMessageStderr param type purpose Message type
# fn_tag dnMessageStderr param type required yes
# fn_tag dnMessageStderr param type multipart no
# fn_tag dnMessageStderr param type type string
# fn_tag dnMessageStderr param suppress_newline purpose Whether to suppress terminal newline
# fn_tag dnMessageStderr param suppress_newline required yes
# fn_tag dnMessageStderr param suppress_newline multipart no
# fn_tag dnMessageStderr param suppress_newline type boolean
# fn_tag dnMessageStderr param part purpose Message part
# fn_tag dnMessageStderr param part required yes
# fn_tag dnMessageStderr param part multipart yes
# fn_tag dnMessageStderr param part type string
dnMessageStderr() {
	[ -n "${3+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No newline flag provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No type provided"
	# set message type
	dnPushIFS  # need space in IFS
	dnResetIFS # else $echo_cmd is interpreted as single token
	local type echo_cmd
	type="${1}" echo_cmd=''
	shift
	# set echo command
	case ${1} in
	0) echo_cmd='echo -e -n' ;;
	*) echo_cmd='echo -e' ;;
	esac
	shift
	# display messages
	while [ ${#} -gt 0 ]; do
		${echo_cmd} "${type}: ${1}" 1>&2
		shift
	done
	dnPopIFS
}
# Function: dnMimeType    {{{1
# Get mimetype of file
#   params: filepath
#   prints: mime type
#   return: nil
# fn_tag dnMimeType purpose Get mimetype of file
# fn_tag dnMimeType prints File mime type
# fn_tag dnMimeType returns NIL
# fn_tag dnMimeType usage mime_type="$( dnMimeType "${file}" )"
# fn_tag dnMimeType param file purpose File to be analysed
# fn_tag dnMimeType param file required yes
# fn_tag dnMimeType param file multipart no
# fn_tag dnMimeType param file type path
dnMimeType() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	# set and check variables
	local file first_line mime
	file="$(dnNormalisePath "${1}")"
	[ -f "${file}" ] || return 1 # false
	# special case: perlscript
	first_line="$(head -n 1 "${file}")"
	if [ "${first_line}" = '#!/usr/bin/perl' ]; then
		echo 'application/x-perl'
		return
	fi
	# back to general case
	mime="$(perl -M'File::MimeInfo' \
		-e "print File::MimeInfo::mimetype('${file}')")"
	echo "${mime}"
	return 0 # true
}

# Function: dnNoSpace    {{{1
# Contains space?
#   params: 1 - string
#   prints: nil
#   return: 0|1+ (no space|space)
# fn_tag dnNoSpace purpose Determine whether string contains space
# fn_tag dnNoSpace prints NIL
# fn_tag dnNoSpace returns Whether string contains space (Boolean)
# fn_tag dnNoSpace note Does not test for all whitespace -- just the space character
# fn_tag dnNoSpace param string purpose String to check
# fn_tag dnNoSpace param string required yes
# fn_tag dnNoSpace param string multipart no
# fn_tag dnNoSpace param string type string
dnNoSpace() {
	no_spaces=0
	[[ $1 =~ \  ]] && no_spaces=1
	return ${no_spaces}
}
# Function: dnNormalisePath    {{{1
# Normalise path (make absolute)
#   params: 1 - path
#   prints: normalised path
#   return: nil
# fn_tag dnNormalisePath purpose Convert relative path to absolute path
# fn_tag dnNormalisePath prints Normalised path
# fn_tag dnNormalisePath returns NIL
# fn_tag dnNormalisePath param path purpose Filepath to be normalised
# fn_tag dnNormalisePath param path required yes
# fn_tag dnNormalisePath param path multipart no
# fn_tag dnNormalisePath param path type path
dnNormalisePath() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	realpath --canonicalize-missing "${1}"
}
# Function: dnNullCharacter    {{{1
#   params: nil
#   prints: null character
#   return: nil
# fn_tag dnNullCharacter purpose Provides a null character, i.e., octal 000, hex 00, decimal 0, NUL, '\0'
# fn_tag dnNullCharacter prints Null character
# fn_tag dnNullCharacter returns NIL
dnNullCharacter() {
	echo $'\000'
}

# }}}1
# Function: dnNumberToWords    {{{1
# Convert number from sequence of digits to sequence of words
#   params: 1 - number
#   prints: if conversion succeeds:
#               - number in words to stdout
#           if conversion fails:
#               - original input to stdout
#               - error message to stderr
#   return: 0|1 (conversion succeeds|conversion fails)
#   note:   any failure results in return of original number parameter
#   credit: based on script by Chris F.A. Johnson at
#           <http://cfajohnson.com/shell/scripts/num2word-sh>
# fn_tag dnNumberToWords purpose Convert number from sequence of digits to sequence of words
# fn_tag dnNumberToWords prints On success prints word sequence; on failure prints original input, and error message to stderr
# fn_tag dnNumberToWords returns NIL
# fn_tag dnNumberToWords note Based on a script by Chris F.A. Johnson at <http://cfajohnson.com/shell/scripts/num2word-sh>
# fn_tag dnNumberToWords param number purpose Number to be converted to words
# fn_tag dnNumberToWords param number required yes
# fn_tag dnNumberToWords param number multipart no
# fn_tag dnNumberToWords param number type number
# fn_tag dnNumberToWords param number note Must be standard base 10 integer or decimal, e.g., -23.67, 34, -.09
dnNumberToWords() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No number provided"
	# INTERNAL FUNCTIONS
	# process triplet of numbers
	w3() {
		num=${1}
		case ${num} in
		????* | *[!0-9]*) return 5 ;;
		00*) num=${num#00} ;;
		0*) num=${num#0} ;;
		esac
		case ${num#0} in
		[1-9] | [0-9]0 | [1-9]00 | 1[0-9])
			echo "${numwords[$num]}"
			;;
		[2-9][1-9])
			echo "${numwords[${num%?}0]}"-"${numwords[${num#?}]}"
			;;
		[1-9][0-9][0-9])
			hword=${numwords[${num%??}00]}
			echo "${hword}${and} $(w3 "${num#?}")"
			;;
		esac
	}

	# VARIABLES
	local numwords=(zero one two three four five six seven eight nine ten
		eleven twelve thirteen fourteen fifteen sixteen seventeen
		eighteen nineteen twenty)
	numwords[30]='thirty'
	numwords[40]='forty'
	numwords[50]='fifty'
	numwords[60]='sixty'
	numwords[70]='seventy'
	numwords[80]='eighty'
	numwords[90]='ninety'
	numwords[100]='one hundred'
	numwords[200]='two hundred'
	numwords[300]='three hundred'
	numwords[400]='four hundred'
	numwords[500]='five hundred'
	numwords[600]='six hundred'
	numwords[700]='seven hundred'
	numwords[800]='eight hundred'
	numwords[900]='nine hundred'
	local thou=('' thousand million billion trillion quadrillion quintillion)
	local words minus decimal left and amount level
	words='' minus='' decimal='' left='' and=' and' amount="${1}" level=0

	# MAIN
	# check format of input
	if [ "$(
		echo "${amount}" | grep -c \
			'^[-]\?\(\([0-9]\+\)\|\([0-9]*\.[0-9]\+\)\)$'
	)" -ne 1 ]; then
		echo "${amount}"
		dnErrorStderr "Input '${amount}' has invalid format" \
			'Input must be standard base 10 integer or decimal number'
		return 1
	fi
	# deal with possible minus sign in front of number
	if [ "${amount:0:1}" = '-' ]; then
		minus=minus
		amount=${amount#?}
	fi
	# strip any leading zeroes
	amount="$(dnStripLeadingZeroes "${amount}")"
	# split into integer and decimal fraction
	case ${amount} in
	*.*)
		decimal=${amount#*.}
		amount=${amount%.*}
		;;
	esac
	# process number in triplets to convert into words
	while :; do
		case ${amount} in
		[0-9][0-9][0-9]*)
			# process next triplet in number
			left=${amount%???}
			words="$(w3 "${amount#"${left}"}")${thou[level]:+ ${thou[level]}} ${words}"
			amount=${left}
			((level++)) || true
			;;
		"")
			# last iteration because number has been fully converted
			break
			;;
		*)
			# last iteration to process remainder (<1,000)
			words="$(w3 "${amount}")${thou[level]:+ ${thou[level]}} ${words}"
			break
			;;
		esac
	done
	# add decimal part of number
	[ -n "${decimal+x}" ] && words+=' point'
	while [ -n "${decimal+x}" ]; do
		words+=" ${numwords[${decimal:0:1}]}"
		decimal=${decimal#?}
	done
	# return converted number
	echo ${minus:+${minus} }"${words}"
}

# Function: dnOpFail    {{{1
# Report whether operation failed
#   params: 1 - exit status of operation ('0' = success)
#   prints: nil
#   return: inverted exit status of operation ('0' = success)
# fn_tag dnOpFail purpose Report whether operation failed
# fn_tag dnOpFail prints NIL
# fn_tag dnOpFail returns Inverted exit status of operation
# fn_tag dnOpFail param exit_status purpose Exit status of operation ('0'=success)
# fn_tag dnOpFail param exit_status required yes
# fn_tag dnOpFail param exit_status multipart no
# fn_tag dnOpFail param exit_status type boolean
dnOpFail() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No exit status provided"
	[ "${1}" -eq 0 ] && return 1 || return 0
}
# Function: dnOpOk    {{{1
# Report whether operation succeeded
#   params: 1 - exit status of operation ('0' = success)
#   prints: nil
#   return: exit status of operation ('0' = success)
# fn_tag dnOpOk purpose Report whether operation succeeded
# fn_tag dnOpOk prints NIL
# fn_tag dnOpOk returns Exit status of operation (Boolean)
# fn_tag dnOpOk param exit_status purpose Exit status of operation
# fn_tag dnOpOk param exit_status required yes
# fn_tag dnOpOk param exit_status multipart no
# fn_tag dnOpOk param exit_status type boolean
dnOpOk() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No exit status provided"
	return "${1}"
}
# Function: dnOutputArray    {{{1
# Output array for capture into receiving array
#   params: 1+ - array elements
#   prints: single-quote-delimited array elements
#   return: nil
#   usage:  eval "new_array=( dnOutputArray "${old_array[@]}" )"
#   notes:  any quote marks, including apostrophes ('), will be stripped out
#           this function is rarely called directly but used by other fns
#           it is vital to use 'eval' for line
# fn_tag dnOutputArray purpose Output array in form suitable for capture into another array
# fn_tag dnOutputArray prints Altered array
# fn_tag dnOutputArray returns NIL
# fn_tag dnOutputArray note All quote marks in array items, including apostrophes (') will be stripped
# fn_tag dnOutputArray note It is vital that 'eval' be used when calling function
# fn_tag dnOutputArray usage eval "new_array=( dnOutputArray "${old_array[@]}" )"
# fn_tag dnOutputArray param array purpose Input array to be altered and output
# fn_tag dnOutputArray param array required yes
# fn_tag dnOutputArray param array multipart yes
# fn_tag dnOutputArray param array type string
dnOutputArray() {
	[ ${#} -gt 0 ] || dnAbort "${FUNCNAME[0]}: No array elements provided"
	local -a output=()
	while [ ${#} -gt 0 ]; do
		output+=("$(dnStripQuotes "${1}")")
		shift
	done
	echo "${output[@]}"
}
# Function: dnParentDir    {{{1
# Extracts parent directory from directory path
# e.g., from '/path/to/dir' extract '/path/to'
#   params: 1 - directory path
#   prints: parent directory
#   return: nil
#   needs:  functions [dnRemoveEndSlash]
#   usage:  dnParentDir '/music/audio.wav'   # '/music'
#           dnParentDir '/music/pop/'        # '/music'
# fn_tag dnParentDir purpose Extract parent directory path from file or directory path
# fn_tag dnParentDir prints Parent directory path
# fn_tag dnParentDir returns NIL
# fn_tag dnParentDir usage dnParentDir '/music/audio.wav'   # '/music'
# fn_tag dnParentDir usage dnParentDir '/music/pop/'        # '/music'
# fn_tag dnParentDir note Can be used on file or directory paths
# fn_tag dnParentDir note The shortcut prefix '~' will be converted to the home directory path
# fn_tag dnParentDir param path purpose Path to be analysed
# fn_tag dnParentDir param path required yes
# fn_tag dnParentDir param path multipart no
# fn_tag dnParentDir param path type path
dnParentDir() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No directory path provided"
	parent="$(dirname "${1}")"
	[[ $parent =~ ^(\.|\/)$ ]] && parent=''
	echo "${parent}"
}
# Function: dnPickColour    {{{1
# User selects colour
# note: All colours must also be in dnColourToRGB
# note: Arrays in dnColourToRGB and dnPickColour must be kept in synchrony
#   params: 1 - prompt text (optional, default='Select colour')
#   prints: selected colour
#   return: boolean (0=success|1=error)
# fn_tag dnPickColour purpose User selects colour name
# fn_tag dnPickColour prints Selected colour
# fn_tag dnPickColour returns Whether colour chosen (Boolean)
# fn_tag dnPickColour note All colours must also be in function 'dnColourToRGB'
# fn_tag dnPickColour note Arrays in functions 'dnColourToRGB' and 'dnPickColour' must be kept in synchrony
# fn_tag dnPickColour param prompt purpose User prompt
# fn_tag dnPickColour param prompt required no
# fn_tag dnPickColour param prompt multipart no
# fn_tag dnPickColour param prompt type string
# fn_tag dnPickColour param prompt default Select colour:
dnPickColour() {
	local retval index colour pick options prompt
	retval='' index='' colour='' pick='' options=''
	prompt="${1:-'Select colour: '}"
	local -a colours=('black' 'blue' 'blue, midnight' 'blue, royal' 'cyan'
		'gold' 'gray' 'gray, dim' 'gray, slate' 'green'
		'green, dark' 'green, forest' 'green, pale' 'magenta'
		'navy' 'orange' 'orange, dark' 'peach' 'pink' 'purple'
		'red' 'red, orange' 'rose, misty' 'slate, dark blue'
		'tan' 'violet' 'white' 'yellow')
	# assemble list of colours
	local msg menu_file
	msg="${FUNCNAME[0]}: Unable to make temp file"
	menu_file="$(dnTempFile)" || dnEndScript 1 "${msg}"
	dnTempTrap "${menu_file}"
	cat >"${menu_file}" <<-EOF
		title 'Pick Colour'
		prompt '${prompt}'
		return index
	EOF
	for ((index = 0; index < ${#colours[*]}; index++)); do
		echo "option '${colours[index]}'" >>"${menu_file}"
	done
	# select colour
	retval=0
	pick="$(dnSelectDlg "${menu_file}")"
	dnTempKill "${menu_file}"
	[ -z "${pick}" ] && retval=1
	choice="${colours[pick]}"
	# return choice and indicate success
	echo "${choice}"
	return ${retval}
}
# Function: dnPidRunning    {{{1
# Check whether app is running (by pid)
#   params: 1 - pid of process
#   prints: nil
#   return: boolean (0=running|1=not running)
# fn_tag dnPidRunning purpose Determine whether given PID is running
# fn_tag dnPidRunning prints NIL
# fn_tag dnPidRunning returns Whether PID is running (Boolean)
# fn_tag dnPidRunning param pid purpose Process ID to check
# fn_tag dnPidRunning param pid required yes
# fn_tag dnPidRunning param pid multipart no
# fn_tag dnPidRunning param pid type integer
dnPidRunning() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No pid provided"
	ps -p "${1}" &>/dev/null
	return ${?}
}
# Function: dnPipeSucceeded    {{{1
# Check whether all commands in a command pipeline succeeded
#   params: 1 - pipeline array as single string
#   prints: nil
#   return: 0|1 (true|false)
#   usage:  cmd_1 | cmd_2 | ...
#           if dnPipeSucceeded "${PIPESTATUS[*]}" ; then ...
# fn_tag dnPipeSucceeded purpose Determine whether all commands in the most recently executed pipe succeeded
# fn_tag dnPipeSucceeded prints NIL
# fn_tag dnPipeSucceeded returns Whether all pipe commands succeeded (Boolean)
# fn_tag dnPipeSucceeded usage cmd_1 | cmd_2 | ...
# fn_tag dnPipeSucceeded usage if dnPipeSucceeded "${PIPESTATUS[*]}" ; then ...
# fn_tag dnPipeSucceeded param result-array purpose Array of pipline exit statuses
# fn_tag dnPipeSucceeded param result-array required yes
# fn_tag dnPipeSucceeded param result-array multipart no
# fn_tag dnPipeSucceeded param result-array type integer
# fn_tag dnPipeSucceeded param result-array note Array of exit statuses provided by '"${PIPESTATUS[*]"'
dnPipeSucceeded() {
	[[ $1 =~ ^0(\ 0)*$ ]]
	return ${?}
}
# Function: dnPopIFS    {{{1
# Pop top IFS stack value into IFS variable
#   params: nil
#   prints: nil
#   return: 0|1 (success|failure)
#   note:   deletes top element of IFS stack variable 'dn_IFS_stack'
#   note:   IFS variable is left unchanged if IFS stack is empty
#   usage:  see dnPushIFS function
# fn_tag dnPopIFS purpose Pop top IFS stack value into IFS variable
# fn_tag dnPopIFS prints NIL
# fn_tag dnPopIFS returns Whether operation succeeds (Boolean)
# fn_tag dnPopIFS usage See dnPushIFS function
# fn_tag dnPopIFS note Deletes top element of IFS stack variable 'dn_IFS_stack'
# fn_tag dnPopIFS note IFS variable is left unchanged if IFS stack is empty
dnPopIFS() {
	# variables
	local last_index
	last_index=$((${#dn_IFS_stack[@]} - 1))
	# must be at least one element in the array
	[ ${last_index} -lt 0 ] && return 1
	# put last element of stack array into IFS variable
	eval "IFS=\${dn_IFS_stack[\${last_index}]}"
	# remove last element
	unset "dn_IFS_stack[last_index]"
}
# }}}1
# Function: dnPopupDlg    {{{1
# Display popup message
#   params: 1 - message
#           2 - title (optional)
#   prints: nil
#   return: nil
# fn_tag dnPopupDlg purpose Display informational message in popup
# fn_tag dnPopupDlg prints NIL
# fn_tag dnPopupDlg returns NIL
# fn_tag dnPopupDlg note This function does not guarantee that newlines tokens ('\n') in the message are honoured by the popup
# fn_tag dnPopupDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnPopupDlg param message purpose Popup message
# fn_tag dnPopupDlg param message required yes
# fn_tag dnPopupDlg param message multipart no
# fn_tag dnPopupDlg param message type string
# fn_tag dnPopupDlg param title purpose Popup title
# fn_tag dnPopupDlg param title required no
# fn_tag dnPopupDlg param title multipart no
# fn_tag dnPopupDlg param title type string
# fn_tag dnPopupDlg param title note Empty title is converted by subsidiary function to script name
dnPopupDlg() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	dnDlg 'popup' "${2:-''}" "${1}" "1"
}

# Function: dnPopupNlDlg    {{{1
# Display popup message in popup that honours newlines
#   params: 1 - message
#           2 - title (optional)
#   prints: nil
#   return: nil
# fn_tag dnPopupNlDlg purpose Display informational message in popup
# fn_tag dnPopupNlDlg prints NIL
# fn_tag dnPopupNlDlg returns NIL
# fn_tag dnPopupNlDlg note This function attempts to use a popup that honours newlines tokens ('\n') in the message
# fn_tag dnPopupNlDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnPopupNlDlg param message purpose Popup message
# fn_tag dnPopupNlDlg param message required yes
# fn_tag dnPopupNlDlg param message multipart no
# fn_tag dnPopupNlDlg param message type string
# fn_tag dnPopupNlDlg param title purpose Popup title
# fn_tag dnPopupNlDlg param title required no
# fn_tag dnPopupNlDlg param title multipart no
# fn_tag dnPopupNlDlg param title type string
# fn_tag dnPopupNlDlg param title note Empty title is converted by subsidiary function to script name
dnPopupNlDlg() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No message provided"
	dnDlg 'popup' "${2:-''}" "${1}" "0"
}
# Function: dnPositionInArray    {{{1
# Find first matching element in array and return element index
#   params: 1  - element (raw element, NOT regex or wildcards)
#           2+ - array elements
#   prints: array index of first matching element
#   return: boolean (0=found position|1=position not found)
#   usage:  index=$( dnElementInArray "${element}" "${array[@]}" )
# fn_tag dnPositionInArray purpose Determine index of first matching array element
# fn_tag dnPositionInArray prints Index of first matching array element, empty string if no match
# fn_tag dnPositionInArray returns Whether matching element found (Boolean)
# fn_tag dnPositionInArray usage index=$( dnElementInArray "${element}" "${array[@]}" )
# fn_tag dnPositionInArray param element purpose Element to search for
# fn_tag dnPositionInArray param element required yes
# fn_tag dnPositionInArray param element multipart no
# fn_tag dnPositionInArray param element type string
# fn_tag dnPositionInArray param element note Raw text, no regex or wildcards
# fn_tag dnPositionInArray param array purpose Array to search
# fn_tag dnPositionInArray param array required yes
# fn_tag dnPositionInArray param array multipart yes
# fn_tag dnPositionInArray param array type string
dnPositionInArray() {
	# set and check variables
	# • process args
	[ ${#} -ge 2 ] || return 1
	local match_value
	match_value="${1}"
	shift
	# • vars
	local retval loop match_position
	retval=1 loop=0 match_position=''
	# loop through array looking for match
	for element in "${@}"; do
		((loop++)) || true
		if [ "${match_value}" = "${element}" ]; then
			match_position=$loop
			retval=0
			break
		fi
	done
	# report results
	echo "${match_position}"
	return ${retval}
}
# Function: dnPrintArray    {{{1
# Print array
#   params: 1 - array
#   prints: formatted list (newline-delimited)
#   return: nil
#   invoke: dnPrintArray "${foo[@]}"
# fn_tag dnPrintArray purpose Displays formatted array on STDOUT
# fn_tag dnPrintArray prints Formatted array
# fn_tag dnPrintArray returns NIL
# fn_tag dnPrintArray note Array items are numbered with one per line
# fn_tag dnPrintArray usage dnPrintArray "${foo[@]}"
# fn_tag dnPrintArray param array purpose Array to format
# fn_tag dnPrintArray param array required yes
# fn_tag dnPrintArray param array multipart yes
# fn_tag dnPrintArray param array type string
dnPrintArray() {
	local index space input_item output_item index_width
	index=0 space=' ' input_item='' output_item=''
	index_width=$(dnStrLen ${#})
	local -a output=()
	for input_item in "${@}"; do
		output_item="${index}"
		while [ "$(dnStrLen "${output_item}")" -lt "${index_width}" ]; do
			output_item="${space}${output_item}"
		done
		output_item="${output_item}: '${input_item}'"
		output+=("${output_item}")
		((index++)) || true
	done
	dnInfo "${output[@]}"
}
# Function: dnPrintArrayStderr    {{{1
# Print array to stderr
#   params: 1 - array
#   prints: formatted list (newline-delimited)
#   return: nil
#   invoke: dnPrintArrayStderr "${foo[@]}"
# fn_tag dnPrintArrayStderr purpose Displays formatted array on STDERR
# fn_tag dnPrintArrayStderr prints Formatted array
# fn_tag dnPrintArrayStderr returns NIL
# fn_tag dnPrintArrayStderr note Array items are numbered with one per line
# fn_tag dnPrintArrayStderr usage dnPrintArray "${foo[@]}"
# fn_tag dnPrintArrayStderr param array purpose Array to format
# fn_tag dnPrintArrayStderr param array required yes
# fn_tag dnPrintArrayStderr param array multipart yes
# fn_tag dnPrintArrayStderr param array type string
dnPrintArrayStderr() {
	local index space input_item output_item index_width
	index=0 space=' ' input_item='' output_item=''
	index_width=$(dnStrLen ${#})
	local -a output=()
	for input_item in "${@}"; do
		output_item="${index}"
		while [ "$(dnStrLen "${output_item}")" -lt "${index_width}" ]; do
			output_item="${space}${output_item}"
		done
		output_item="${output_item}: '${input_item}'"
		output+=("${output_item}")
		((index++)) || true
	done
	dnInfoStderr "${output[@]}"
}
# Function: dnPrintElements    {{{1
# Print list (of space-delimited elements) one per line
#   params: 1 - list (space-delimited)
#           2 - 'info' [optional] = print using dnInfo command
#   prints: list (newline-delimited)
#   return: nil
#   invoke: dnPrintElements "${foo[*]}"
#   needs:  functions [dnInfo]
# fn_tag dnPrintElements purpose Prints list
# fn_tag dnPrintElements prints List elements -- one per line
# fn_tag dnPrintElements returns NIL
# fn_tag dnPrintElements usage dnPrintElements "${foo[*]}"
# fn_tag dnPrintElements param list purpose List of elements to print
# fn_tag dnPrintElements param list required yes
# fn_tag dnPrintElements param list multipart no
# fn_tag dnPrintElements param list type string
# fn_tag dnPrintElements param list note List must be space-delimited
# fn_tag dnPrintElements param output-command purpose Determines which output command is used
# fn_tag dnPrintElements param output-command required no
# fn_tag dnPrintElements param output-command multipart no
# fn_tag dnPrintElements param output-command type string
# fn_tag dnPrintElements param output-command value info
# fn_tag dnPrintElements param output-command note If set to 'info' will output using 'dnInfo', else will output using 'echo'
dnPrintElements() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No list provided"
	local cmd
	cmd="${2:-}" # determine print mode
	if [ "${cmd}" = 'info' ]; then cmd='dnInfo'; else cmd='echo'; fi
	for element in ${1}; do ${cmd} "${element}"; done # print list
}
# Function: dnProcessName    {{{1
# Check whether app is running (by pid)
#   params: 1 - pid of process
#   prints: Process name
#   return: nil
# fn_tag dnProcessName purpose Get name of process ID
# fn_tag dnProcessName prints Process name
# fn_tag dnProcessName returns NIL
# fn_tag dnProcessName note Assumes valid pid of running process
# fn_tag dnProcessName note This can be checked with dnPidRunning
# fn_tag dnProcessName param pid purpose Process ID to retrieve name on
# fn_tag dnProcessName param pid required yes
# fn_tag dnProcessName param pid multipart no
# fn_tag dnProcessName param pid type integer
dnProcessName() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No pid provided"
	pgrep -a "^\b${1}\b" |
		cut -d ' ' -f 2-
}
# Function: dnProgressWheel    {{{1
# Provide visual feedback ("spinning wheel") while pid running
#   params: 1 - pid
#           2 - text stub
#   prints: progress indicator (not for capture)
#   return: nil
#   needs:  functions [dnInfon ; dnPidRunning]
# fn_tag dnProgressWheel purpose Provide visual feedback while a PID is running
# fn_tag dnProgressWheel prints Progress indicator (not suitable for capture to a variable)
# fn_tag dnProgressWheel returns NIL
# fn_tag dnProgressWheel note Feedback is "spinning wheel" in front of slowly growing line of dots
# fn_tag dnProgressWheel param pid purpose PID whose cessation will stop spinning wheel
# fn_tag dnProgressWheel param pid required yes
# fn_tag dnProgressWheel param pid multipart no
# fn_tag dnProgressWheel param pid type integer
# fn_tag dnProgressWheel param text-stub purpose Text stub to print before dots and spinning wheel
# fn_tag dnProgressWheel param text-stub required yes
# fn_tag dnProgressWheel param text-stub multipart no
# fn_tag dnProgressWheel param text-stub type string
dnProgressWheel() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No pid provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No stub provided"
	dnInfon "${2} . "
	count=0
	rotation=0
	rotations=9
	pause=0.1
	while true; do
		if ! dnPidRunning "${1}"; then break; fi
		sleep ${pause}s
		case ${count} in
		0) echo -ne "\b\\" ;;
		1) echo -ne "\b|" ;;
		2) echo -ne "\b/" ;;
		3) echo -ne "\b-" ;;
		*)
			if [ ${rotation} -gt ${rotations} ]; then
				echo -ne "\b. "
				rotation=-1
			fi
			rotation=$((rotation + 1))
			count=-1
			;;
		esac
		count=$((count + 1))
	done
	echo -e "\b. Done."
}
# Function: dnPrompt    {{{1
# Prompt user
#   params: 1+ - message(s) [optional]
#   prints: feedback (not for capture)
#   return: nil
# fn_tag dnPrompt purpose Print prompt message to standard output
# fn_tag dnPrompt prints Formatted message
# fn_tag dnPrompt returns NIL
# fn_tag dnPrompt note prints default message in addition to param messages
# fn_tag dnPrompt param part purpose Message part
# fn_tag dnPrompt param part required no
# fn_tag dnPrompt param part multipart yes
# fn_tag dnPrompt param part type string
# shellcheck disable=SC2120  # passing param to dnPrompt is optional
dnPrompt() {
	local preamble prompt
	preamble="${*}" prompt='Press any key to proceed... '
	[[ -n "${preamble+x}" ]] && dnMessage 'Prompt' 1 "${preamble[@]}"
	dnMessage 'Prompt' 0 "${prompt}"
	read -r -s -n 1
	echo
}

# Function: dnPromptDlg    {{{1
# Prompt user with dialog
#   params: 1 - message
#           2 - title (optional)
#   prints: nil
#   return: nil
# fn_tag dnPromptDlg purpose Display prompt in dialog
# fn_tag dnPromptDlg prints NIL
# fn_tag dnPromptDlg returns NIL
# fn_tag dnPromptDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnPromptDlg param message purpose Prompt message
# fn_tag dnPromptDlg param message required yes
# fn_tag dnPromptDlg param message multipart no
# fn_tag dnPromptDlg param message type string
# fn_tag dnPromptDlg param title purpose Dialog title
# fn_tag dnPromptDlg param title required no
# fn_tag dnPromptDlg param title multipart no
# fn_tag dnPromptDlg param title type string
# fn_tag dnPromptDlg param title note Empty title is converted by subsidiary function to script name
dnPromptDlg() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No prompt provided"
	dnDlg 'info' "${2:-''}" "${1}"
}
# Function: dnPromptStderr    {{{1
# Prompt user using stderr
#   params: 1+ - message(s) [optional]
#   prints: feedback (not for capture)
#   return: nil
# fn_tag dnPromptStderr purpose Print prompt message to standard error
# fn_tag dnPromptStderr prints Formatted message
# fn_tag dnPromptStderr returns NIL
# fn_tag dnPromptStderr param part purpose Message part
# fn_tag dnPromptStderr param part required yes
# fn_tag dnPromptStderr param part multipart yes
# fn_tag dnPromptStderr param part type string
# shellcheck disable=SC2120  # passing param to dnPromptStderr is optional
dnPromptStderr() {
	local preamble prompt
	preamble="${*}" prompt='Press any key to proceed... '
	[[ -n "${preamble+x}" ]] && dnMessageStderr 'Prompt' 1 "${preamble[@]}"
	dnMessageStderr 'Prompt' 0 "${prompt}"
	read -r -s -n 1
	echo 1>&2
}
# Function: dnPushIFS    {{{1
# Push IFS value onto IFS stack
#   params: 1+ - IFS value(s) [string]
#   prints: nil
#   return: nil
#   note:   manipulates IFS stack variable 'dn_IFS_stack'
#   usage:  # protect operations relying on IFS variable
#           dnPushIFS
#           dnResetIFS
#           ## do operations relying on IFS variable
#           dnPopIFS
# fn_tag dnPushIFS purpose Push current IFS value onto IFS stack
# fn_tag dnPushIFS prints NIL
# fn_tag dnPushIFS returns NIL
# fn_tag dnPushIFS usage # protect operations relying on IFS variable
# fn_tag dnPushIFS usage dnPushIFS
# fn_tag dnPushIFS usage dnResetIFS
# fn_tag dnPushIFS usage ## do operations relying on IFS variable
# fn_tag dnPushIFS usage dnPopIFS
# fn_tag dnPushIFS note Manipulates IFS stack variable 'dn_IFS_stack'
dnPushIFS() {
	dn_IFS_stack=("${dn_IFS_stack[@]}" "${IFS}")
}
# Function: dnQuery    {{{1
# Print query to stdout
#   params: 1+ - message part(s)
#   prints: formatted message to stdout
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnQuery purpose Print query message to standard output
# fn_tag dnQuery prints Formatted message
# fn_tag dnQuery returns NIL
# fn_tag dnQuery param part purpose Message part
# fn_tag dnQuery param part required yes
# fn_tag dnQuery param part multipart yes
# fn_tag dnQuery param part type string
dnQuery() { dnMessage 'Query' 1 "${@}"; }
# Function: dnQueryStderr    {{{1
# Print query to stderr
#   params: 1+ - message part(s)
#   prints: formatted message to stderr
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnQueryStderr purpose Print query message to standard error
# fn_tag dnQueryStderr prints Formatted message
# fn_tag dnQueryStderr returns NIL
# fn_tag dnQueryStderr param part purpose Message part
# fn_tag dnQueryStderr param part required yes
# fn_tag dnQueryStderr param part multipart yes
# fn_tag dnQueryStderr param part type string
dnQueryStderr() { dnMessageStderr 'Query' 1 "${@}"; }
# Function: dnQuoted    {{{1
# Determine whether string enclosed in quotes
#   params: 1 - string
#   prints: nil
#   return: boolean (0=enclosed in quotes|1=not enclosed in quotes)
# fn_tag dnQuoted purpose Returns whether a string is enclosed in quotes
# fn_tag dnQuoted prints NIL
# fn_tag dnQuoted returns Whether string is enclosed in quotes (Boolean)
# fn_tag dnQuoted note Actually looks only for an opening quote -- either single or double
# fn_tag dnQuoted param string purpose String to be tested
# fn_tag dnQuoted param string required yes
# fn_tag dnQuoted param string multipart no
# fn_tag dnQuoted param string type string
dnQuoted() {
	if { [[ $string =~ ^\" ]] && [[ $string =~ \"$ ]]; } ||
		{ [[ $string =~ ^\' ]] && [[ $string =~ \'$ ]]; }; then
		return ${dn_true}
	else
		return ${dn_false}
	fi
}
# Function: dnReachableRepository    {{{1
# Determine whether any internet repository is reachable
#   params: 1 - package resource list file
#           2 - silent mode (optional, boolean, default = false)
#   prints: feedback (not for capture)
#   return: 0|1 (success|failure)
#   invoke: dnReachableRepository "\etc\apt\sources.list || ...
#   notes:  searches only for lines beginning with 'deb http'
# fn_tag dnReachableRepository purpose Determine whether at least one internet repository is reachable
# fn_tag dnReachableRepository prints Feedback (not for capture)
# fn_tag dnReachableRepository returns Whether any internet repository was reachable (Boolean)
# fn_tag dnReachableRepository note Searches package resource list only for files beginning 'deb http'
# fn_tag dnReachableRepository param file purpose File containing the package resource list, i.e., list of repositories
# fn_tag dnReachableRepository param file note Usual value for Debian systems is '\etc\apt\sources.list'
# fn_tag dnReachableRepository param file required yes
# fn_tag dnReachableRepository param file multipart no
# fn_tag dnReachableRepository param file type path
# fn_tag dnReachableRepository param silent purpose whether to echo feedback to screen
# fn_tag dnReachableRepository param silent required no
# fn_tag dnReachableRepository param silent multipart no
# fn_tag dnReachableRepository param silent type boolean
dnReachableRepository() {
	# define and check variables
	local rep source exit_status reached_repository silent
	rep='' source='' exit_status='' reached_repository=1 silent=1
	[ ${#} -eq 0 ] && return 1 # must be one or two parameters
	[ ${#} -gt 2 ] && return 1
	# check source file
	source="${1}"
	dnFileValid "${source}" || return 1
	# check mode
	[ ${#} -eq 2 ] && silent=$(dnStandardiseBoolean "${2}")
	dnFlagTrue "${silent}" || dnInfo "using repository list in '${source}'"
	dnFlagTrue "${silent}" ||
		dnInfo 'checking that at least one repository is reachable:'
	awk -F/ '/^deb http/ { print $3 }' "${source}" | while IFS= read -r rep; do
		# stop testing when have reached a repository
		if ! dnFlagTrue "${reached_repository}"; then
			dnFlagTrue "${silent}" || dnInfon "  pinging ${rep}... "
			ping -c 1 "${rep}" &>/dev/null
			exit_status=${?}
			dnFlagTrue "${exit_status}" && reached_repository=0
			dnFlagTrue "${silent}" || dnReport "${exit_status}"
		fi
	done
	return ${reached_repository}
}

# Function: dnRedReverseText    {{{1
# Add formatting strings to text to make it reverse red text
#   params: 1 - text string
#   prints: reversed red text
#   return: nil
# fn_tag dnRedReverseText purpose Add bash formatting codes to string to make it display in terminal as reverse red text
# fn_tag dnRedReverseText prints Formatted string
# fn_tag dnRedReverseText returns NIL
# fn_tag dnRedReverseText param string purpose String to format
# fn_tag dnRedReverseText param string required yes
# fn_tag dnRedReverseText param string multipart no
# fn_tag dnRedReverseText param string type string
dnRedReverseText() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	echo "$(dnFontFormat "reset,reverse" "red")${1}$(dnFontFormat "reset")"
}
# Function: dnRemoveDuplicates    {{{1
# Remove duplicate elements from a list
#   params: 1 - list (space-delimited)
#   prints: unique list (newline-delimited)
#   return: nil
#   invoke: dnRemoveDuplicates "${foo[*]}"
#   needs:  functions [dnPrintElements]
# fn_tag dnRemoveDuplicates purpose Remove duplicate elements from a list
# fn_tag dnRemoveDuplicates prints Unique list (newline-delimited)
# fn_tag dnRemoveDuplicates returns NIL
# fn_tag dnRemoveDuplicates usage dnRemoveDuplicates "${foo[*]}"
# fn_tag dnRemoveDuplicates param list purpose List to be processed
# fn_tag dnRemoveDuplicates param list required yes
# fn_tag dnRemoveDuplicates param list multipart no
# fn_tag dnRemoveDuplicates param list type string
# fn_tag dnRemoveDuplicates param list note Must be space-delimited
dnRemoveDuplicates() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No list provided"
	dnPrintElements "${1}" | sort | uniq
}
# Function: dnRemoveElements    {{{1
# Remove elements from a list
#   params: 1 - list (space-delimited)
#           2 - elements to remove (space-delimited)
#   prints: modified list
#   return: nil
#   invoke: dnRemoveElements "${foo[*]}" "${elements[*]}"
# fn_tag dnRemoveElements purpose Remove elements from a list
# fn_tag dnRemoveElements prints Modified list
# fn_tag dnRemoveElements returns NIL
# fn_tag dnRemoveElements usage dnRemoveElements "${foo[*]}" "${elements[*]}"
# fn_tag dnRemoveElements note All input and output lists are to be space-delimited
# fn_tag dnRemoveElements note Elements in both lists cannot contain spaces
# fn_tag dnRemoveElements param master-list purpose List of elements to be modified
# fn_tag dnRemoveElements param master-list required yes
# fn_tag dnRemoveElements param master-list multipart no
# fn_tag dnRemoveElements param master-list type string
# fn_tag dnRemoveElements param master-list note Space-delimited
# fn_tag dnRemoveElements param remove-list purpose List of elements to remove from the first (master) list
# fn_tag dnRemoveElements param remove-list required yes
# fn_tag dnRemoveElements param remove-list multipart no
# fn_tag dnRemoveElements param remove-list type string
# fn_tag dnRemoveElements param remove-list note Space-delimited
dnRemoveElements() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No list subset provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No master list provided"
	local -a list_master=() list_remove=() list_result=()
	IFS=' ' read -r -a list_master <<<"${1}"
	IFS=' ' read -r -a list_remove <<<"${2}"
	local delete_this_item
	delete_this_item=''
	for master_item in "${list_master[@]}"; do
		delete_this_item='no'
		for remove_item in "${list_remove[@]}"; do
			[ "${master_item}" == "${remove_item}" ] && delete_this_item='yes'
		done
		[ "${delete_this_item}" == 'no' ] && list_result+=("${master_item}")
	done
	echo "${list_result[*]}"
}

# }}}1
# Function: dnRemoveEndSlash    {{{1
# Remove terminal slash ('/') from string
#   params: 1 - string
#   prints: edited string
#   return: nil
# fn_tag dnRemoveEndSlash purpose Remove terminal (forward) slash from string
# fn_tag dnRemoveEndSlash prints Edited string
# fn_tag dnRemoveEndSlash returns NIL
# fn_tag dnRemoveEndSlash param string purpose String to edit
# fn_tag dnRemoveEndSlash param string required yes
# fn_tag dnRemoveEndSlash param string multipart no
# fn_tag dnRemoveEndSlash param string type string
dnRemoveEndSlash() { echo "${1/%\//}"; }
# Function: dnRemoveLeadingMinus    {{{1
# Remove leading minus sign
#   params: 1 - integer
#   prints: integer without any leading minus sign
#   return: nil
# fn_tag dnRemoveLeadingMinus purpose Remove leading minus sign from number
# fn_tag dnRemoveLeadingMinus prints Edited number
# fn_tag dnRemoveLeadingMinus returns NIL
# fn_tag dnRemoveLeadingMinus param number purpose Number to be edited
# fn_tag dnRemoveLeadingMinus param number required yes
# fn_tag dnRemoveLeadingMinus param number multipart no
# fn_tag dnRemoveLeadingMinus param number type number
dnRemoveLeadingMinus() { echo "${1/#-/}"; }
# Function: dnReport    {{{1
# Report success or failure of operation
#   params: 1 - exit status of operation ('0' = success)
#   prints: 'OK.'|'Failed.'
#   return: nil
# fn_tag dnReport purpose Report success or failure of operation
# fn_tag dnReport prints Feedback: 'OK.' or 'Failed.'
# fn_tag dnReport returns NIL
# fn_tag dnReport param exit_status purpose Exit status of operation ('0'=success)
# fn_tag dnReport param exit_status required yes
# fn_tag dnReport param exit_status multipart no
# fn_tag dnReport param exit_status type boolean
dnReport() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No exit status provided"
	case ${1} in
	0) echo 'OK.' ;;
	*) echo 'Failed.' ;;
	esac
}
# Function: dnResetIFS    {{{1
# Reset IFS variable to default value
#   params: nil
#   prints: nil
#   return: nil
#   note:   default IFS value is space+tab+newline
#   note:   in many cases can avoid need to reset variable
#           by changing it in a subshell
#   note:   have to work around shell behaviour of discarding
#           trailing newlines when returning output from
#           command substitution
#   usage:  # do in current shell
#           IFS=$'\n'
#           ## do operations relying on changed IFS value
#           dnResetIFS
#           # do in subshell
#           (
#           IFS=$'\n'
#           ## do operations relying on changed IFS value
#           )
# fn_tag dnResetIFS purpose Reset IFS variable to default value
# fn_tag dnResetIFS prints NIL
# fn_tag dnResetIFS returns NIL
# fn_tag dnResetIFS usage # do in current shell
# fn_tag dnResetIFS usage IFS=$'\n'
# fn_tag dnResetIFS usage ## do operations relying on changed IFS value
# fn_tag dnResetIFS usage dnResetIFS
# fn_tag dnResetIFS usage # ------------------------------
# fn_tag dnResetIFS usage # do in subshell instead
# fn_tag dnResetIFS usage ( IFS=$'\n' ; ## do operations relying on changed IFS value ; )
# fn_tag dnResetIFS note Default IFS value is space+tab+newline
# fn_tag dnResetIFS note In many cases can avoid need to reset IFS by changing it in a subshell
# fn_tag dnResetIFS note By default trailing newlines are stripped from command substitutions
# fn_tag dnResetIFS note In this function have to work around newline stripping behaviour
dnResetIFS() {
	IFS="$(
		printf ' \t\n'
		echo a
	)"
	IFS="${IFS%a}"
}
# Function: dnRightPad    {{{1
# Right pad a string
#   params: 1 - number of characters to pad
#           2 - string to right pad (optional, default = empty string)
#           3 - character to pad with (optional, default = space)
#   prints: padded string
#   return: nil
# fn_tag dnRightPad purpose Right pad a string
# fn_tag dnRightPad prints Padded string
# fn_tag dnRightPad returns NIL
# fn_tag dnRightPad param pad-length purpose Length that string is to be padded to (i.e., target string length)
# fn_tag dnRightPad param pad-length required yes
# fn_tag dnRightPad param pad-length multipart no
# fn_tag dnRightPad param pad-length type integer
# fn_tag dnRightPad param string purpose String to be padded
# fn_tag dnRightPad param string required no
# fn_tag dnRightPad param string multipart no
# fn_tag dnRightPad param string type string
# fn_tag dnRightPad param string default empty string
# fn_tag dnRightPad param string note If string is longer than pad-length then supplied string printed unchanged
# fn_tag dnRightPad param pad-character purpose Character to pad with
# fn_tag dnRightPad param pad-character required no
# fn_tag dnRightPad param pad-character multipart no
# fn_tag dnRightPad param pad-character type string
# fn_tag dnRightPad param pad-character default <Space>
dnRightPad() {
	# check params
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No pad length provided"
	local target_len string char i pad_len str_len
	target_len=${1} string="${2:-}" char="${3:-' '}" i='' pad_len='' str_len=''
	[ -z "${char}" ] && char=' '
	char="${char:0:1}" # ensure single char
	# determine how much to pad
	str_len=$(dnStrLen "${string}")
	pad_len=$((target_len - str_len))
	# pad
	for ((i = 0; i < pad_len; i++)); do
		string="${string}${char}"
	done
	# done
	echo "${string}"
}
# Function: dnSecondsSinceEpoch    {{{1
# Get time since epoch in seconds
#   params: nil
#   prints: seconds since epoch
#   return: nil
# fn_tag dnSecondsSinceEpoch purpose Get number of seconds since unix epoch
# fn_tag dnSecondsSinceEpoch prints Seconds since epoch
# fn_tag dnSecondsSinceEpoch returns NIL
dnSecondsSinceEpoch() { date '+%s'; }
# Function: dnSelect    {{{1
# Select option from list
#   params: 1 - resource file
#   prints: selection -- option or index based on user preference
#   return: boolean (0=selection made|1=no selection made)
#           can also evaluate success on printed output
#           -- any output=success, empty string=failure
#   resource: file consists of name value pairs with whitespace delimiter
#             names are --
#               title:  menu title [optional] (default=script_name)
#               prompt: menu prompt [optional] (default='Select option: ')
#               return: 'option'|'index' [optional] (default='option')
#               option: menu option [required]
#   warning: quote marks will be stripped from options
# fn_tag dnSelect purpose Select option from console list
# fn_tag dnSelect prints User list selection -- option string or index depending on user preference
# fn_tag dnSelect returns Whether selection made (Boolean)
# fn_tag dnSelect param resource purpose Resource file
# fn_tag dnSelect param resource required yes
# fn_tag dnSelect param resource multipart no
# fn_tag dnSelect param resource type path
# fn_tag dnSelect param resource note File consists of name-value pairs with whitespace delimiter
# fn_tag dnSelect param resource note Name 'title' = menu title [optional] (default=script_name)
# fn_tag dnSelect param resource note Name 'prompt' = menu prompt [optional] (default='Select option: ')
# fn_tag dnSelect param resource note Name 'return' = 'option'|'index' [optional] (default='option')
# fn_tag dnSelect param resource note Name 'option' = a menu option [required, multiple]
# fn_tag dnSelect param resource note Warning: quote marks will be stripped from options
dnSelect() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local title prompt msg
	title="$(basename "$0")" prompt='Select option: ' msg=''
	local return_val valid_return_vals resources
	return_val='option' valid_return_vals='index option' resources=''
	local -a options=()
	resources="$(dnNormalisePath "${1}")"
	msg="${FUNCNAME[0]}: Invalid resource filename"
	[ -r "${resources}" ] || dnEndScript 1 "${msg}"
	local retval name val option pick_file
	retval='' name='' val='' option='' pick_file=''
	msg="${FUNCNAME[0]}: Unable to create temporary file"
	pick_file="$(dnTempFile)" || dnEndScript 1 "${msg}"
	dnTempTrap "${pick_file}"
	# process resources file
	while read -r name val; do
		if [ -n "${val+x}" ]; then
			# option *may* have two values needing stripping
			[ "${name}" != 'option' ] &&
				val="$(dnStripEnclosingQuotes "${val}")"
			# load vars depending on name
			case ${name} in
			'title') title="${val}" ;;
			'prompt') prompt="${val}" ;;
			'return')
				dnElementInList "${val}" "${valid_return_vals}" &&
					return_val="${val}"
				;;
			'option')
				# internal possessive apostrophes can cause problems
				options+=("$(dnStripQuotes "${val}")")
				;;
			esac
		fi
	done <"${resources}"
	# prepare for selection
	local old_PS3 err_msg
	old_PS3="${PS3}" err_msg='Invalid option number -- try again'
	PS3="${prompt}: " REPLY=
	title="$(dnUppercase "${title}")"
	prompt="$(dnStripEnclosingSpaces "${prompt}")"
	prompt="${prompt/%:/}" # strip trailing colon
	msg="\nError: Invalid option number.  Try again.\n"
	# make selection
	while [ -z "${option}" ]; do
		echo "${title}" 1>&2
		select option in "${options[@]}"; do break; done
		[ -z "${option}" ] && dnErrorStderr "${err_msg}" 1>&2
	done
	PS3="${old_PS3}"
	index="$((REPLY - 1))" # 'REPLY' set by 'select' command
	[ -n "${option+x}" ] || return 1
	# decide upon, and return, return value
	case ${return_val} in
	'index') retval="${index}" ;;
	'option') retval="${option}" ;;
	esac
	[ -n "${retval+x}" ] || return 1
	echo "${retval}"
}
# Function: dnSelectDlg    {{{1
# Select option from dialog
#   params: 1 - resource file
#   prints: selection -- option or index based on user preference
#   return: boolean (0=selection made|1=no selection made)
#           can also evaluate success on printed output
#           -- any output=success, empty string=failure
#   resource: file consists of name value pairs with whitespace delimiter
#             names are --
#               title:  menu title [optional] (default=script_name)
#               prompt: menu prompt [optional] (default='Select option: ')
#               return: 'option'|'index' [optional] (default='option')
#               option: menu option [required]
#   warning: quote marks will be stripped from options
# fn_tag dnSelectDlg purpose Select option from GUI list
# fn_tag dnSelectDlg prints User list selection -- option string or index depending on user preference
# fn_tag dnSelectDlg returns Whether selection made (Boolean)
# fn_tag dnSelectDlg param resource purpose Resource file
# fn_tag dnSelectDlg param resource required yes
# fn_tag dnSelectDlg param resource multipart no
# fn_tag dnSelectDlg param resource type path
# fn_tag dnSelectDlg param resource note File consists of name-value pairs with whitespace delimiter
# fn_tag dnSelectDlg param resource note Name 'title' = menu title [optional] (default=script_name)
# fn_tag dnSelectDlg param resource note Name 'prompt' = menu prompt [optional] (default='Select option: ')
# fn_tag dnSelectDlg param resource note Name 'return' = 'option'|'index' [optional] (default='option')
# fn_tag dnSelectDlg param resource note Name 'option' = a menu option [required, multiple]
# fn_tag dnSelectDlg param resource note Warning: quote marks will be stripped from options
dnSelectDlg() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local prompt msg title
	prompt='Select option: ' msg='' title=''
	title="$(basename "$0")"
	local return_val valid_return_vals
	return_val='option' valid_return_vals='index option'
	local -a tags=() options=()
	local resources
	resources="$(dnNormalisePath "${1}")"
	msg="${FUNCNAME[0]}: Invalid resource filename"
	[ -r "${resources}" ] || dnEndScript 1 "${msg}"
	local dlg_type cmd i pick retval
	dlg_type='' cmd='' i='' pick='' retval=''
	local menu_count menu_height menu_width
	menu_count=0 menu_height=0 menu_width=0
	local height_char_pixels width_char_pixels
	height_char_pixels=25 width_char_pixels=9 # char -> pixels
	local option_length option_length_max
	option_length='' option_length_max=0
	local name val tag option pick_file
	name='' val='' tag='' option='' pick_file=''
	msg="${FUNCNAME[0]}: Unable to create temporary file"
	pick_file="$(dnTempFile)" || dnEndScript 1 "${msg}"
	dnTempTrap "${pick_file}"
	# process resources file
	while read -r name val; do
		if [ -n "${val+x}" ]; then
			# option *may* have two values needing stripping
			[ "${name}" != 'option' ] &&
				val="$(dnStripEnclosingQuotes "${val}")"
			# load vars depending on name
			case ${name} in
			'title') title="${val}" ;;
			'prompt') prompt="${val}" ;;
			'return')
				dnElementInList "${val}" "${valid_return_vals}" &&
					return_val="${val}"
				;;
			'option')
				option="${val}"
				# internal possessive apostrophes can cause problems
				options+=("$(dnStripQuotes "${option}")")
				tags+=("${#tags[*]}")
				;;
			esac
		fi
	done <"${resources}"
	# get dialog type
	dlg_type="$(dnLowercase "$(dnDialogType)")" || dnEndScript 1 \
		"${FUNCNAME[0]}: Unable to locate dialog command" \
		'Perhaps this is a non-graphical environment?'
	# set menu dimensions
	for ((i = 0; i < ${#tags[*]}; i++)); do # get max option length
		option_length=$(dnStrLen "${options[i]}")
		[ "${option_length}" -gt "${option_length_max}" ] &&
			option_length_max=${option_length}
	done
	case ${dlg_type} in
	'kdialog' | 'zenity')
		# menu dimensions in pixels
		menu_height=$(((${#tags[*]} + 5) * height_char_pixels))
		menu_width=$(((option_length_max + 5) * width_char_pixels))
		;;
	'dialog')
		# dialog uses sensible defaults so no changes necessary
		;;
	esac
	# build dialog command
	case ${dlg_type} in
	'kdialog')
		cmd="kdialog --geometry ${menu_width}x${menu_height}"
		cmd="${cmd} --title '${title}' --menu '${prompt}'"
		;;
	'zenity')
		cmd="zenity --list --text='${prompt}' --title='${title}'"
		cmd="${cmd} --width=${menu_width} --height=${menu_height}"
		cmd="${cmd} --hide-column=1 --column='Tags' --column='Options'"
		;;
	'dialog')
		cmd="dialog --stdout --title '${title}' --menu '${prompt}'"
		cmd="${cmd} ${menu_height} ${menu_width} ${menu_count}"
		;;
	esac
	for ((i = 0; i < ${#tags[*]}; i++)); do
		cmd="${cmd} '${tags[i]}' '${options[i]}'"
	done
	cmd="${cmd} 1>${pick_file}" # capture output in temporary file
	# make selection
	eval "${cmd}"
	pick="$(cat "${pick_file}")"
	rm -f "${pick_file}"
	[ -n "${pick+x}" ] || return 1
	# decide upon, and return, return value
	# we have tag in variable 'pick'
	# finds first match (if duplicate tags)
	for ((i = 0; i < ${#tags[*]}; i++)); do
		if [ "${tags[i]}" = "${pick}" ]; then
			case ${return_val} in
			'index') retval="${i}" ;;
			'option') retval="${options[i]}" ;;
			esac
			break
		fi
	done
	[ -n "${retval+x}" ] || return 1
	echo "${retval}"
}
# Function: dnSelectTagDlg    {{{1
# Select option from dialog
#   params: 1 - resource file
#   prints: selection -- tag, option or index based on user preference
#   return: boolean (0=selection made|1=no selection made)
#           can also evaluate success on printed output
#           -- any output=success, empty string=failure
#   resource: file consists of name value pairs with whitespace delimiter
#             names are --
#               title:  menu title [optional] (default=script_name)
#               prompt: menu prompt [optional] (default='Select option: ')
#               return: 'tag'|'option'|'index' [optional] (default='tag')
#               option: menu option [required]
#                       =tag[whitespace]option
#   warning: quote marks will be stripped from tags and options
#   warning: tags must not contain whitespace
#   warning: tags must be unique or results may be unpredictable
# fn_tag dnSelectTagDlg purpose Select option from GUI list
# fn_tag dnSelectTagDlg prints User list selection -- option tag, string or index depending on user preference
# fn_tag dnSelectTagDlg returns Whether selection made (Boolean)
# fn_tag dnSelectTagDlg param resource purpose Resource file
# fn_tag dnSelectTagDlg param resource required yes
# fn_tag dnSelectTagDlg param resource multipart no
# fn_tag dnSelectTagDlg param resource type path
# fn_tag dnSelectTagDlg param resource note File consists of name-value pairs with whitespace delimiter
# fn_tag dnSelectTagDlg param resource note Name 'title' = menu title [optional] (default=script_name)
# fn_tag dnSelectTagDlg param resource note Name 'prompt' = menu prompt [optional] (default='Select option: ')
# fn_tag dnSelectTagDlg param resource note Name 'return' = 'tag'|'option'|'index' [optional] (default='tag')
# fn_tag dnSelectTagDlg param resource note Name 'option' = a menu option [required, multiple]
# fn_tag dnSelectTagDlg param resource note Name 'option' format =tag[whitespace]option
# fn_tag dnSelectTagDlg param resource note Warning: quote marks will be stripped from tags and options
# fn_tag dnSelectTagDlg param resource note Warning: tags must not contain whitespace
# fn_tag dnSelectTagDlg param resource note Warning: tags must be unique or results may be unpredictable
dnSelectTagDlg() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local title prompt msg
	title="$(basename "$0")" prompt='Select option: ' msg=''
	local return_val valid_return_vals
	return_val='tag' valid_return_vals='index tag option'
	local -a tags=() options=()
	local resources
	resources="$(dnNormalisePath "${1}")"
	msg="${FUNCNAME[0]}: Invalid resource filename"
	[ -r "${resources}" ] || dnEndScript 1 "${msg}"
	local dlg_type cmd i pick retval
	dlg_type='' cmd='' i='' pick='' retval=''
	local menu_count menu_height menu_width
	menu_count=0 menu_height=0 menu_width=0
	local height_char_pixels width_char_pixels
	height_char_pixels=25 width_char_pixels=9 # char -> pixels
	local option_length option_length_max
	option_length='' option_length_max=0
	local name val tag option pick_file
	name='' val='' tag='' option='' pick_file=''
	msg="${FUNCNAME[0]}: Unable to create temporary file"
	pick_file="$(dnTempFile)" || dnEndScript 1 "${msg}"
	dnTempTrap "${pick_file}"
	# process resources file
	while read -r name val; do
		if [ -n "${val+x}" ]; then
			# option *may* have two values needing stripping
			[ "${name}" != 'option' ] &&
				val="$(dnStripEnclosingQuotes "${val}")"
			# load vars depending on name
			case ${name} in
			'title') title="${val}" ;;
			'prompt') prompt="${val}" ;;
			'return')
				dnElementInList "${val}" "${valid_return_vals}" &&
					return_val="${val}"
				;;
			'option')
				[[ $val =~ ^[[:space:]]*([^[:space:]]+)[[:space:]]+(.*)$ ]]
				tag="${BASH_REMATCH[1]}"
				option="${BASH_REMATCH[2]}"
				# internal possessive apostrophes can cause problems
				tag="$(dnStripQuotes "${tag}")"
				tags+=("${tag}")
				option="$(dnStripQuotes "${option}")"
				options+=("${option}")
				;;
			esac
		fi
	done <"${resources}"
	# get dialog type
	dlg_type="$(dnLowercase "$(dnDialogType)")" || dnEndScript 1 \
		"${FUNCNAME[0]}: Unable to locate dialog command" \
		'Perhaps this is a non-graphical environment?'
	# set menu dimensions
	for ((i = 0; i < ${#tags[*]}; i++)); do # get max option length
		option_length=$(dnStrLen "${options[i]}")
		[ "${option_length}" -gt "${option_length_max}" ] &&
			option_length_max=${option_length}
	done
	case ${dlg_type} in
	'kdialog' | 'zenity')
		# menu dimensions in pixels
		menu_height=$(((${#tags[*]} + 5) * height_char_pixels))
		menu_width=$(((option_length_max + 5) * width_char_pixels))
		;;
	'dialog')
		# dialog uses sensible defaults so no changes necessary
		;;
	esac
	# build dialog command
	case ${dlg_type} in
	'kdialog')
		cmd="kdialog --geometry ${menu_width}x${menu_height}"
		cmd="${cmd} --title '${title}' --menu '${prompt}'"
		;;
	'zenity')
		cmd="zenity --list --text='${prompt}' --title='${title}'"
		cmd="${cmd} --width=${menu_width} --height=${menu_height}"
		cmd="${cmd} --hide-column=1 --column='Tags' --column='Options'"
		;;
	'dialog')
		cmd="dialog --stdout --title '${title}' --menu '${prompt}'"
		cmd="${cmd} ${menu_height} ${menu_width} ${menu_count}"
		;;
	esac
	for ((i = 0; i < ${#tags[*]}; i++)); do
		cmd="${cmd} '${tags[i]}' '${options[i]}'"
	done
	cmd="${cmd} 1>${pick_file}" # capture output in temporary file
	# make selection
	eval "${cmd}"
	pick="$(cat "${pick_file}")"
	rm -f "${pick_file}"
	[ -n "${pick+x}" ] || return 1
	# decide upon, and return, return value
	# we have tag in variable 'pick'
	# finds first match (if duplicate tags)
	for ((i = 0; i < ${#tags[*]}; i++)); do
		if [ "${tags[i]}" = "${pick}" ]; then
			case ${return_val} in
			'tag') retval="${pick}" ;;
			'index') retval="${i}" ;;
			'option') retval="${options[i]}" ;;
			esac
			break
		fi
	done
	[ -n "${retval+x}" ] || return 1
	echo "${retval}"
}
# Function: dnShowIFS    {{{1
# Display current value of internal field separator variable IFS
#   params: 1+ - messages to display before IFS output
#   prints: value of IFS
#   return: nil
#   note:   use utility 'od' ("octal dump")
#   note:   default value of IFS is space + (horizontal) tab + newline
#   note:   option combination causes value to display in three formats
#   note:   uses format 'a' to display named characters
#           default output: ' sp  ht  nl'
#   note:   uses format 'o1' to display octal values
#           the '1' forces interpretation of each input byte as a number
#           default output: '040 011 012'
#   note:   uses format 'c' to display ascii character (or backslash escape)
#           default output: '     \t  \n
# fn_tag dnShowIFS purpose Display current value of internal field separator variable IFS
# fn_tag dnShowIFS prints Value of IFS variable in three display formats (see Notes)
# fn_tag dnShowIFS returns NIL
# fn_tag dnShowIFS usage dnShowIFS "Current value of IFS:"
# fn_tag dnShowIFS note Uses utility 'od' ("octal dump")
# fn_tag dnShowIFS note Default value of IFS is: space + (horizontal) tab + newline
# fn_tag dnShowIFS note Option combination causes value to display in three formats
# fn_tag dnShowIFS note Uses format 'a' to display named characters; default is ' sp  ht  nl'
# fn_tag dnShowIFS note Uses format 'o1' to display octal values; default is '040 011 012'
# fn_tag dnShowIFS note Uses format 'c' to display ascii character (or backslash escape); default is '     \t  \n'
# fn_tag dnShowIFS param message purpose Message(s) to show before displaying IFS value
# fn_tag dnShowIFS param message required no
# fn_tag dnShowIFS param message multipart yes
# fn_tag dnShowIFS param message type string
dnShowIFS() {
	# display any messages
	while [ ${#} -gt 0 ]; do
		echo "${1}"
		shift
	done
	# display value of variable IFS
	echo -n "${IFS}" | od --format=a --format=o1 --format=c
}
# Function: dnSplitStringIntoArray    {{{1
# Utility array splitting string into an array
#   params: 1 - string [string]
#           2 - delimiter <optional> <default=_> [string]
#   prints: array definition
#   return: nil
#   usage:  eval declare -a array_var="$( dnSplitStringIntoArray "my_data" )"
# fn_tag dnSplitStringIntoArray purpose Split a string into an array
# fn_tag dnSplitStringIntoArray prints array definition
# fn_tag dnSplitStringIntoArray returns NIL
# fn_tag dnSplitStringIntoArray usage eval declare -a array_var="$( dnSplitStringIntoArray "my_data" )"
# fn_tag dnSplitStringIntoArray note Requires function 'dnUseArray'
# fn_tag dnSplitStringIntoArray param string purpose String to be split into array elements
# fn_tag dnSplitStringIntoArray param string required yes
# fn_tag dnSplitStringIntoArray param string multipart no
# fn_tag dnSplitStringIntoArray param string type string
# fn_tag dnSplitStringIntoArray param delimiter purpose Character(s) separating elements
# fn_tag dnSplitStringIntoArray param delimiter required no
# fn_tag dnSplitStringIntoArray param delimiter multipart no
# fn_tag dnSplitStringIntoArray param delimiter type string
# fn_tag dnSplitStringIntoArray param delimiter default _
dnSplitStringIntoArray() {
	# variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string delim count i
	string="${1}" delim="${2:-'_'}" count=0 i=''
	local -a array=()
	# loop through string
	count=$(awk -F "${delim}" '{ print NF }' <<<"${string}")
	for ((i = 1; i <= count; i++)); do
		array+=("$(awk -v EN=${i} -F "${delim}" '{ print $EN }' <<<"${string}")")
	done
	# return array
	dnUseArray array
}

# Function: dnStackTrace    {{{1
# Print stack trace
#   option: s - number of function calls to skip
#               (optional, default=1)
#   option: p - prepend (optional, default='')
#   params: nil
#   prints: stack trace (string)
#   return: nil
#   note:   prints function calls recursively from the
#             function that called this one to the first
#             function called from the script ('main')
#           for each function prints function name,
#             file and line number of function call
#           by default skips the most recent function
#             call; the assumption is that the most recent
#             function call is from an exit function to the
#             stack trace -- this function call is ignored;
#             the function call to the exit function is the
#             first to be printed because it was presumably
#             triggered by the error of interest
#   usage:  # raw output
#           dnStackTrace
#           # prepend string outside stack trace function
#           trace="$( dnStackTrace )"
#           (
#               IFS=$'\n'  # brackets create subshell limiting scope
#                          # of change to IFS value
#               for i in $( echo "${trace}" ) ; do
#                   # anything provided it doesn't mind IFS being a
#                   # newline instead of its default value of whitespace
#                   echo "Fatal error: ${i}"
#               done
#           )
#           # prepend string using stack trace function
#           dnStackTrace -p "Fatal error: "
# fn_tag dnStackTrace purpose Print stack trace
# fn_tag dnStackTrace prints Stack trace (String)
# fn_tag dnStackTrace returns NIL
# fn_tag dnStackTrace usage # raw output
# fn_tag dnStackTrace usage dnStackTrace
# fn_tag dnStackTrace usage # prepend string using stack trace function
# fn_tag dnStackTrace usage dnStackTrace -p "Fatal error: "
# fn_tag dnStackTrace usage # prepend string outside stack trace function
# fn_tag dnStackTrace usage trace="$( dnStackTrace)"
# fn_tag dnStackTrace usage (
# fn_tag dnStackTrace usage # brackets create subshell limiting scope of change to IFS value
# fn_tag dnStackTrace usage for i in $( echo "${trace}" ) ; do
# fn_tag dnStackTrace usage # anything provided it doesn't mind IFS being a
# fn_tag dnStackTrace usage # newline instead of its default value of whitespace
# fn_tag dnStackTrace usage echo "Fatal error: ${i}"
# fn_tag dnStackTrace usage done
# fn_tag dnStackTrace usage )
# fn_tag dnStackTrace note Prints details of function calls recursively from most recent
# fn_tag dnStackTrace note For each call prints name of function containing call, name of file containing calling function, and line number of function call
# fn_tag dnStackTrace option s purpose Number of function calls to skip when outputting details
# fn_tag dnStackTrace option s required no
# fn_tag dnStackTrace option s multiple no
# fn_tag dnStackTrace option s type integer
# fn_tag dnStackTrace option s default 1
# fn_tag dnStackTrace option s note Most recent call is assumed to be a generic exit/error function calling this function
# fn_tag dnStackTrace option s note Default skips this call so first call displayed is call to exit/error function
# fn_tag dnStackTrace option p purpose Prefix string to prepend to each function call in output
# fn_tag dnStackTrace option p required no
# fn_tag dnStackTrace option p multiple no
# fn_tag dnStackTrace option p type string
# fn_tag dnStackTrace option p note Default is empty string, i.e., no prefix string
dnStackTrace() {
	# variables
	local frame max_frame max_len prepend skip caller_output
	frame=0 max_frame=0 max_len=0 prepend='' skip=1 caller_output=''
	local -a fns=() lines=() files=() caller_info=()
	# process options
	while getopts ':s:p:' opt; do
		case ${opt} in
		's') dnValidPosInteger "${OPTARG}" && skip="${OPTARG}" ;;
		'p') prepend="${OPTARG}" ;;
		*) echo "${FUNCNAME[0]}: Invalid option '${opt}'" ;;
		esac
	done
	shift $((OPTIND - 1))
	# process stack frames
	caller_output="$(caller "${frame}")"
	IFS=' ' read -r -a caller_info <<<"${caller_output}"
	while [ ${#caller_info[@]} -gt 0 ]; do
		# work out maximum frame number as we go
		max_frame=${frame}
		# load individual stack trace elements into arrays
		lines+=("${caller_info[0]}")
		fns+=("${caller_info[1]}")
		files+=("${caller_info[@]:2}")
		((frame++)) || true
		caller_output="$(caller "${frame}")"
		IFS=' ' read -r -a caller_info <<<"${caller_output}"
	done
	# work out where to start listing function calls
	# • skip cannot be greater than last function call
	test "${skip}" -gt "${max_frame}" && skip="${max_frame}"
	# get maximum function name length
	for ((i = skip; i < ${#fns[@]}; i++)); do
		test ${#fns[i]} -gt "${max_len}" && max_len=${#fns[i]}
	done
	# assemble and output stack trace
	for ((i = skip; i < ${#fns[@]}; i++)); do
		echo -n "${prepend}$(printf %-"${max_len}"s "${fns[i]}")"
		echo " in ${files[i]}: ${lines[i]}"
	done
}

# Function: dnStandardiseBoolean    {{{1
# Standardise flag value to 0|1
#   params: 1 - flag value [required]
#   prints: boolean (0=true|1=false) if match standard value
#           input value unchanged if no match to standard value
#   return: nil
# fn_tag dnStandardiseBoolean purpose Standardise truth value to '0'|'1'
# fn_tag dnStandardiseBoolean prints New boolean value if able to convert (Boolean) or unchanged parameter if not
# fn_tag dnStandardiseBoolean returns NIL
# fn_tag dnStandardiseBoolean param value purpose True /false value to standardise as boolean
# fn_tag dnStandardiseBoolean param value required yes
# fn_tag dnStandardiseBoolean param value multipart no
# fn_tag dnStandardiseBoolean param value type string
dnStandardiseBoolean() {
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	local flag
	flag="$(dnLowercase "${1}")"
	# standardise
	case ${flag} in
	'y' | 'yes' | 't' | 'true' | 'on' | '0') flag=0 ;;
	'n' | 'no' | 'f' | 'false' | 'off' | '1') flag=1 ;;
	*) true ;; # unchanged
	esac
	# return result and indicate outcome
	echo "${flag}"
}
# Function: dnStandardiseControl    {{{1
# Standardise flag value to 0|1
#   params: 1 - flag value [required]
#   prints: boolean (0=on|1=off) if match standard value
#           input value unchanged if no match to standard value
#   return: nil
# fn_tag dnStandardiseControl purpose Standardise control term (verb) as boolean
# fn_tag dnStandardiseControl prints Standardised term (Boolean) if converted or unchanged parameter if not
# fn_tag dnStandardiseControl returns NIL
# fn_tag dnStandardiseControl note Converts term such as 'enable', 'halt' and 'begin'
# fn_tag dnStandardiseControl param value purpose Control term to standardise
# fn_tag dnStandardiseControl param value required yes
# fn_tag dnStandardiseControl param value multipart no
# fn_tag dnStandardiseControl param value type string
dnStandardiseControl() {
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local flag
	flag="$(dnLowercase "${1}")"
	# standardise
	case ${flag} in
	'on' | 'enable' | 'activate' | 'start' | 'trigger' | 'actuate' | 'begin' | 'go' | '0')
		flag=0
		;;
	'off' | 'disable' | 'inactivate' | 'stop' | 'halt' | 'end' | '1')
		flag=1
		;;
	*) true ;; # unchanged
	esac
	# return result
	echo "${flag}"
}
# }}}1
# Function: dnStrLen    {{{1
# Length of string
#   params: 1 - string
#   prints: string length
#   return: nil
# fn_tag dnStrLen purpose Calculate string length
# fn_tag dnStrLen prints String length
# fn_tag dnStrLen returns NIL
# fn_tag dnStrLen param string purpose String to measure
# fn_tag dnStrLen param string required yes
# fn_tag dnStrLen param string multipart no
# fn_tag dnStrLen param string type string
dnStrLen() { echo "${#1}"; }
# Function: dnStringContains    {{{1
# Whether string contains substring
#   params: 1 - string
#           2 - substring
#           3 - whole words (boolean) [default=true]
#   prints: nil
#   return: boolean (0=contains|1=does not contain)
# fn_tag dnStringContains purpose Return whether string contains a given substring
# fn_tag dnStringContains prints NIL
# fn_tag dnStringContains returns Whether string contains substring (Boolean)
# fn_tag dnStringContains param string purpose String to be searched
# fn_tag dnStringContains param string required yes
# fn_tag dnStringContains param string multipart no
# fn_tag dnStringContains param string type string
# fn_tag dnStringContains param substring purpose String to search for
# fn_tag dnStringContains param substring required yes
# fn_tag dnStringContains param substring multipart no
# fn_tag dnStringContains param substring type string
# fn_tag dnStringContains param whole-words purpose Whether searching for whole words only
# fn_tag dnStringContains param whole-words required no
# fn_tag dnStringContains param whole-words multipart no
# fn_tag dnStringContains param whole-words type boolean
# fn_tag dnStringContains param whole-words value 0
# fn_tag dnStringContains param whole-words value 1
# fn_tag dnStringContains param whole-words default 0
dnStringContains() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No substring provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string substring whole_words
	string="${1}" substring="${2}" whole_words=${3:-'0'}
	dnFlagTrue "${whole_words}" && substring="\b${substring}\b"
	[[ $string =~ $substring ]]
	return ${?}
}
# Function: dnStringEqual    {{{1
# Compare two strings to see if both lexicographically equal
#   params: 1 - string
#           2 - string
#   prints: nil
#   return: boolean (0=equal|1=not equal)
# fn_tag dnStringEqual purpose Returns whether two string are lexicographically (case-sensitive) equal
# fn_tag dnStringEqual prints NIL
# fn_tag dnStringEqual returns Whether string comparison successful (Boolean)
# fn_tag dnStringEqual param string-A purpose First string to be compared
# fn_tag dnStringEqual param string-A required yes
# fn_tag dnStringEqual param string-A multipart no
# fn_tag dnStringEqual param string-A type string
# fn_tag dnStringEqual param string-B purpose Second string to be compared
# fn_tag dnStringEqual param string-B required yes
# fn_tag dnStringEqual param string-B multipart no
# fn_tag dnStringEqual param string-B type string
dnStringEqual() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: Second string not provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: First string not provided"
	return "$([ "${1}" = "${2}" ])"
}
# Function: dnStringGreaterThan    {{{1
# Compare two strings to see if first is lexicographically greater
#   params: 1 - string
#           2 - string
#   prints: nil
#   return: boolean (0=greater than|1=not)
# fn_tag dnStringGreaterThan purpose Returns whether first string is lexicographically greater than second
# fn_tag dnStringGreaterThan prints NIL
# fn_tag dnStringGreaterThan returns Whether string comparison successful (Boolean)
# fn_tag dnStringGreaterThan param string-A purpose First string to be compared
# fn_tag dnStringGreaterThan param string-A required yes
# fn_tag dnStringGreaterThan param string-A multipart no
# fn_tag dnStringGreaterThan param string-A type string
# fn_tag dnStringGreaterThan param string-B purpose Second string to be compared
# fn_tag dnStringGreaterThan param string-B required yes
# fn_tag dnStringGreaterThan param string-B multipart no
# fn_tag dnStringGreaterThan param string-B type string
dnStringGreaterThan() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: Second string not provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: First string not provided"
	# opposite of less than or equal
	dnStringLessThanOrEqual "${1}" "${2}" && return 1
	return 0
}
# Function: dnStringGreaterThanOrEqual    {{{1
# Compare two strings to see if first is lexicographically greater or equal
#   params: 1 - string
#           2 - string
#   prints: nil
#   return: boolean (0=greater than or equal|1=not)
# fn_tag dnStringGreaterThanOrEqual purpose Returns whether first string is lexicographically greater than or equal to second
# fn_tag dnStringGreaterThanOrEqual prints NIL
# fn_tag dnStringGreaterThanOrEqual returns Whether string comparison successful (Boolean)
# fn_tag dnStringGreaterThanOrEqual param string-A purpose First string to be compared
# fn_tag dnStringGreaterThanOrEqual param string-A required yes
# fn_tag dnStringGreaterThanOrEqual param string-A multipart no
# fn_tag dnStringGreaterThanOrEqual param string-A type string
# fn_tag dnStringGreaterThanOrEqual param string-B purpose Second string to be compared
# fn_tag dnStringGreaterThanOrEqual param string-B required yes
# fn_tag dnStringGreaterThanOrEqual param string-B multipart no
# fn_tag dnStringGreaterThanOrEqual param string-B type string
dnStringGreaterThanOrEqual() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: Second string not provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: First string not provided"
	# first, catch if equal
	dnStringEqual "${1}" "${2}" && return 0
	# last, rule out less than (or equal)
	dnStringLessThanOrEqual "${1}" "${2}" && return 1
	return 0
}

# }}}1
# Function: dnStringLessThan    {{{1
# Compare two strings to see if first is lexicographically less than
#   params: 1 - string
#           2 - string
#   prints: nil
#   return: boolean (0=less than|1=not)
# fn_tag dnStringLessThan purpose Returns whether first string is lexicographically less than second
# fn_tag dnStringLessThan prints NIL
# fn_tag dnStringLessThan returns Whether string comparison successful (Boolean)
# fn_tag dnStringLessThan param string-A purpose First string to be compared
# fn_tag dnStringLessThan param string-A required yes
# fn_tag dnStringLessThan param string-A multipart no
# fn_tag dnStringLessThan param string-A type string
# fn_tag dnStringLessThan param string-B purpose Second string to be compared
# fn_tag dnStringLessThan param string-B required yes
# fn_tag dnStringLessThan param string-B multipart no
# fn_tag dnStringLessThan param string-B type string
dnStringLessThan() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: Second string not provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: First string not provided"
	# first, ensure less than or equal
	dnStringLessThanOrEqual "${1}" "${2}" || return 1
	# last, ensure not equal
	dnStringEqual "${1}" "${2}" && return 1
	return 0
}
# Function: dnStringLessThanOrEqual    {{{1
# Compare two strings to see if first is lexicographically less or equal
#   params: 1 - string
#           2 - string
#   prints: nil
#   return: boolean (0=less than or equal|1=not)
# fn_tag dnStringLessThanOrEqual purpose Returns whether first string is lexicographically less than or equal to second
# fn_tag dnStringLessThanOrEqual prints NIL
# fn_tag dnStringLessThanOrEqual returns Whether string comparison successful (Boolean)
# fn_tag dnStringLessThanOrEqual param string-A purpose First string to be compared
# fn_tag dnStringLessThanOrEqual param string-A required yes
# fn_tag dnStringLessThanOrEqual param string-A multipart no
# fn_tag dnStringLessThanOrEqual param string-A type string
# fn_tag dnStringLessThanOrEqual param string-B purpose Second string to be compared
# fn_tag dnStringLessThanOrEqual param string-B required yes
# fn_tag dnStringLessThanOrEqual param string-B multipart no
# fn_tag dnStringLessThanOrEqual param string-B type string
dnStringLessThanOrEqual() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: Second string not provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: First string not provided"
	return "$(echo -e "${1}\n${2}" | sort --check 2>/dev/null)"
}
# Function: dnStripComment    {{{1
# Strip comment from line
#   params: 1 - line of text
#           2 - strip trailing spaces (boolean: 0|1 = true|false, default = 0)
#           3 - comment marker (default = '#')
#   prints: line after comment stripped
#   return: nil
#   invoke: stripped="$( dnStripComment "${input}" )"
# fn_tag dnStripComment purpose Strip comment from a line
# fn_tag dnStripComment prints Edited string
# fn_tag dnStripComment returns NIL
# fn_tag dnStripComment usage stripped="$( dnStripComment "${input}" )"
# fn_tag dnStripComment note Uses 'sed' to perform substitution
# fn_tag dnStripComment note Problems can occur if string contains standard escape ('\')
# fn_tag dnStripComment note Problems can occur if string contains variable token ('$')
# fn_tag dnStripComment param line purpose Line of text to strip
# fn_tag dnStripComment param line required yes
# fn_tag dnStripComment param line multipart no
# fn_tag dnStripComment param line type string
# fn_tag dnStripComment param strip-trailing-spaces purpose Whether trailing spaces are stripped
# fn_tag dnStripComment param strip-trailing-spaces required no
# fn_tag dnStripComment param strip-trailing-spaces multipart no
# fn_tag dnStripComment param strip-trailing-spaces type boolean
# fn_tag dnStripComment param strip-trailing-spaces value 0
# fn_tag dnStripComment param strip-trailing-spaces value 1
# fn_tag dnStripComment param strip-trailing-spaces default 0
# fn_tag dnStripComment param comment-marker purpose The comment marker to be stripped
# fn_tag dnStripComment param comment-marker required no
# fn_tag dnStripComment param comment-marker multipart no
# fn_tag dnStripComment param comment-marker type string
# fn_tag dnStripComment param comment-marker default #
dnStripComment() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local stripped strip marker
	stripped="${1}" strip=0 marker='#'
	# what comment marker do we use? (param 3)
	[ ${#} -ge 3 ] && [ -n "${3+x}" ] && marker="${3}"
	# do we strip trailing spaces? (param 2)
	[ ${#} -ge 2 ] && [ "${2}" == '1' ] && strip=1
	# strip comment
	# • repeat until no more markers
	while [[ $stripped =~ ^(.*)${marker}.*$ ]]; do
		stripped="${BASH_REMATCH[1]}"
	done
	# right trim if requested
	if [ ${strip} -eq 0 ]; then
		stripped="${stripped%"${stripped##*[![:space:]]}"}"
	fi
	# return result
	echo "${stripped}"
}
# Function: dnStripEnclosingQuotes    {{{1
# Strip quotes from front and end of string
#   params: 1 - string
#   prints: string with enclosed quotes removed
#   return: nil
# fn_tag dnStripEnclosingQuotes purpose Strip enclosing quotes from a string
# fn_tag dnStripEnclosingQuotes prints Edited string
# fn_tag dnStripEnclosingQuotes returns NIL
# fn_tag dnStripEnclosingQuotes note Removes multiple levels of matching concentric quotes
# fn_tag dnStripEnclosingQuotes param string purpose String to be edited
# fn_tag dnStripEnclosingQuotes param string required yes
# fn_tag dnStripEnclosingQuotes param string multipart no
# fn_tag dnStripEnclosingQuotes param string type string
dnStripEnclosingQuotes() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string
	string="${1}"
	while { [[ $string =~ ^\" ]] && [[ $string =~ \"$ ]]; } ||
		{ [[ $string =~ ^\' ]] && [[ $string =~ \'$ ]]; }; do
		if [[ $string =~ ^\" ]] && [[ $string =~ \"$ ]]; then
			string="${string/#\"/}"
			string="${string/%\"/}"
		elif [[ $string =~ ^\' ]] && [[ $string =~ \'$ ]]; then
			string="${string/#\'/}"
			string="${string/%\'/}"
		fi
	done
	echo "${string}"
}
# Function: dnStripEnclosingSpaces    {{{1
# Strip spaces from front and end of string
#   params: 1 - string
#   prints: string with enclosed spaces removed
#   return: nil
# fn_tag dnStripEnclosingSpaces purpose Strip spaces from front and end of string
# fn_tag dnStripEnclosingSpaces prints Edited string
# fn_tag dnStripEnclosingSpaces returns NIL
# fn_tag dnStripEnclosingSpaces param string purpose String to edit
# fn_tag dnStripEnclosingSpaces param string required yes
# fn_tag dnStripEnclosingSpaces param string multipart no
# fn_tag dnStripEnclosingSpaces param string type string
dnStripEnclosingSpaces() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string
	string="${1}"
	string="${string#"${string%%[![:space:]]*}"}" # strip leading spaces
	string="${string%"${string##*[![:space:]]}"}" # strip trailing spaces
	echo "${string}"
}
# Function: dnStripExtension    {{{1
# Strip extension from filepath
#   params: 1 - filepath
#   prints: filepath without extension
#   return: nil
# fn_tag dnStripExtension purpose Strip extension from filepath
# fn_tag dnStripExtension prints Filepath without extension, e.g., path plus basename
# fn_tag dnStripExtension returns NIL
# fn_tag dnStripExtension param filepath purpose Filepath to be analysed
# fn_tag dnStripExtension param filepath required yes
# fn_tag dnStripExtension param filepath multipart no
# fn_tag dnStripExtension param filepath type path
dnStripExtension() {
	# get parent dir and basename
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local parent base
	parent="$(dnParentDir "${1}")"
	[ -n "${parent+x}" ] && parent="${parent}/"
	base="$(dnExtractFileBase "${1}")"
	# supply result
	echo "${parent}${base}"
}
# Function: dnStripLeadingZeroes    {{{1
# Strip leading zeroes from integer
#   params: 1 - integer
#   prints: integer
#   return: nil
# fn_tag dnStripLeadingZeroes purpose Strip leading zeroes from an integer
# fn_tag dnStripLeadingZeroes prints Edited integer
# fn_tag dnStripLeadingZeroes returns NIL
# fn_tag dnStripLeadingZeroes param integer purpose Integer to strip leading zeroes from
# fn_tag dnStripLeadingZeroes param integer required yes
# fn_tag dnStripLeadingZeroes param integer multipart no
# fn_tag dnStripLeadingZeroes param integer type integer
dnStripLeadingZeroes() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	if [[ ${1} =~ ^0+$ ]]; then
		echo '0'
	else
		[[ ${1} =~ ^0*(.*)$ ]]
		echo "${BASH_REMATCH[1]}"
	fi
}
# Function: dnStripQuotes    {{{1
# Strip quote marks from string
#   params: 1 - string
#   prints: string with quote marks removed
#   return: nil
# fn_tag dnStripQuotes purpose Strip all quote marks from a string
# fn_tag dnStripQuotes prints Edited string
# fn_tag dnStripQuotes returns NIL
# fn_tag dnStripQuotes note Will also strip single quotes (') used as apostrophes
# fn_tag dnStripQuotes param string purpose String to be edited
# fn_tag dnStripQuotes param string required yes
# fn_tag dnStripQuotes param string multipart no
# fn_tag dnStripQuotes param string type string
dnStripQuotes() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string
	string="${1}"
	string="${string//\"/}"
	string="${string//\'/}"
	echo "${string}"

}
# Function: dnStripWhitespace    {{{1
# Strip whitespace from string
#   params: 1 - string
#   prints: string with whitespace removed
#   return: nil
# fn_tag dnStripWhitespace purpose Strip all whitespace from string
# fn_tag dnStripWhitespace prints Edited string
# fn_tag dnStripWhitespace returns NIL
# fn_tag dnStripWhitespace note Includes intra-string spaces as well as enclosing spaces
# fn_tag dnStripWhitespace param string purpose String to be edited
# fn_tag dnStripWhitespace param string required yes
# fn_tag dnStripWhitespace param string multipart no
# fn_tag dnStripWhitespace param string type string
dnStripWhitespace() { echo "${1//[[:space:]]/}"; }
# Function: dnTempDir    {{{1
# Create temporary dir
#   params: nil
#   prints: temporary dir name
#   return: boolean (0|*) on success
#   usage:  local tmp_dir
#           tmp_dir="$( dnTempDir )" || dnEndScript 1 "Can't make temp file"
#           dnTempTrap "${tmp_dir}"
#           ...
#           dnTempKill "${tmp_dir}"
# fn_tag dnTempDir purpose Create temporary directory
# fn_tag dnTempDir prints Temporary directory name
# fn_tag dnTempDir returns Whether temporary directory successfully created
# fn_tag dnTempDir usage local tmp_dir
# fn_tag dnTempDir usage tmp_dir="$( dnTempDir )" || dnEndScript 1 "Can't make temp file"
# fn_tag dnTempDir usage dnTempTrap "${tmp_dir}"
# fn_tag dnTempDir usage ...
# fn_tag dnTempDir usage dnTempKill "${tmp_dir}"
dnTempDir() {
	local tmp_dir
	tmp_dir="$(mktemp -d)" || return 1 # create temporary dir
	echo "${tmp_dir}"                  # inform user
}
# Function: dnTempFile    {{{1
# Create temporary file
#   params: nil
#   prints: temporary file name
#   return: boolean (0|*) on success
#   usage:  local tmp_dir
#           tmp_file="$( dnTempFile )" || dnEndScript 1 "Can't make temp file"
#           dnTempTrap "${tmp_file}"
#           ...
#           dnTempKill "${tmp_file}"
# fn_tag dnTempFile purpose Create temporary file
# fn_tag dnTempFile prints Temporary filename
# fn_tag dnTempFile returns Whether temporary file successfully created (Boolean)
# fn_tag dnTempFile usage local tmp_dir
# fn_tag dnTempFile usage tmp_file="$( dnTempFile )" || dnEndScript 1 "Can't make temp file"
# fn_tag dnTempFile usage dnTempTrap "${tmp_file}"
# fn_tag dnTempFile usage ...
# fn_tag dnTempFile usage dnTempKill "${tmp_file}"
dnTempFile() {
	local tmp_file
	tmp_file="$(mktemp)" || return 1 # create temporary file
	echo "${tmp_file}"               # inform user
}
# Function: dnTempKill    {{{1
# Remove file/dir from list of temporary file/dirs and reset trap
#   params: temporary file or dir names to remove
#   prints: nil
#   return: boolean (0=success|1=failed)
#   note:   sets variables [ dn_temp_file_dirs[] ]
#   usage:  local tmp_dir
#           tmp_dir="$( dnTempDir )" || dnEndScript 1 "Can't make temp file"
#           dnTempTrap "${tmp_dir}"
#           ...
#           dnTempKill "${tmp_dir}"
# fn_tag dnTempKill purpose Remove temporary file/dir from list and reset trap command
# fn_tag dnTempKill prints NIL
# fn_tag dnTempKill returns Whether operation succeeds (Boolean)
# fn_tag dnTempKill note Removes file/dir from array 'dn_temp_file_dirs'
# fn_tag dnTempKill note Resets trap command to delete paths in array when signal trapped
# fn_tag dnTempKill usage local tmp_dir
# fn_tag dnTempKill usage tmp_dir="$( dnTempDir )" || dnEndScript 1 "Can't make temp file"
# fn_tag dnTempKill usage dnTempTrap "${tmp_dir}"
# fn_tag dnTempKill usage ...
# fn_tag dnTempKill usage dnTempKill "${tmp_dir}"
# fn_tag dnTempKill param path purpose Path of temporary file/dir being processed
# fn_tag dnTempKill param path required yes
# fn_tag dnTempKill param path multipart no
# fn_tag dnTempKill param path type path
dnTempKill() {
	# set and check variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No path provided"
	[ -n "$(dnStripWhitespace "${@}")" ] || return 1
	local i
	i=''
	local -a temps=()
	# loop through files
	while [ ${#} -gt 0 ]; do
		# delete file/dir
		rm -fr "${1}"
		# remove file/dir from list of temporary file/dirs
		# -- duplicate and copy back only if non-null and not for removal
		local -a temps=()
		for ((i = 0; i < ${#dn_temp_file_dirs[*]}; i++)); do
			temps[i]="${dn_temp_file_dirs[i]}"
		done
		dn_temp_file_dirs=()
		for ((i = 0; i < ${#temps[*]}; i++)); do
			[ -n "${temps[i]+x}" ] && [ "${temps[i]}" != "${1}]}" ] &&
				dn_temp_file_dirs+=("${temps[i]}")
		done
		shift
	done
	# reset trap
	if [ ${#dn_temp_file_dirs[*]} -eq 0 ]; then # no temp file/dirs remain
		trap - 1 3 9 11 15
	else # at least one file/dir remains to be deleted on exit
		eval trap "\"rm -fr ${dn_temp_file_dirs[*]}\"" 1 3 9 11 15
	fi
}

# }}}1
# Function: dnTempTrap    {{{1
# Add new temporary file/dir and reset trap command
#   params: temporary file or dir name to add
#   prints: nil
#   return: boolean (0=success|1=failed)
#   note:   sets variables [ dn_temp_file_dirs[] ]
#   usage:  local tmp_dir
#           tmp_dir="$( dnTempDir )" || dnEndScript 1 "Can't make temp file"
#           dnTempTrap "${tmp_dir}"
#           ...
#           dnTempKill "${tmp_dir}"
# fn_tag dnTempTrap purpose Add temporary file/dir to list and reset trap command
# fn_tag dnTempTrap prints NIL
# fn_tag dnTempTrap returns Whether file/dir path supplied to function (Boolean)
# fn_tag dnTempTrap note Adds file/dir path to array 'dn_temp_file_dirs'
# fn_tag dnTempTrap note Resets trap command to delete cNILths in array when signal trapped
# fn_tag dnTempTrap usage local tmp_dir
# fn_tag dnTempTrap usage tmp_dir="$( dnTempDir )" || dnEndScript 1 "Can't make temp file"
# fn_tag dnTempTrap usage dnTempTrap "${tmp_dir}"
# fn_tag dnTempTrap usage ...
# fn_tag dnTempTrap usage dnTempKill "${tmp_dir}"
# fn_tag dnTempTrap param path purpose Path of temporary file or directory being processed
# fn_tag dnTempTrap param path required yes
# fn_tag dnTempTrap param path multipart no
# fn_tag dnTempTrap param path type path
dnTempTrap() {
	[ ${#} -gt 0 ] || return 1                                 # sanity check
	dn_temp_file_dirs+=("${1}")                                # add new file/dir
	eval trap "\"rm -fr ${dn_temp_file_dirs[*]}\"" 1 3 9 11 15 # reset trap
}
# Function: dnTerminalSubdir    {{{1
# Extracts terminal subdirectory from directory path
#   params: 1 - directory path
#   prints: terminal subdirectory
#   return: nil
#   needs:  functions [dnRemoveEndSlash]
# fn_tag dnTerminalSubdir purpose Extract terminal subdirectory from directory path
# fn_tag dnTerminalSubdir prints Terminal subdirectory name
# fn_tag dnTerminalSubdir returns NIL
# fn_tag dnTerminalSubdir note Handles terminal slash if present
# fn_tag dnTerminalSubdir note Use on dirpaths only -- if filepath supplied will return filename
# fn_tag dnTerminalSubdir param directory_path purpose Directory path to be analysed
# fn_tag dnTerminalSubdir param directory_path required yes
# fn_tag dnTerminalSubdir param directory_path multipart no
# fn_tag dnTerminalSubdir param directory_path type path
dnTerminalSubdir() {
	# ensure no terminal slash
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No directory path provided"
	local dir
	dir="${1}"
	dir="$(dnRemoveEndSlash "${dir}")"
	# extract last directory name
	awk -F '/' '{ print $NF }' <<<"${dir}"
}
# Function: dnTimeDifference    {{{1
# Calculate difference between two times (as formatted string)
#   params: 1 - time (in seconds)
#           2 - time (in seconds)
#           3 - format type (see dnFormatTime for format type codes)
#   prints: time as formatted string
#   return: boolean (0=valid result|1=error)
#   usage:  start="$( dnSecondsSinceEpoch )"
#           ...
#           end="$( dnSecondsSinceEpoch )"
#           dnInfo "Duration: $( dnTimeDifference "${start}" "${end}" 'a' )"
# fn_tag dnTimeDifference purpose Convert time difference to formatted time
# fn_tag dnTimeDifference prints Formatted time string
# fn_tag dnTimeDifference returns Whether able to process inputs (Boolean)
# fn_tag dnTimeDifference usage start="$( dnSecondsSinceEpoch )"
# fn_tag dnTimeDifference usage ...
# fn_tag dnTimeDifference usage end="$( dnSecondsSinceEpoch )"
# fn_tag dnTimeDifference usage dnInfo "Duration: $( dnTimeDifference "${start}" "${end}" 'a' )"
# fn_tag dnTimeDifference param begin purpose Start time in seconds
# fn_tag dnTimeDifference param begin required yes
# fn_tag dnTimeDifference param begin multipart no
# fn_tag dnTimeDifference param begin type integer
# fn_tag dnTimeDifference param begin note Most commonly use seconds since epoch
# fn_tag dnTimeDifference param begin note Can obtain seconds since epoch using function 'dnSecondsSinceEpoch'
# fn_tag dnTimeDifference param end purpose Finish time in seconds
# fn_tag dnTimeDifference param end required yes
# fn_tag dnTimeDifference param end multipart no
# fn_tag dnTimeDifference param end type integer
# fn_tag dnTimeDifference param format-code purpose How to format time string
# fn_tag dnTimeDifference param format-code required yes
# fn_tag dnTimeDifference param format-code multipart no
# fn_tag dnTimeDifference param format-code type string
# fn_tag dnTimeDifference param format-code value a
# fn_tag dnTimeDifference param format-code value :
# fn_tag dnTimeDifference param format-code default :
# fn_tag dnTimeDifference param format-code note 'a' = alpha (example is '5h 12m 3s')
# fn_tag dnTimeDifference param format-code note ':' = colons (example is '05:12:03')
dnTimeDifference() {
	# set and check variables
	[ -n "${3+x}" ] || dnAbort "${FUNCNAME[0]}: No format code provided"
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No finish time provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No start time provided"
	(dnValidPosInteger "${1}" && dnValidPosInteger "${2}") || return 1
	# get time difference
	local diff
	diff="$(dnRemoveLeadingMinus "$((${1} - ${2}))")"
	# format it
	dnFormatTime "${diff}" "${3}"
}

# TODO
#
# dnDlg function:
# • ensure support for dnList[Tag]Dlg and dnSelect[Tag]Dlg
# • ensure support for input box

# Function: dnTitleCase    {{{1
# Converts string to title case
#   params: 1 - string
#   prints: string
#   return: nil
#   note:   there are numerous versions of title case
#   note:   capitalises first and last words, and all words
#           except articles, prepositions and conjunctions
#           of fewer than five letters
# fn_tag dnTitleCase purpose Converts string to title case
# fn_tag dnTitleCase prints Edited string
# fn_tag dnTitleCase returns NIL
# fn_tag dnTitleCase note Capitalises first and last words, and all words except articles, prepositions and conjunctions of less than five letters
# fn_tag dnTitleCase param string purpose String to convert
# fn_tag dnTitleCase param string required yes
# fn_tag dnTitleCase param string multipart no
# fn_tag dnTitleCase param string type string
dnTitleCase() {
	# define variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local string cap_word loop new_string stem
	string="${1}" cap_word='' loop='' new_string='' stem=''
	# define words not to be capitalised in title case
	local -a articles=(
		a an the
	)
	local -a prepositions=(
		amid as at atop but by for from
		in into mid near next of off on
		onto out over per quo sans than till
		to up upon v vs via with
	)
	local -a conjunctions=(
		and as both but for how if lest
		nor once or so than that till when
		yet
	)
	local -a title_lowercase=("${articles[@]}" "${prepositions[@]}" "${conjunctions[@]}")
	# build array of lower case, space-separated string elements (=~ words)
	local -a words=("$(dnLowercase "${string}")")
	# loop through words
	loop=1
	for word in "${words[@]}"; do
		cap_word="$(dnInitialCap "${word}")"
		# first and last words must be capitalised
		if test ${loop} -eq 1; then
			new_string="${cap_word}"
		elif test ${loop} -eq ${#words[@]}; then
			new_string="${new_string} ${cap_word}"
		else
			# these "inner" words may or may not be capitalised
			# need to compare them with list of words not to be capitalised
			# to enable comparison strip trailing commas, bangs, etc.
			stem="$(tr --delete --complement "[:alpha:]" <<<"${word}")"
			if dnElementInArray "${stem}" "${title_lowercase[@]}"; then
				new_string="${new_string} ${word}"
			else
				new_string="${new_string} ${cap_word}"
			fi
		fi
		((loop++)) || true
	done
	# return result
	echo "${new_string}"
}
# Function: dnToggleFlag    {{{1
# Toggle flag value
#   params: 1 - flag variable
#   prints: inverted flag value
#   return: inverted flag value -- boolean (0|1)
# fn_tag dnToggleFlag purpose Invert value of flag
# fn_tag dnToggleFlag prints Inverted flag value (Boolean)
# fn_tag dnToggleFlag returns Inverted flag value (Boolean)
# fn_tag dnToggleFlag note A flag value of zero (true) is converted to '1' (false).  *All* other values, whether numeric or string, are converted to '0' (true).
# fn_tag dnToggleFlag param flag purpose Value to be inverted
# fn_tag dnToggleFlag param flag required yes
# fn_tag dnToggleFlag param flag multipart no
# fn_tag dnToggleFlag param flag type string
dnToggleFlag() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	case ${1} in
	0)
		echo '1'
		return 1
		;;
	*)
		echo '0'
		return 0
		;;
	esac
}

# Function: dnToolAvailable    {{{1
# Checks that tool (executable) is available (using 'which')
#   params: 1 - executable name
#   prints: nil
#   return: 0|1 (exists|not exists)
# fn_tag dnToolAvailable purpose Checks whether a tool is available
# fn_tag dnToolAvailable prints NIL
# fn_tag dnToolAvailable returns Whether tool exists (Boolean)
# fn_tag dnToolAvailable note Uses 'which' to check for executable
# fn_tag dnToolAvailable param executable purpose Name of executable to check for
# fn_tag dnToolAvailable param executable required yes
# fn_tag dnToolAvailable param executable multipart no
# fn_tag dnToolAvailable param executable type string
dnToolAvailable() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No executable name provided"
	which "${1}" >/dev/null 1>&2
	return ${?}
}
# Function: dnToolsAvailable    {{{1
# Checks for all needed tools
#   params: list of tools
#   prints: message listing missing tools
#   return: 0|1 (tools all present|tools NOT all present)
#   invoke: dnToolsAvailable "${tools_list}" || dnEndScript
#   needs:  functions [dnToolAvailable]
# fn_tag dnToolsAvailable purpose Checks list of tools to determine whether all are available
# fn_tag dnToolsAvailable prints Message listing missing tools
# fn_tag dnToolsAvailable returns Whether all tools are available (Boolean)
# fn_tag dnToolsAvailable usage dnToolsAvailable "${tools_list}" || dnEndScript
# fn_tag dnToolsAvailable note Uses function 'dnToolAvailable' for each tool
# fn_tag dnToolsAvailable param executable purpose List of executable names to check
# fn_tag dnToolsAvailable param executable required yes
# fn_tag dnToolsAvailable param executable multipart yes
# fn_tag dnToolsAvailable param executable type string
dnToolsAvailable() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No list provided"
	local tool retval
	tool='' retval=0
	# check for tools
	for tool in ${1}; do
		if ! dnToolAvailable "${tool}"; then
			retval=1
			echo "Warning: missing executable '${tool}'"
		fi
	done
	# return exit status
	return ${retval}
}
# Function: dnTrayClose    {{{1
# Common routine for loading tray
#   params: 1 - drive name,
#           2 - drive device
#   prints: feedback (not for capture)
#   return: 0|1 (success|failure)
#   needs:  functions [dnReport]
# fn_tag dnTrayClose purpose Close drive tray
# fn_tag dnTrayClose prints Feedback
# fn_tag dnTrayClose returns Whether tray successfully closed (Boolean)
# fn_tag dnTrayClose param name purpose Human-readable drive name
# fn_tag dnTrayClose param name required yes
# fn_tag dnTrayClose param name multipart no
# fn_tag dnTrayClose param name type string
# fn_tag dnTrayClose param device purpose Drive device location
# fn_tag dnTrayClose param device required yes
# fn_tag dnTrayClose param device multipart no
# fn_tag dnTrayClose param device type path
dnTrayClose() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No device location provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No drive name provided"
	local exit_status
	exit_status=''
	dnInfon "loading ${1}... "
	eject --trayclose "${2}" &>/dev/null
	exit_status=${?}
	dnReport ${exit_status}
	return ${exit_status}
}
# Function: dnTrayEject    {{{1
# Common routine for ejecting tray
#   params: 1 - drive name,
#           2 - drive device
#   prints: feedback (not for capture)
#   return: 0|1 (success|failure)
#   needs:  functions [dnDiscUnmount ; dnReport]
# fn_tag dnTrayEject purpose Open drive tray
# fn_tag dnTrayEject prints Feedback
# fn_tag dnTrayEject returns Whether drive successfully ejected
# fn_tag dnTrayEject note Attempts to unmount drive before opening tray
# fn_tag dnTrayEject param name purpose Human-readable drive name
# fn_tag dnTrayEject param name required yes
# fn_tag dnTrayEject param name multipart no
# fn_tag dnTrayEject param name type string
# fn_tag dnTrayEject param device purpose Drive device location
# fn_tag dnTrayEject param device required yes
# fn_tag dnTrayEject param device multipart no
# fn_tag dnTrayEject param device type path
dnTrayEject() {
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No device location provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No drive name provided"
	local exit_status
	exit_status=''
	dnDiscUnmount "${1}" "${2}"
	dnInfon "ejecting ${1}... "
	eject --cdrom "${2}" &>/dev/null
	exit_status=${?}
	dnReport ${exit_status}
	return ${exit_status}
}

# Function: dnTrueFilepath    {{{1
# Find true filepath if supplied with symlink
#   params: 1 - filepath
#   prints: 2 - true filepath
#   return: nil
#   invoke: file="$( dnTrueFilepath "${file}"
# fn_tag dnTrueFilepath purpose Determine true filepath of supplied file
# fn_tag dnTrueFilepath prints True filepath
# fn_tag dnTrueFilepath returns NIL
# fn_tag dnTrueFilepath note Intended for resolving symlinks to true filepaths
# fn_tag dnTrueFilepath note Will return symlink target even if target does not exist
# fn_tag dnTrueFilepath param filepath purpose Filepath to be resolved
# fn_tag dnTrueFilepath param filepath required yes
# fn_tag dnTrueFilepath param filepath multipart no
# fn_tag dnTrueFilepath param filepath type path
dnTrueFilepath() {
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local exit_status fp true_fp
	exit_status='' fp='' true_fp=''
	fp="$(dnNormalisePath "${1}")"
	# try to resolve symlinks
	true_fp="$(readlink -m "${fp}" 2>/dev/null)"
	exit_status=${?}
	# if error then return supplied filepath
	[ ${exit_status} -ne 0 ] || [ -z "${true_fp}" ] && true_fp="${fp}"
	# supply true filepath
	echo "${true_fp}"
}
# Function: dnTruncate    {{{1
# Truncate string to specified length
#   params: 1 - string
#           2 - maximum length
#   prints: truncated string
#   return: nil
# fn_tag dnTruncate purpose Truncate string at specified length
# fn_tag dnTruncate prints Truncated string
# fn_tag dnTruncate returns NIL
# fn_tag dnTruncate note String is truncated at three fewer chars to allow ellipsis to be added
# fn_tag dnTruncate param string purpose String to be truncated
# fn_tag dnTruncate param string required yes
# fn_tag dnTruncate param string multipart no
# fn_tag dnTruncate param string type string
# fn_tag dnTruncate param max_length purpose Maximum length of string before truncation occurs
# fn_tag dnTruncate param max_length required yes
# fn_tag dnTruncate param max_length multipart no
# fn_tag dnTruncate param max_length type integer
dnTruncate() {
	# set variables
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No length provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	local str max len trunc
	str="${1}" max="${2}" len='' trunc=''
	len=$(dnStrLen "${str}")
	trunc=$((max - 3))
	# sanity checks
	if [ -z "${str}" ] || [ -z "${max}" ]; then
		[ -n "${str+x}" ] && echo "${str}"
		return 1
	fi
	# determine whether truncation necessary
	if [ "${len}" -le "${max}" ]; then # no truncation necessary
		echo "${str}"
	else # have to truncate
		echo "${str:0:${trunc}}..."
	fi
}
# Function: dnUnderGitControl    {{{1
# Determines whether directory is under local git version control
#   params: 1 - directory [string]
#   prints: nil
#   return: 0|1 (is under git control|not under git control)
#   note:   test is presence of file '.git/HEAD'
# fn_tag dnUnderGitControl purpose Determine whether directory is under local git version control
# fn_tag dnUnderGitControl prints NIL
# fn_tag dnUnderGitControl returns Whether directory is under local git version control (Boolean)
# fn_tag dnUnderGitControl note Test is presence of file '.git/HEAD'
# fn_tag dnUnderGitControl param directory purpose Directory to test for local git version control
# fn_tag dnUnderGitControl param directory required yes
# fn_tag dnUnderGitControl param directory multipart no
# fn_tag dnUnderGitControl param directory type path
dnUnderGitControl() {
	# check parameter
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No directory path provided"
	[ -z "${1}" ] && return ${dn_false}
	# HEAD file must be present
	local head
	head="${1}/.git/HEAD"
	dnFileValid "${head}" &>/dev/null
	return ${?}
}

# Function: dnUnderRcsControl    {{{1
# Determines whether directory is under local RCS version control
#   params: 1 - directory [string]
#   prints: nil
#   return: 0|1 (is under RCS control|not under RCS version control)
#   note:   test is presence of non-empty subdirectory 'RCS'
# fn_tag dnUnderRcsControl purpose Whether directory is under local RCS version control
# fn_tag dnUnderRcsControl prints NIL
# fn_tag dnUnderRcsControl returns Whether directory is under local RCS version control (Boolean)
# fn_tag dnUnderRcsControl note Test is presence of non-empty subdirectory 'RCS'
# fn_tag dnUnderRcsControl param directory purpose Directory to test for local RCS version control
# fn_tag dnUnderRcsControl param directory required yes
# fn_tag dnUnderRcsControl param directory multipart no
# fn_tag dnUnderRcsControl param directory type path
dnUnderRcsControl() {
	# check parameter
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No directory path provided"
	[ -z "${1}" ] && return ${dn_false}
	# RCS subdirectory must be present
	local rcs_dir
	rcs_dir="${1}/RCS"
	dnDirValid "${rcs_dir}" || return ${dn_false}
	# RCS subdirectory must be non-empty
	dnDirEmpty "${rcs_dir}" && return ${dn_false}
	# passed all tests!
	return ${dn_true}
}
# Function: dnUnderSpace    {{{1
# Convert underscores to spaces
#   params: 1 - string
#   prints: converted string
#   return: nil
# fn_tag dnUnderSpace purpose Convert underscores to spaces
# fn_tag dnUnderSpace prints Edited string
# fn_tag dnUnderSpace returns NIL
# fn_tag dnUnderSpace note Not all whitespace -- only space characters
# fn_tag dnUnderSpace param string purpose String to be edited
# fn_tag dnUnderSpace param string required yes
# fn_tag dnUnderSpace param string multipart no
# fn_tag dnUnderSpace param string type string
dnUnderSpace() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	tr '_' ' ' <<<"${1}"
}
# Function: dnUniqueFileName    {{{1
# Get unique file name for given name template and directory
#   params: 1 - directory (for unique file)
#           2 - template (needs minimum 1 placeholder character)
#           3 - placeholder (optional, default='X', cannot be'=')
#   prints: unique file name
#   return: boolean (0|*) on success
# fn_tag dnUniqueFileName purpose Get a unique file name for a given name template in a specified directory
# fn_tag dnUniqueFileName prints Unique file name
# fn_tag dnUniqueFileName returns Whether unique file name determined successfully (Boolean)
# fn_tag dnUniqueFileName param directory purpose Directory in which unique file name is to be used
# fn_tag dnUniqueFileName param directory required yes
# fn_tag dnUniqueFileName param directory multipart no
# fn_tag dnUniqueFileName param directory type path
# fn_tag dnUniqueFileName param directory note Can be relative or absolute
# fn_tag dnUniqueFileName param template purpose Provide template for file name
# fn_tag dnUniqueFileName param template required yes
# fn_tag dnUniqueFileName param template multipart no
# fn_tag dnUniqueFileName param template type string
# fn_tag dnUniqueFileName param template note Must include one or more consecutive placeholder character which will be replaced with a number string to ensure uniqueness
# fn_tag dnUniqueFileName param template note The placeholder character cannot occur anywhere else in the template
# fn_tag dnUniqueFileName param placeholder_character purpose The placeholder character used in the file name template
# fn_tag dnUniqueFileName param placeholder_character required no
# fn_tag dnUniqueFileName param placeholder_character multipart no
# fn_tag dnUniqueFileName param placeholder_character type string
# fn_tag dnUniqueFileName param placeholder_character default X
# fn_tag dnUniqueFileName param placeholder_character note If multiple characters are supplied only the first is used
# fn_tag dnUniqueFileName param placeholder_character note Cannot be set to '/'
dnUniqueFileName() {
	# create variables
	[ -n "${2+x}" ] || dnAbort "${FUNCNAME[0]}: No template provided"
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No directory path provided"
	local dir template char
	dir="${1}" template="${2}" char="${3:-'X'}"
	local count prefix suffix placeholder length filedir first_loop
	count=0 prefix='' suffix='' placeholder='' length='' filedir='' first_loop=''
	# • dir
	dir="$(dnNormalisePath "${dir}")"
	if ! dnDirValid "${dir}"; then
		dnErrorStderr "directory '${1}' is not valid"
		return 1
	fi
	# • char (placeholder character)
	char="${char:0:1}" # ensure single char
	if [ "${char}" = '/' ]; then
		dnErrorStderr "invalid placeholder character '${char}'"
		return 1
	fi
	# • placeholder length, prefix and suffix
	if ! [[ $template =~ ^([^${char}]*)(${char}+)([^${char}]*)$ ]]; then
		dnErrorStderr "invalid template '${template}' (placeholder='${char}')"
		return 1
	fi
	prefix="${BASH_REMATCH[1]}"
	placeholder="${BASH_REMATCH[2]}"
	suffix="${BASH_REMATCH[3]}"
	length="$(dnStrLen "${placeholder}")"
	# get unique filename
	first_loop='yes'
	while [ "${first_loop}" = 'yes' ] || dnFileValid "${filedir}"; do
		first_loop='no'
		((count++)) || true
		if [ "$(dnStrLen "${count}")" -gt "${length}" ]; then
			# have reached max placeholder with no unique filename obtained
			dnErrorStderr "insufficient placeholder characters '${char}' ..." \
				"... in template '${template}' to get unique ..." \
				"... filename in directory '${dir}'"
			return 1
		fi
		filedir="${dir}/${prefix}$(dnLeftPad "${length}" "${count}" "0")${suffix}"
	done
	# success!
	echo "${prefix}$(dnLeftPad "${length}" "${count}" "0")${suffix}"
	return 0
}
# Function: dnUpdateLocalGitRepo    {{{1
# Update local git repo
#   params: nil
#   prints: confirmation dialog and feedback from git commit
#   return: nil
#   note:   uses git commit command with '-a' flag
#   note:   intended for repo consisting only of current directory
#   note:   if repo covers more than current directory may get unexpected results
# fn_tag dnUpdateLocalGitRepo purpose Update local git repo
# fn_tag dnUpdateLocalGitRepo prints Confirmation dialog and feedback from git commit
# fn_tag dnUpdateLocalGitRepo returns NIL
# fn_tag dnUpdateLocalGitRepo usage Uses git commit command with '-a' flag
# fn_tag dnUpdateLocalGitRepo usage See dnUpdateRemoteGitRepo for example using this function
# fn_tag dnUpdateLocalGitRepo note Intended for local repo consisting only of current directory
# fn_tag dnUpdateLocalGitRepo note If local repo covers more than current dir may get unexpected results
dnUpdateLocalGitRepo() {
	# variables
	local prompt message
	prompt='Enter commit message [leave blank to abort commit]: ' message=''
	# get commit message
	message="$(dnGetInput "${prompt}")"
	# commit
	if [ -n "${message+x}" ]; then
		dnInfo 'Updating local git repo...'
		echo "${dn_divider}"
		git commit -a -m "${message}"
		echo "${dn_divider}"
	else
		dnWarn 'Commit aborted'
	fi
}
# Function: dnUpdateRemoteGitRepo    {{{1
# Update remote git repo
#   params: nil
#   prints: feedback from git push
#   return: nil
#   note:   assumes remote repo has been created
#   note:   intended for local repo consisting only of current directory
#   note:   if local repo covers more than current dir may get unexpected results
# fn_tag dnUpdateRemoteGitRepo purpose Update remote git repo
# fn_tag dnUpdateRemoteGitRepo prints Feedback from git push
# fn_tag dnUpdateRemoteGitRepo returns NIL
# fn_tag dnUpdateRemoteGitRepo usage if ! dnLocalGitRepoUptodate ; then
# fn_tag dnUpdateRemoteGitRepo usage     dnDisplayFilesGitRepoStatus
# fn_tag dnUpdateRemoteGitRepo usage     if dnConfirm 'Commit changes to local git repo?' ; then
# fn_tag dnUpdateRemoteGitRepo usage         dnUpdateLocalGitRepo
# fn_tag dnUpdateRemoteGitRepo usage     fi
# fn_tag dnUpdateRemoteGitRepo usage fi
# fn_tag dnUpdateRemoteGitRepo usage if dnLocalGitRepoUptodate ; then
# fn_tag dnUpdateRemoteGitRepo usage     dnInfo 'Local git repo is up to date'
# fn_tag dnUpdateRemoteGitRepo usage     if dnConfirm 'Update remote github repo?' ; then
# fn_tag dnUpdateRemoteGitRepo usage         dnUpdateRemoteGitRepo
# fn_tag dnUpdateRemoteGitRepo usage     else
# fn_tag dnUpdateRemoteGitRepo usage         dnWarn 'Remote git repo was not updated'
# fn_tag dnUpdateRemoteGitRepo usage     fi
# fn_tag dnUpdateRemoteGitRepo usage else
# fn_tag dnUpdateRemoteGitRepo usage     dnWarn 'Local git repo is not up to date'
# fn_tag dnUpdateRemoteGitRepo usage     dnWarn 'Remote git repo is not synchronised'
# fn_tag dnUpdateRemoteGitRepo usage fi
# fn_tag dnUpdateRemoteGitRepo note Assumes remote repo has been created
# fn_tag dnUpdateRemoteGitRepo note Intended for local repo consisting only of current directory
# fn_tag dnUpdateRemoteGitRepo note If local repo covers more than current dir may get unexpected results
dnUpdateRemoteGitRepo() {
	# variables
	local retval
	retval=''
	# attempt update
	dnInfo 'Updating remote git repo...'
	echo "${dn_divider}"
	git push -u origin master
	retval=${?}
	echo "${dn_divider}"
	# provide feedback
	if dnFlagTrue "${retval}"; then
		dnInfo 'Remote repo update successful'
	else
		dnError 'Remote repo update failed'
	fi
}
# Function: dnUppercase    {{{1
# Change lowercase to uppercase
#   params: 1 - string
#   prints: string
#   return: nil
# Note: uses 'tr'; alternate solution is 'sed -e "s/.*/\\L&/"'
# fn_tag dnUppercase purpose Convert lower case characters in string to upper case
# fn_tag dnUppercase prints Edited string
# fn_tag dnUppercase returns NIL
# fn_tag dnUppercase param string purpose String to be converted
# fn_tag dnUppercase param string required yes
# fn_tag dnUppercase param string multipart no
# fn_tag dnUppercase param string type string
dnUppercase() {
	echo "${1^^}"
}
# Function: dnUseArray    {{{1
# Utility array assisting in passing arrays from functions
#   params: 1 - name of array variable
#   prints: array definition
#   return: nil
#   usage:  returnsArray () {
#               local -a my_array=( 'first item' 'second item' )
#               dnUseArray my_array
#           }
#           eval declare -a array_var="$( returnsArray )"
#   note:   cannot use to append arrays like `a1+=$( use_array a2 )`
#           because values at matching array indices merge instead of
#           pushing them all on the array; so just use for returning
#           arrays
#   note:   technique taken from user smhmic, who based his answer on
#           that of Dennis Williamson, at internet site stackoverflow:
#           http://stackoverflow.com/questions/10582763/\
#           how-to-return-an-array-in-bash-without-using-globals
# fn_tag dnUseArray purpose Assist in passing/returning arrays from function
# fn_tag dnUseArray prints Array contents
# fn_tag dnUseArray returns NIL
# fn_tag dnUseArray usage returnsArray () {
# fn_tag dnUseArray usage     local -a my_array=( 'first item' 'second item' )
# fn_tag dnUseArray usage     dnUseArray my_array
# fn_tag dnUseArray usage }
# fn_tag dnUseArray usage eval declare -a array_var="$( returnsArray )"
# fn_tag dnUseArray note Cannot use to append arrays like `a1+=$( use_array a2 )`
# fn_tag dnUseArray note Use only for returning arrays
# fn_tag dnUseArray param varname purpose Name of array variable being passed
# fn_tag dnUseArray param varname required yes
# fn_tag dnUseArray param varname multipart no
# fn_tag dnUseArray param varname type string
# fn_tag dnUseArray param varname note Variable NAME, rather than value, is passed
dnUseArray() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No variable name provided"
	local r
	r=$(declare -p "${1}")
	r=${r#declare\ -a\ *=}
	echo "${r//\[[0-9]\]=/}"
}
# Function: dnValidDebianPackageVersion    {{{1
# Check validity of debian package version
#   params: 1 - version
#   prints: error message if invalid
#   return: boolean (0=valid|1=invalid)
#   notes:  based on Debian::Dpkg::Version module
#   usage:  dnValidDebianPackageVersion "${version}" &>/dev/null
#           if ! dnFlagTrue ${?} ; then
#               dnError "Version '${version}' is INVALID because"
#               dnError "  $( dnValidDebianPackageVersion "${version}" )"
#           fi
# fn_tag dnValidDebianPackageVersion purpose Check validity of debian package version
# fn_tag dnValidDebianPackageVersion prints Informative error message if version string is invalid
# fn_tag dnValidDebianPackageVersion returns Whether version string is valid (Boolean)
# fn_tag dnValidDebianPackageVersion usage dnValidDebianPackageVersion "${version}" &>/dev/null
# fn_tag dnValidDebianPackageVersion usage if ! dnFlagTrue ${?} ; then
# fn_tag dnValidDebianPackageVersion usage     dnError "Version '${version}' is INVALID because"
# fn_tag dnValidDebianPackageVersion usage     dnError "  $( dnValidDebianPackageVersion "${version}" )"
# fn_tag dnValidDebianPackageVersion usage fi
# fn_tag dnValidDebianPackageVersion note Based on Debian::Dpkg::Version module
# fn_tag dnValidDebianPackageVersion param version purpose Debian package version string
# fn_tag dnValidDebianPackageVersion param version required yes
# fn_tag dnValidDebianPackageVersion param version multipart no
# fn_tag dnValidDebianPackageVersion param version type string
dnValidDebianPackageVersion() {
	# variables
	local version illegal_chars epoch fragment
	version="${1:-}" illegal_chars='' epoch='' fragment='character'
	# cannot be empty
	if [ -z "${version}" ]; then
		echo 'version number cannot be empty'
		return ${dn_false}
	fi
	# check for illegal characters
	# • produces sequence of illegal characters in version string
	local -a legal_chars=({a..z} {A..Z} {0..9} '-' '+' ':' '.')
	illegal_chars="${version}"
	for char in "${legal_chars[@]}"; do
		illegal_chars="${illegal_chars//${char}/}"
	done
	if [ -n "${illegal_chars+x}" ]; then
		[ ${#illegal_chars} -gt 1 ] && fragment+='s'
		echo "version number contains illegal ${fragment} '${illegal_chars}'"
		return ${dn_false}
	fi
	# epoch, if present, must be number
	if [[ $version =~ ^([[:digit:]]+):[^:]+$ ]]; then
		epoch="${BASH_REMATCH[1]}"
		if ! dnValidPosInteger "${epoch}"; then
			echo "epoch part of version number ('${epoch}') is not an integer"
			return ${dn_false}
		fi
	fi
	# if here then all tests passed
	return ${dn_true}
}

# Function: dnValidGeometry    {{{1
# Determine whether value is valid X11 geometry value ([+-]integer)
#   params: 1 - value
#   prints: nil
#   return: 0|1 (valid|invalid)
# fn_tag dnValidGeometry purpose Determine whether value is a valid X11 geometry value
# fn_tag dnValidGeometry prints NIL
# fn_tag dnValidGeometry returns Whether value is valid X11 geometry value (Boolean)
# fn_tag dnValidGeometry note An X11 geometry value is defined in this function as: '[+-]int' where 'int' is a valid positive integer
# fn_tag dnValidGeometry param value purpose Value to be tested
# fn_tag dnValidGeometry param value required yes
# fn_tag dnValidGeometry param value multipart no
# fn_tag dnValidGeometry param value type integer
dnValidGeometry() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[[ ${1} =~ ^[\+-]0$|^[\+-][1-9][[:digit:]]*$ ]]
	return ${?}
}
# Function: dnValidNonZeroPosInt    {{{1
# Determine whether value is valid positive integer
#   params: 1 - integer
#   prints: nil
#   return: 0|1 (valid|invalid)
# fn_tag dnValidNonZeroPosInt purpose Determine whether value is a valid, non-zero, positive integer
# fn_tag dnValidNonZeroPosInt prints NIL
# fn_tag dnValidNonZeroPosInt returns Whether value is a valid, non-zero, positive integer (Boolean)
# fn_tag dnValidNonZeroPosInt param integer purpose Value to be tested
# fn_tag dnValidNonZeroPosInt param integer required yes
# fn_tag dnValidNonZeroPosInt param integer multipart no
# fn_tag dnValidNonZeroPosInt param integer type integer
dnValidNonZeroPosInt() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[[ ${1} =~ ^[1-9][[:digit:]]*$ ]]
	return ${?}
}
# Function: dnValidNumber    {{{1
# Determine whether value is valid number
#   params: 1 - number
#   prints: nil
#   return: 0|1 (valid|invalid)
# fn_tag dnValidNumber purpose Determine whether value is a valid number
# fn_tag dnValidNumber prints NIL
# fn_tag dnValidNumber returns Whether value is a valid number (Boolean)
# fn_tag dnValidNumber param number purpose Value to be tested
# fn_tag dnValidNumber param number required yes
# fn_tag dnValidNumber param number multipart no
# fn_tag dnValidNumber param number type number
dnValidNumber() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[[ ${1} =~ ^0$|^-?[1-9][[:digit:]]*$|^-?0\.[[:digit:]]+$|^-?[1-9][[:digit:]]*\.[[:digit:]]+$ ]]
	return ${?}
}
# Function: dnValidPosInteger    {{{1
# Determine whether value is valid positive integer
#   params: 1 - integer
#   prints: nil
#   return: 0|1 (valid|invalid)
# fn_tag dnValidPosInteger purpose Determine whether value is a valid positive integer
# fn_tag dnValidPosInteger prints NIL
# fn_tag dnValidPosInteger returns Whether value is a valid positive integer (Boolean)
# fn_tag dnValidPosInteger note Zero is considered a positive integer
# fn_tag dnValidPosInteger param integer purpose Value to be tested
# fn_tag dnValidPosInteger param integer required yes
# fn_tag dnValidPosInteger param integer multipart no
# fn_tag dnValidPosInteger param integer type integer
dnValidPosInteger() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No value provided"
	[[ ${1} =~ ^0$|^[1-9][[:digit:]]*$ ]]
	return ${?}
}
# Function: dnValidRGB    {{{1
# Determine whether an RGB value is correct
#   params: 1 - RBG values
#   prints: nil
#   return: boolean (0=valid|1=invalid)
#   format: 'r,g,b' where 'r', 'g' and 'b' are integers between 0 and 255
# fn_tag dnValidRGB purpose Determine whether an RGB value is correct
# fn_tag dnValidRGB prints NIL
# fn_tag dnValidRGB returns Whether an RGB value is correct (Boolean)
# fn_tag dnValidRGB note Valid RGB format is 'r,g,b' where each is integer between 0 and 255
# fn_tag dnValidRGB param rgb purpose The RGB value being analysed
# fn_tag dnValidRGB param rgb required yes
# fn_tag dnValidRGB param rgb multipart no
# fn_tag dnValidRGB param rgb type string
# fn_tag dnValidRGB param rgb note Valid RGB format is 'r,g,b' where each is integer between 0 and 255
dnValidRGB() {
	# first, make sure basic format is correct
	[[ $1 =~ ^([[:digit:]]+),([[:digit:]]+),([[:digit:]]+)$ ]] || return 1
	# second, check each value is valid positive integer between 0 and 255
	local value
	value=''
	for value in "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}" "${BASH_REMATCH[3]}"; do
		dnValidPosInteger "${value}" || return 1
		[ "${value}" -ge 0 ] && [ "${value}" -le 255 ] || return 1
	done
	# if here then no errors
	return 0
}

# }}}1
# Function: dnValidTarzip    {{{1
# Checks whether archive is a valid tarzip
#   params: 1 - archive filepath
#   prints: nil
#   return: 0|1 (valid|not valid)
# fn_tag dnValidTarzip purpose Determine whether file is a valid tarzip archive
# fn_tag dnValidTarzip prints NIL
# fn_tag dnValidTarzip returns Whether file is a valid tarzip archive (Boolean)
# fn_tag dnValidTarzip param filepath purpose Archive to be analysed
# fn_tag dnValidTarzip param filepath required yes
# fn_tag dnValidTarzip param filepath multipart no
# fn_tag dnValidTarzip param filepath type path
dnValidTarzip() {
	# check it exists
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	local archive
	archive="$(dnNormalisePath "${1}")"
	dnFileValid "${archive}" || return 1
	# check it has correct extension
	[[ $archive =~ \.tar\.gz$ ]] || return 1
	# check it is in correct format
	tar --gunzip --list --file "${archive}" &>/dev/null || return 1
	# done
	return 0
}
# Function: dnValidUser    {{{1
# Determine whether user has user account and directory under /home/
#   params: 1 - user
#   prints: nil
#   return: 0|1 (true|false)
#   usage:  if dnValidUser "${user}" ; then ...
# fn_tag dnValidUser purpose Determine whether user has user account and directory under /home/
# fn_tag dnValidUser prints NIL
# fn_tag dnValidUser returns Boolean
# fn_tag dnValidUser usage if dnValidUser "${user}" ; then ...
# fn_tag dnValidUser param user purpose User to check
# fn_tag dnValidUser param user required yes
# fn_tag dnValidUser param user multipart no
# fn_tag dnValidUser param user type string
dnValidUser() {
	local -a users=()
	mapfile -t users < <(dnListUsers)
	local user
	user=''
	for user in "${users[@]}"; do
		[[ $1 =~ ^${user}$ ]] && return 0
	done
	return 1
}
# Function: dnVariableSet    {{{1
# Determines whether bash variable is set
#   params: 1 - variable name
#   prints: nil
#   return: boolean
# fn_tag dnVariableSet purpose Determine whether variable is set
# fn_tag dnVariableSet prints NIL
# fn_tag dnVariableSet returns Boolean
# fn_tag dnVariableSet usage if dnVariableSet 'proxy' ; then ...
# fn_tag dnVariableSet note Variable may exist but not be initialised, i.e., is null/empty
# fn_tag dnVariableSet param var purpose Name of variable
# fn_tag dnVariableSet param var required yes
# fn_tag dnVariableSet param var multipart no
# fn_tag dnVariableSet param var type string
dnVariableSet() {
	[ "${!1-one}" == "${!1-two}" ]
}
# Function: dnVariablesAvailable    {{{1
# Checks for all needed variables
#   params: list of variables
#   prints: message listing missing variables
#   return: 0|1 (variables all present|variables NOT all present)
#   invoke: dnVariablesAvailable "${variable_list}" || dnEndScript
# fn_tag dnVariablesAvailable purpose Checks list of variables to determine whether all are available
# fn_tag dnVariablesAvailable prints Message listing missing variable(s)
# fn_tag dnVariablesAvailable returns Whether all variables are available (Boolean)
# fn_tag dnVariablesAvailable usage dnVariablesAvailable "${variables_list}" || dnEndScript
# fn_tag dnVariablesAvailable param variable purpose List of variable names to check
# fn_tag dnVariablesAvailable param variable required yes
# fn_tag dnVariablesAvailable param variable multipart yes
# fn_tag dnVariablesAvailable param variable type string
dnVariablesAvailable() {
	# sanity checks
	# shellcheck disable=SC2154
	# • 'dn_commonbash_vars is referenced but not assigned'
	# • variable is provided by libvariables
	if [ -z "${dn_commonbash_vars+x}" ]; then
		echo "Error: cannot find variable 'dn_commonbash_vars'"
		echo 'Warning: is libdncommon-bash fully installed and loaded?'
		return 1
	fi
	# set variables
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No variable name list provided"
	local var retval found_var dn_commonbash_var
	var='' retval=0 found_var=1 dn_commonbash_var=''
	local -a vars=()
	IFS=' ' read -r -a vars <<<"${1}"
	# check for variables
	for var in "${vars[@]}"; do
		found_var=1
		for dn_commonbash_var in "${dn_commonbash_vars[@]}"; do
			if [ "${var}" = "${dn_commonbash_var}" ]; then
				found_var=0
				break
			fi
		done
		if [ ${found_var} -ne 0 ]; then
			retval=1
			echo "Warning: missing variable '${var}'" 1>&2
		fi
	done
	# return exit status
	return ${retval}
}
# Function: dnWarn    {{{1
# Print warning message to stdout
#   params: 1+ - message part(s)
#   prints: formatted message to stdout
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnWarn purpose Print warning message to standard output
# fn_tag dnWarn prints Formatted message
# fn_tag dnWarn returns NIL
# fn_tag dnWarn param part purpose Message part
# fn_tag dnWarn param part required yes
# fn_tag dnWarn param part multipart yes
# fn_tag dnWarn param part type string
dnWarn() { dnMessage 'Warning' 1 "${@}"; }
# Function: dnWarnDlg    {{{1
# Display warning dialog message
#   params: 1 - message
#           2 - title (optional)
#   prints: nil
#   return: nil
# fn_tag dnWarnDlg purpose Display warning message in dialog
# fn_tag dnWarnDlg prints NIL
# fn_tag dnWarnDlg returns NIL
# fn_tag dnWarnDlg note If variable dn_app_icon exists will use it for info dialog icon
# fn_tag dnWarnDlg note If variable dn_app_icon_all_dialogs true then also use for warn|error dlgs
# fn_tag dnWarnDlg param message purpose Dialog message
# fn_tag dnWarnDlg param message required yes
# fn_tag dnWarnDlg param message multipart no
# fn_tag dnWarnDlg param message type string
# fn_tag dnWarnDlg param title purpose Dialog title
# fn_tag dnWarnDlg param title required no
# fn_tag dnWarnDlg param title multipart no
# fn_tag dnWarnDlg param title type string
# fn_tag dnWarnDlg param title note Empty title is converted by subsidiary function to script name
dnWarnDlg() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No string provided"
	dnDlg 'warn' "${2:-''}" "${1}"
}
# Function: dnWarnStderr    {{{1
# Print warning message to stderr
#   params: 1+ - message part(s)
#   prints: formatted message to stderr
#   return: nil
#   needs:  functions [dnMessage]
# fn_tag dnWarnStderr purpose Print warning message to standard error
# fn_tag dnWarnStderr prints Formatted message
# fn_tag dnWarnStderr returns NIL
# fn_tag dnWarnStderr param part purpose Message part
# fn_tag dnWarnStderr param part required yes
# fn_tag dnWarnStderr param part multipart yes
# fn_tag dnWarnStderr param part type string
dnWarnStderr() { dnMessageStderr 'Warning' 1 "${@}"; }
# Function: dnZeroFileSize    {{{1
# Is file of zero size?
#   params: 1 - filepath
#   prints: nil
#   return: boolean (0|*)
#   needs:  functions [dnGetFileSize]
# fn_tag dnZeroFileSize purpose Determine whether file has zero size
# fn_tag dnZeroFileSize prints NIL
# fn_tag dnZeroFileSize returns Whether file has zero size (Boolean)
# fn_tag dnZeroFileSize param filepath purpose File to be analysed
# fn_tag dnZeroFileSize param filepath required yes
# fn_tag dnZeroFileSize param filepath multipart no
# fn_tag dnZeroFileSize param filepath type path
dnZeroFileSize() {
	[ -n "${1+x}" ] || dnAbort "${FUNCNAME[0]}: No filepath provided"
	return "$(dnGetFileSize "${1}")"
}
# }}}1

# SET FUNCTION AND VARIABLE LISTS    {{{1

# Function list    {{{2
# • greppable list of available functions
# • global variable set from loaded data
mapfile -t dn_commonbash_fns < <(declare -F | cut -d' ' -f3)

# Variable list    {{{2
# • all available shell variables
# • global variable set from loaded data
mapfile -t dn_commonbash_vars < <(declare -p | cut -d' ' -f3 | cut -d'=' -f1)
# }}}1

# vim:foldmethod=marker:
